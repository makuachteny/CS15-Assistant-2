Uh, the solutions are not published yet. Um, which is a pity, I suppose. But you'll tell me what the solutions are, and then I can just publish yours. That would be the best. That would be ideal. Um. We may talk about it a bit today. I took kind of snow slides and chopped off the stuff about Huffman trees and just kind of put them there. Um, if we have some time, we can look at them. Um, but I'm mostly interested if there are any quick questions. And then we're going to talk about trees, which are super, super cool. You don't have to ask why you should be super cool. You'll find that out. So everybody said for the exam, no questions. Perfectly clear. This is great. Confidence is good. Okay. It will happen. Um, it'll be in here. And, uh, um, if anyone requires accommodations. Um, I my assumption is I have already been in touch with you either at the beginning of the term or recently. Um, but if that's not true, you should email me, like, now.

Um.

And just let me know. Um. All right, uh, questions, of course, are welcome. Piazza. How did lab do? Was lab all right?

UNKNOWN
All right. Um.

Okay. Uh, so this is after we've done, you know, all of our different variations on trees. We've done, you know, what is a tree, a general tree, a binary tree, an airy tree, binary search trees, uh, self-balancing binary search trees in the form of AVL trees. And, and we're going to study heaps so that so more trees are coming. This is another kind of tree that we're going to look at. And um, uh, and this one is kind of cool. And I remember when I learned about it, um, it was just I found it fascinating. Um, I was reminded when I was sort of looking through old slides that, um, years ago, um, Professor Greg, who's not here anymore, he started a thing that I did for a while, but I'd forgotten about a Unix tip of the day, so I thought, uh, maybe I'll revive it, at least for one day. And, um, before we talk about tries, um, I'll just give you a hint, because, um, being useful with the unit of being sorry, being, um, relatively fluent in the Unix Linux shell is a real professional advantage. Um, almost 100%. Not not 100%, but almost 100% of the world's supercomputers are on Linux. If you're going to do any kind of large scale, high performance computing, it's going to be Linux, except for a couple of oddball cases, right? IBM does their own thing, and, um, they're a few, uh, if you do any embedded devices. So these days we don't drive automobiles. We have computer networks on wheels, and I'm not joking about that. That's that's real. A typical automobile now has anywhere from a dozen to two dozen, even even three dozen computers in it. And in fact, there's an industry standard computer network specifically for computers in cars. There's a standard for this. And guess what?

They all mine.

That's right. All of them. If you do any web back end work, unless you're working specifically in like a Microsoft shop, it will the back end will be in Linux. So these are just really, really, really useful skills that can make you stand out for an internship or a, or a job. Um, and they can just help you get stuff done. So with that in mind, um, sometimes, you know, you're just you're typing so fast that that darn carriage return is killing you. It's slowing you down. So what can you do? Well, it turns out that you can put two shell commands on one line, and you can separate them with a semicolon. So you can do muktar, you know, because you you've left count 15. It's continued. And now you're at lab 256. And so in your 256 a week of of the class, there'll be a lab 256 and you'll, you'll muktar lab 256 semicolon CD lab 256 and you can do that, you can put 3 or 4 together. You can put a whole bunch. So if you know what you don't, if you know what you want to do, um, you don't even have to hit carriage return. You don't have to wait for things to finish. Right. Because you can type this even after a command that will take a long time. And you can type like 5 or 6 of them and then go and have a have a warm beverage and wait for things to finish. So that's your Unix tip of the day. Nothing to do with tris, just a fun thing. There's another thing related to that that I'm tempted, but one one tip per day. So I'm going to try to hold myself to that. All right. So before we start thinking about Tris, um, let's just think about binary search trees. And um, because this is also kind of midterm exam review material. So um, if you've got a binary search trees, binary search tree, um, operations you might want to perform include things like does this thing exist in the tree, in the set, in the data set, in the database. Right. If maybe whatever you're storing data in a binary search tree type thing, is it there at all? Right. Um, I want to add things. I want to remove things. I might want to find the smallest thing. I might want to find the largest thing. All of these operations are Big-O of for binary search trees. And that's all you know.

In proportion to the.

Height of the tree. In proportion to the height of the tree, which in the worst case is, uh, the number of elements in the tree order n, right. So if n is the number of elements in the tree order n, so order number of elements in the tree. Exactly right. Um, if it's an AVL tree, they are.

Is it log n.

Log n. Yeah.

So pretty cool right? Okay. Um, so I want you to start thinking about a particular application in a minute. Um, but, uh, let's start with just dictionaries. You know, we want to, um, we've talked about key value pairs, so maybe we have words and definitions. And this is my OED. And I didn't take a very good picture of it. Um, but it's there. And so in this, uh, two volume set, which is a reduced version of a um, of an eight volume set, uh, uh, we have all these words and definitions, um, and sometimes have you noticed that, like when you're typing or you're, you're sending a text and you type a couple letters and then it tells you things that you might want to continue, right? How could you do that?

I didn't do that.

If you start off with something like this in electronic form and somebody types a few letters, how do you how do you find out what would be a plausible completion? And if you already know, then today's going to be very boring. But go ahead.

Yeah, I.

Guess maybe I, I was just saying, like with a dictionary, you would just look at the part of the dictionary that starts with those. Like if you have like the e s t, then you would look at the part of the dictionary that starts with s t. So like estimated or whatever.

Yeah. Perfect. Yeah. So you would start looking in the dictionary, um, based on the few characters you typed. And then all the words that start that way would be plausible continuations. Um. That's fantastic. So it tries a data structure that exploits that very idea. Um, and then by the way, if you open it up, it looks like that, and it comes with a handy magnifying glass, which I thought was so cool. Um. Okay. So, um. So we're going to use this thing called a try, which is also called, with respect to your idea, a prefix tree. Um, and, um, so that's what we're going to go. But first let's sort of understand because we already have binary search trees. Right. So if we already have the things in a binary search tree, let's just kind of remember what that looks like. Um, and we can put these words in a, in a binary search tree as an exercise for, you know, for the exam, you could just you could insert these words in a, uh, using the naive approach and then ask yourself if it were an AVL tree, would it be any different? Um, but I'm going to show you a balanced one, which is actually pretty close to what you might get if you submitted those in that order. Um, and we would get a tree that looks like this. Right. Um, and once again, if it's balanced. So if it's an evil tree or it happens to be balanced, it's, it's log n, and, um, if it's a, if it's a not known to be balanced binary search tree, worst case is four again. So it would look like this. And the thing I want you to notice is that this this structure doesn't particularly help us with the prefix problem. Right. Because all you can know is the thing. I guess if it's if something is a prefix, it would be sort of greater. But you know, it doesn't sort of give you an immediate way to solve this problem. Um, there is a thing called a ternary tree, by the way, just for fun, um, we said that there are binary trees in an array. Trees? Well, n could be three and that would be a ternary. Um, actually, quad trees are another thing that get used in geographic information systems a lot. So quad trees are another thing. Um, a, a ternary search tree divides keys up into less than, equal to or greater than. And that can be particularly useful if the equal to set um has a large, uh, is relatively large. Right. Okay. So, like, you know, a transaction history with the same individual, it might be a huge transaction. Okay. Um, but that doesn't help because that's log base three in. And, um, again midterm practice log two, log three, log ten log e are all order of each other. Because changing the base of the log only, um, changes a, a constant factor. And so they're all within a constant factor of each other when you take 160. What this means, that sort of cool is if you're doing a proof, you can pick the base that's easiest for you to prove. And then if you get a get something older log, then it then whatever. If the instructor would choose a different one, it doesn't matter. The the orders are the same. So that's sort of a useful piece of information to filing. Okay. Um, so we kind of already heard about it. Um, but let's just sort of go through the exercise. And if we if we look at the data, we start thinking, okay, we're thinking of new data structures, and we're looking at some examples to try to get a sense of what's going on. And we look for commonalities. Um. You know, and we might write down the words in a list and then we might observe that, uh, well, corn c or n cow c o w those have the, those share of prefix. Right. Um, fire and fish pit and pits, um, sand and snow. All of those things share a prefix. And in general, just I mean, this is a, you know, a particular sample, but would you expect this to be generally true of a Dictionary of English Usage, and the answer is yes, because we form plurals by adding s and s to things. So a word in its plural, the word will will not all the time, right? I mean, you've got person and people, you've got oddball things. But um, but a word in its plural will, will, the word will almost always be a prefix. Right? And for verbs we have ING and ed, we use different endings, um, to indicate, you know, um, different properties of verbs, past tense and present participle and all that stuff. So the truth is, you're going to find that you get a ton of these, um. Oh, sorry. Um, you get a ton of these, uh, these these overlaps, and we can exploit that. So this is these are the prefixes you're talking about. Um, and so I want to think about. Okay, well, if we're going to exploit this, and I've already sort of told you it's going to be a tree structure? Well, a tree structure. What is a general tree? It's either empty or it's got nodes and the nodes of subtrees and all that stuff. Um, a binary tree has at most two children. Um, a ternary tree has at most three. Um, if we were going to sort of, um, it's nice to fix n because then you sort of know what's here, what we call fan out. Right? Fan out is the, um, graph theorists call it out degree electrical engineers call it fan out. It's the when you have a bunch of things connected to one thing the size of bunch of is the fan out. Okay. And so we want to limit that. And if we're thinking about letters then we can ban, uh, we can bound the fan out by. And you've already seen it, but maybe you weren't paying attention. In which case, you can think about it, I guess. How can.

We?

I can give you another hand. We can put just one letter in a note.

What's that?

26. Right. Because if I put one letter in a node, then the the prefixes that could follow that have to start with a letter. And if we're confining ourselves to English language, then it's 26. It's another language. It's whatever their alphabet is. If it's Ascii text and it's size of Ascii, which is 128 for regular Ascii, 256 for um, extended Ascii. Um, now, I'll grant you that 26 and certainly 256 isn't quite as nice as two, but it's at least bounded. And, you know, and in computer terms, it's not that large. 26 actually isn't bad. Um. Right. So, um, so now each node will have a maximum of 26 children. Um, and so we can build a tree based on prefixes. And I'm going to do that. Okay. So that, um, so how would that look. Well, there you go. So here's an example of a of a structure that we might want to represent. So we've got um now C potentially has 26 children right. So I'm not showing you things that are C, A and C. And so, so the um in the OS slot of C so c c is going to have 26 potential children. One will be all the things that start with a C and then have an A. Next. All the things that start with a C and then have a B next might not be any. They're um c and C right. So you've got the 26 letters of the alphabet and many of them will be null because, you know, there may not be anything that begins with, uh c x. Right. Um, but but the OTH slot is definitely not null for this. For the example words that we're looking at before. And so there's uh, there's an O there, but then words that begin with c o. Um, well there's an th slot of that o because c o n is a word and there's a w ith slot c o w. So everybody understand this, this structure. Just take a moment and let it sink in. Okay. So you can see what's happening. Words that share prefixes. They're going to kind of merge in a structure like this in the tree. Right. So the diagram I'm not showing the null pointers. And if I were asking you to program this um we do have a lab I don't think we'll do the lab. Um, you would say okay, well, it's a tree. So they're nodes. And we said that there's a character in each, um, node, so there's a character in each node. if this is a dictionary, you might also have a definition right? String definition or something. Right? You can put whatever your. If it's a key value pair, you can put whatever the value might be in here too. Um, the interesting thing that's a little bit different is instead of a left and a right or left, a middle and a right or a linked list, well, we could use a linked list. But here we know that they're going to be whatever the alphabet size is. So it's fixed in advance. Um, so that's a constant. I should have made it all uppercase. Um, so you'll just have an array of pointers to try. Knows. Oh, by the way, it's pronounced tri t. It's spelled tri, but it's pronounced like tree. It's not pronounced tree. Um, it's what kind of a tree? A tree tree. Of course, a trie tree is also not very a little bit challenging to say too. Um, so it tries to be a tree. Okay. So it's going to look something like that. And as I said, um, Array slots that correspond to successor letters. Um, if there aren't any things with that successor letter, you just put a null pointer, right? Which is what you would do in a binary search tree. Right? You've got left and right. If there's no left it's a null pointer. Right. So so far nothing new. We've just gone from 2 to 26, but otherwise. Yeah.

Um, so how would you differentiate, you know, between the, you know, what you want to count as a word and what you, you know, because like, you would want count obviously to count as a word and you would also want like cows as well. So it's not just if you're ending on a leaf, but you wouldn't want core like core to count as a word, even though it is. You can find it in the dictionary. So, you know, it's not just leaves, because some words are prefixes of other words, but it's not every perfect.

Observation, right? I mean, naively at first, you might suppose that the leaves are words. But we said that, you know, like, um, cows is might be in the dictionary and cow and cows are both words. And so what we're going to do is we'll just add a slot here that says if you end up here, this is a word, just put a boolean value in there. And the way I'm going to show that on the slides is with an asterisk. So if there's an asterisk then that boolean value is set to true. This is a if you stop here this is a word. Excellent. Okay. Um does everybody understand that conversation. Because that would be good.

So, um.

Like, every tree is for each letter. So every word starting with every letter. You think of forest like a tree for a tree.

Yeah. Okay.

Uh, yeah. And if you try to draw it, you go a little nuts. Um, I'll show you, um, I'll show you a forest later, But yes. Exactly right.

Um.

Okay. Right. Um, okay. So how would we use this thing? And maybe you've already figured it out, but in case you haven't. But sort of, um, think about it. So suppose I want to know if a word is in this very small dictionary. Right. And so I go to the root node. Interesting. The root node doesn't have a letter in it. So tries are going to be different from the other trees we've seen. All trees are going to have a root node. So there's not going to be an empty trie will still have a root node. So this is different from what we saw with binary search trees and AVL trees and binary trees. Then those cases we represented an empty tree is just the null pointer. There were no nodes in an empty tree, no nodes in a in a in an empty linked list. Right. Um, here an empty trie is always going to have one node in it. Um, it doesn't correspond to a letter. Now of course you can't. There's no such thing as an empty variable. Right? So there's something in that slot. So you just have to keep track of that. It's the root. Um, I guess you could have some other boolean value, but mostly you just keep track and it kind of just represents the empty word or something, I don't know. Um, so there's always a root node. And so the way that you search for something once you've built one of these is you say, okay, um, you give me the word. Right. So if you give me the word corncob, okay, I go, okay, well root node, are there any. So see, are there any words that begin with C. Um. Oh yeah. Okay. So I've got some c. All right. So. Oh is there anything that goes without. Yeah. Is there anything that goes with R. Yes. Is there anything that goes with N. Yes. Is there anything that goes with C or and C. No. Um it's not in the dictionary. Right. So you start at the root and then you go through this the search string letter by letter. And you see if there's a path and if there's not a path, then the word is not in the in the tree. So if you run out of nodes or if you never get started because you run out of nodes right away, there's nothing in this tree that begins with Y. So you be at the root node. You look at the first letter Y and find it's not there, not there.

Okay. So just to clarify, the root node is always going to be empty.

Well, um, uh, logically, yes. I mean, in terms of computer memory, there's no such thing as empty. So it's a, it's a matter of programmer, um, conceit and algorithmic structure that we, that we treat it as empty. Okay. Right. So, um, it doesn't it, um, logically, it doesn't represent a character at all or a word. Right? It's just it's just kind of there. Um, but at the moment, I haven't said how we represent that, and you don't really have to represent it. You just in your algorithm, you start at what you know to be the root node, and you don't look in there for a character, so you just do this. And so if it has a it has a char box in it, but you don't look at what's in there.

So unlike the other trees we've looked at so far, we've never had a height of negative one. So uh.

Uh, if you're measuring it by nodes, that's true, that's true. Um, you could make a new definition specifically for Tris, where you count the height below, below. But, uh, but what you said is true, given what what I said and given our past definition. Yes. So the the height of a tree, given our past definition, will never be negative one, because there will always be one node. Um, but it doesn't represent data. Um, I really want to hammer the idea that you can't have an empty memory location because we yearn for this at the beginning, and we sort of believe it because people tell you that, you know, a variable is like a post office box and you know, you can go to your post office box and not see anything in there. You know, no letters from home. Sad, because that can be the only one to walk away. Um, but um, but variables aren't like that. A bit is either 0 or 1. It's not zero, one or emptiness, right? It's not like that. There's always exactly one data value in a bit. And if you've got a bunch of bits in a byte, there's exactly one combination of eight bits in there. You've got an integer. There's exactly 132 bits in there. Um, no such thing as emptiness. And we're going to see this later with some of our other data structures, where we're going to have to encode emptiness, because you cannot look at memory and determine whether it's empty or not, because it's never empty. You can just determine that the value there is not a reasonable one or what you might like. And there's a question.

Um, in terms of.

Like time for a trigger. So what? It takes longer to find a word That's like, for example, ash is like the most will have the most words. I don't know if it is like, let's say that like there's the most words under Ed's, or would it be the most words along the longest word in the alphabet?

Oh, I love this. So this is a perfect question, which I want to save an answer later. So just so perfect question. Um, and everybody sort of think about that because we're going to, we're going to discuss, um, algorithmic complexity a little bit later. So we're going to come back to this. But it's a perfect question to ask. Um, so wonderful. Uh, always have a root node. Um, I showed you how you use it. Um. Um, okay. We look in the oth slot. Yeah. So, um, um, so notice that. Oh. Um, right. So there are two ways you can find if you're looking for a string that it's not in the tree. One is that you try to look for it, but you run out of notes. The other is that you. You don't run out of nodes, but you run out of letters in the search string, and the node you're on isn't a word node. So for example, if I asked if phi phi is a word, you would say, okay, we'll start at the root node. Look in the F slot. Oh there's something there. So we got words that start with that look in the ith slot of f. Okay. We got things that begin with I um oh there are no more letters. So have we found a word? And the answer is no because the I'm a word Boolean value is set to false there. There's no excuse okay. So those are two ways you can find out that a word is not in the dictionary. You run out of nodes where you run out of letters in the search string. And when you do, you've landed up on a node in the tree that doesn't represent a word. So those are the two things.

Perfect.

Um, okay. So, uh, so now we're going to come to your question. I thought there were a couple more slides before this one, but. Oh, well, um, we're here. So then your question was better time than I thought. So here we are. Okay, so what's the cost? Well, um. If you're searching for a word of length three, you never have to go deeper than three in the tree. If you have a word of length ten, you never have to go deeper than ten, right? The descent through the tree is independent of the number of things in the tree. So if the number of words in your trie is n, the time it takes to find a search string is independent of n, it's in fact proportional to the length of the search string. So this is so your question was, well, if the tree happens to be particularly bushy in the area where you're searching, is that going to affect anything? The answer is no, which is actually pretty cool.

Right?

Um, and this, this this is why you get so excited about it. It's like, oh, well, you know, order n order log n. Well, if it if you're searching for English words, there's a practical bound on the length of the word. Um, you know, most words are probably ten characters or less, but there are a few oddball words out there, you know? Um, um, so. Oh, gosh, I'm blanking on the, uh, super, super cow. Right. So that's one. And it turns out that my friends in chemistry are really good at making long words, and so theirs go well into the hundreds. Um, and there's a Welsh town that has a name that's like 70 letters long. So there are a few oddball things like that. Um, but if you if you regard the length of a word, if there's some practical maximum, then in fact, it's constant. It's order one. This is what makes it really good for doing completion tasks, right? Because you can easily do sort of a quick order one task while somebody is typing. It's very efficient for stuff like that. Uh, now it depends on what we say. N is right. If n is the length of the search string, then it's order n. If n is the number of things stored in the tree, then it's independent of n, but it's order length of search string. So we would give that a name. And if we have a practical bound on the size of a search string, say 200 characters, you'll never be more than 200 characters. Well then it's constant time. So, um, on exams and in job interviews, when you're talking about, um, algorithmic complexity, always, always, always be very clear about what N is. And if they didn't say n is the blah, blah, blah, blah, blah, then it might not hurt you. Before you answer the question to say assuming that n is and just put it on the table and then they can say, oh no, no, no, no, we're interested in complexity relative to something else. And then you have a conversation.

So if this is, you know, since this is better than log in to search for like a string, couldn't you also use this for integers like search for 1134. So go one good one go for you go for.

Yeah.

Um.

Yeah. So they're, um, if you describe them formally and mathematically, they're prefix trees over some alphabet sigma and you can say what sigma is and they can be numerical digits. They can be, you know, any collection of symbols you like. They could be bits, in which case we're back to binary trees.

Right. So. Okay. Um.

Now. Oh. So, um, something that we often sweep under the rug is if we're doing what Oh, is that a question. Yeah.

Yeah. When you saying oh length of word. Would that just go down to O of one complexity because it's a constant.

Well it's not strictly speaking a constant because we might have search words of different length. But in practical terms, if you're using it for an application where we're searching for English words, in a practical sense it is constant because English words don't get longer than, you know, 50 characters. So it's a there's there's not a crisp, you know, there is a crisp answer. The crisp answer is it's order length of search string. That's what it is. And then we can then have a secondary discussion about, do we know that the search strings have a bounded size or an a priori. You know, because somebody can sit there and type forever or they could take, you know, the contents of all of their files, concatenate them together, make that be the search string. But if we know people are searching for particular words, Then, um, we know that, you know, then words are not likely to be more than 50 characters. Then we could say it's order one, but that's under the assumption that there's a practical bound on the length of the word. Oh, I, um. In fact, we can even get a little bit more precise, because if you, uh, if if the string length exceeds the maximum height of the tree, then the height of the tree is the is the is how much time it would take. Right. So it's actually the smaller of the two. But when you build one of these things you know remember you're texting. So the thing you're looking up is definitely smaller than the height of the of the tree. Right. And the height is the maximum height of the tree is the length of the longest word sorted.

Right.

So again not proportional to n. This is what's so cool. Is that the the analysis. Well sorry where n is the number of words stored in the tree. Um, the analysis of searching is independent of the number of distinct words stored in the tree. It's a it's mostly the length of the search term. Or if you're going to get sort of weird and out there, it's the lower of the length of the search term or the longest word in the dictionary, the smaller of those, which is really so cool. I just the fact that it's independent of the number of things stored in the tree is just delicious and wonderful. Um. Oh, right. I was going to point out that we, uh, we often sweep this under the rug, and we assume that if you have two strings, um, string one and string two, and you say string one equals string two, we have a way of sort of assuming that that's constant time operation, but it's not right. What is it? The equal equal operation on strings. That's what equal. Equal s to the world. What's that? Think of the.

Word.

Right. It's the. It's the length of the smaller string. So if if n is the number of characters in the smaller string, then it's order in. It's linear. It's linear in the number of characters in the shorter string. So you can compare integers in constant time. You can't compare big numbers in constant time, but you haven't learned about big numbers yet. So there's that. You'll learn about the five.

Uh.

And you'll see why you can't compare them in concept. But so if you're doing a binary search tree, we often think about, you know, it's log n and the height of the tree, which is true. But at each stage you're doing a comparison that's order size of the key that you're searching for, the smaller of the key you're searching for in the peanuts in the node. Right. It's those things If you assume that they're sort of about the same, then it's it's length of stream. So just a thing to note that when we do a lot of these analyzes, we push them under the covers largely on the assumption that if keys are strings, they're probably not 300,000 lines long or 300,000 characters long. They're probably dozens. Um, but you sometimes find extreme things. Okay, so the good news, the fantastic news, the perhaps completely unintuitive news, is that we can solve this problem independently of the number of things stored in the dictionary. So that's the that's just the mind blowing good news. And there must be bad news. Can anybody guess what the bad news is?

Um.

I'm slicing.

For creating a.

Try. Be like, kind of kind of rough because it wouldn't be like the number of words that you're trying to insert. Times like the worst case height of the tree, which is like the longest word.

Well, it's the sum of the insertion time for all of the words, and the insertion time is proportional to the length of each word. Yeah. So it's proportional to the sum of the lengths of all the words which. So uh, so that wasn't what I had in mind. But that's an excellent observation. Is that, um, what gives a try? And its advantage, though, is that we precompute the try. And so we do pay that price, but you pay it once at the beginning and then you reap the benefits. Um, but it absolutely counts, right? If you, if people were allowed to, like, change the alphabet every time they typed this, this would be a problem. So that's absolutely. So there's there's overhead in terms of precomputation. And in 160 you'll see that a lot. There'll be an analysis of what they might call an online algorithm where you do everything as you're going and then one where you precompute pieces. And then if you take that out now, what's the time to to use it. Right. So that's a really good distinction to me. Um, I'm thinking of something that we don't spend a lot of time talking about in the class, but I did put it on the table. Yes.

Storage.

Storage space. Yeah. So these are like, the way I've described them to you. This is like, you know, this. It's terrible. The overhead. Um. So how much space is required? Well, um. Is it is it worse than linear, I guess is the thing where linear means what the the number of characters in all of the words stored in the in the dictionary. Let's call that n, right. Um, it's kind of proportional to that, isn't it? At least because we've got, we've got a node for each of those things. And then what's in a node? A character which if we're using regular chars in C or C plus plus is one byte. And then we've got 26 eight byte pointers 26 times eight overhead plus the boolean for word. And we might have other booleans in there too, which we haven't really discussed. But when you try to implement it, you know things have a way of popping up. So this is mind numbingly inefficient. Yeah, you've got eight meaningful bits and then you've got this, this giant array of of pointers, which is a nightmare. So the space constraints are pretty bad actually. Um, so um, all right. So that's true. And people who do tries have worked on this problem. And I'll show you a couple of things. But they they kind of do require more space than, uh, than a BST.

Yeah. Um.

Do null pointers use space?

Yes. Okay.

Um, so a pointer. So, um, whenever you have a variable and you've allocated it, it takes up that much space. It doesn't matter what you put in it, you can't shrink it or grow it. Um, and, uh, the null pointer has a particular value. This is more of a 40 topic, but it's short enough. I'll mention it. Um, the C and C plus plus standards do not say what the value of the null pointer is. You'll meet people around the world who think that it has to be zero. It does not in C and C plus. Plus, if you convert an integer to a pointer value and you convert the integer value zero, it must convert to whatever the null pointer is in your implementation. That's what the standard says. The standard says that there is a distinguished thing called the null pointer. It is not the address of any legitimate data value in any program. If you try to convert it to an integer, then you get zero out. And if you try to convert an integer to it, zero converts to the null pointer. And that's that's all it says. Our systems do use zero as the null pointer. So if you look in 4D you'll actually look at the assembly code and the stuff and the bits in memory, and you and null pointers will be zeros in there. But there have been computers where the null pointer was not zero. That's interesting trivia. Specifically, it was chosen to be things that if you dereference it, it would cause the operating system to get an alert and then it would crash.

Uh.

Okay. So one of the things we can do is we can try to, um, compress things in situations where, um. What was it? Okay, that one just said that. All right. Um. Any time you have a chain, that's just sort of one thing. One thing, one thing. So 25 of the pointers are null, 25 of the pointers are no 25 and three pointers are null. Um, you can optimize this by putting a string in the node. and then the string can be the length of whatever tree would be here along that line. And it's unambiguous because we're doing this just when it's 1111111. But if you do that, you still have to remember if you stop at any given place, is it a word or not? So now instead of one boolean value, you have to have an array of Boolean values whose length is the length of the string that you have there. And it basically says if you stopped at the first letter, is that a word? If you stopped at the second letter, is that a word? If you stopped at the third letter that can be compressed using using a bit flags, which again, we won't do in 15. But since we're on the subject, that's what that's what happens. Um, but the string, you know, you got to keep the sequence of characters. But this allows you now to store like pits. So we have four characters in the node. Um, and we have the 26, the array of 26 pointers. But now instead of having a 1 to 26 loss, you've got a 4 to 26, right? So they get better. Um, but this makes things complicated. When you do an insertion, if you have to break one of these nodes. Now it's more complicated, but so B small matter of program. It's complicated. But you sit down, you write down all the bases and you work it out. It's not it's not rocket science, but it's, uh. But that doesn't mean it's no work. It's definitely work. Right? So we can do this. Uh, so de da y um, so ko we can't shrink ko because o splits, but r n we can split. N we can join together and re and ssh fits in red. Right. So we can do stuff like that. And in fact, you can shrink any sequence where you have a straight line like that anytime. It's just sort of one child, one child, one child. You can shrink those sequences so you can do stuff like this and they use them. They use bit vectors and all kinds of fancy coding techniques to try to shrink them. Um, you know, so then you can use them on small devices and stuff. There are a lot of tools. You guys probably haven't used this. There's a tool called GDB. You should you'll learn GDB in 40, but I think we should teach it in 11. Honestly. Um, some of it. Uh, um, gdb rule is you can abbreviate any command by the smallest prefix that distinguishes it from all other commands. Can you guess how it works? I don't know if they use a trie internally, but that definitely would work, right? You type it. You can abbreviate any command by the shortest, um, unique prefix. Emacs does the same thing. And so eventually you learn what those minimum things are like. Um, if you screwed up something and you want to reload the file in Emacs, that's meta buffer. But are you really going to type r t hyphen fpr? No, it's meta x revert. Boo. Um, and then so I just happen to remember that's the shortest prefix. Um, so if we're going to write some code for stuff like this, what would it look like? Well, um. And there'd be a musical accompaniment. I don't know if that's the right theme song for this or not, but, uh, suggestions are welcome. Okay, so how do we search for a word? Well, um, you're always going to start at the root, and then what are you going to do? You're going to go through the, um, you're going to go through the characters in the search string, right. And um, you're going to so whatever, um, your current node is, you're going to see if there's, uh, you're going to, you're going to start in this node and you're going to find the, the slot corresponding to string sub I the ith character of the string. So again the first time that will be the zeroth character. The first character. Um, and you'll look that up. And if you find that the child pointer is null, then not here. Right. Because you have a character, but you didn't, you didn't have a node for it. So not there. Um, and you just you just keep doing that. And then when you get to the end, you just ask, hey, is there a, uh, does a word end here? That's it. So it's really pretty simple, I think. Does that make sense? But the cool thing is, again, we're the primary iterations. We're going through the characters of the string. And as a byproduct, we're tracing our way through the through the try to try to keep track. Um, this fine child is sort of interesting. How are we going to do that? Because I've got an array of pointers. Right. And there are 26. So the indices of my array are um 11 review. Um, well, we just if I have an array of 26 things, what are the valid indices of that array. Zero 25 0 to 25 inclusive. Right. But we have these characters and we can assume that they're Ascii characters as you suggest. Um, well, the Ascii code for A is 97, lowercase a, um, b is 98, C is 99. There is no slot. No 99 slot. Right? Yes.

I don't quite understand. What's that? I don't understand this function.

Which part of this?

Um, specifically for.

What it's doing. Okay, so the for loop is going through all the characters in the string. So we're searching for a string S that's my search string. And I'm going to go through each character and I'm going to start at the root note. And so I'm starting with the root note I'll actually I'll start at the root note. And then I'll look at the first character of the string. That's the first time through the loop, because we will assume that if the string is empty, then there's not going to be a word here at the root. Okay, so let's assume the strings are not empty. So um, so I'm going to find the the slot in my children array for the first letter of the string. So suppose I'm searching for, um, I need a short a and and. Right. Um, so I'll say, um, okay. Um, well, let's look in the ath slot of the current node, the root node, and see if we and get back that pointer. That's going to be our next current node. We're going to go there in a minute. But first make sure before we go there we want to make sure it exists. So are you a null pointer if you're a null pointer. Nowhere to begin with eight. We're adding it. If I get back a null pointer I step on. And now so current is now the node that has a the first level node that contains them. And then I'm going to and then plus plus I. So I'm going to go to the next character in the array. That's n. So now this node I look in the nth slot. I get back the uh, pointer value that's there. If that's null, then I'm done. If it's not null, then I go to I go on to the nth the n node. Does that help? Thank you. You're welcome. Um. Now, always, always good to ask. Don't suffer in silence. Suffer noisily, and then we'll try to help. Okay. Um, so I sort of want to focus on that one. And, um, and that's the thing I was talking about is that the Ascii codes are going to be things like 97, 98, 99, 130 or 12, 26, 97, plus 26. So they'll be in that range, right? Um, so how do we find the slot? Uh, you haven't said anything today.

If they're all lowercase.

We can just.

Subtract.

The value of the first character in the alphabet.

From. Right? Right. Because the first slot belongs to a the next slot, it belongs to be. The next slot belongs to C, and the Ascii codes for ABCd through Z lowercase are all contiguous. So all we have to do is kind of shift the index from 97. So 90. So Ascii 97 becomes slot zero right. Because that's the zeroth character in the array. Um, the the one ith character in the array is going to be b. So 98 has to go to B. Um sorry. So b is going to be 98. And 98 has to go to slot one. 99 is going to be C. That has to go to slot two and so on. And so you can implement this function easily enough. By just taking the characters Ascii code and subtracting the code for a front. Style point. Um, if you write code that manipulates Ascii, what I find, um, probably about half of students do is they look up a in a chart and then they just write 97. They're demanding that any future reader of the code memorize the Ascii chart. If if the code you put there is the code of a letter used it just tick a tick in C plus plus. Oh, do you guys know this? In C plus plus chars are numeric types and weirdly you can have signed and unsigned ones. You can have negative chars. I know, I know it's an oddity but it's the way it is. So C and C plus plus expose the fact that chars are represented by binary values that can be treated numerically. Um, and the Ascii code is particularly good. It wasn't quite so good and the alphabet wasn't all contiguous. So that would be a bit of a problem. But Ascii did a good job. All the lowercase letters are together. All the uppercase letters are together. Do you know which one, by the way? So we we veered into a little bit of trivia, but it's good to know. It's good to know this stuff. Do you happen to know if uppercase is less than or greater than? So some of you are indicating, I think less than. If I'm reading you right. Yeah. So the so uppercase Z is less than lowercase a. So for example when we do our sorting unit this could be interesting to note, which is why a lot of times when you sort string data, you convert everything to lowercase, or you convert everything to uppercase to get rid of that, that that oddness. Okay. Um, so we've we've found that we can take the Ascii code for a letter for a letter, which means it's, you know, it starts at a for 97 and then goes up through Z. And we can map that to a range 0 to 25 by just subtracting the value, the Ascii code for a from whatever character we're looking for. And then there was a question somewhere. Okay.

Um.

So if yeah, if you say like that, like say c is literally the character C, and it's like C minus a. Is that not going to just return whatever the second Ascii character is? And like you can't really index a car.

I think I didn't quite get the first part. So what what what's the what's the situation again. So C contains a A character. Yeah. Now we're assuming it's in the range A to Z inclusive. Yeah. If it's not then we get what we get which is a really bad time. So somebody needs to do data sanitizing which I've left out.

But if.

If wouldn't like C minus a return a character or does it return an integer.

Oh, um, it does return an integer. But um, and I often forget exactly what the conversion rules are. It usually, I think actually the type of tick a tick I think is actually of type int, but then you can store it in a jar. Um, there are interesting conversion rules here. The most confusing ones involve sidedness, because, um, she was silent on whether characters by default have negative values or not. And that means that different implementations choose differently, because the minute the standard doesn't say everybody makes their own choice. And this can make writing portable code kind of a nightmare. Yeah.

I believe when you write a character in single quotes, uh, it will represent it as a number and then casted as a character.

Um, well, it's definitely a number. The question is, how many bits does it take up? Is it 8 or 32?

You will because you're cast, because it's the internal cast to a character. It will take up 16 of those.

Ah. So, um, anyway, we're way in the weeds here, and, um, the point is that this code will actually work and the conversions will happen. The the subscript will ultimately become an integer and be used to subscript the array. Um, so we'll be okay. Subscripts by the way, can be signed. And that's a that's a that's a different trivia. We'll do that. We'll do that.

Later.

Um okay. So oh um notice that this is constant time right. We're just calculating. We just take a letter, you give me a letter, you know, you give me t, and I just subtract a from it. That's constant time. That's just a arithmetic operation. So, um, so we nothing we've done here, um, says anything about, um, nothing we've done here affects the asymptotic behavior. If you want to see the full Ascii chart, you're welcome to do that. Um, but first.

We're actually going to do try. Once again I have to tape over my shoulder. So, um.

Right. So we can have a try that has a cookie in it. Um, and maybe. We go ahead and, uh, um. Folks have a favorite word. Of.

Like, chicken coop. Okay. Okay. What?

Are you going to test when you spell it?

Um.

All right. And, um.

Cool color.

So we can get these things, and then we can search for where is, um. Uh, copper isn't going to search for copper. No, copper. Copper is not any.

I didn't put it in.

Okay, so let's search for copper.

Okay.

All right. So we can have it.

Um.

So you can play with this and learn about them, which is fun. You can also add a list of words so you can do this and then just put the comma separated list. Um. Antler. Um.

Frog.

Oh. There was a somebody discovered a small toad, a species of small toad recently. You can do that. Or it's got a list of words built in and then we can get. I did not write this, um.

Chris Gregory. Okay.

Well, I inherited it from him, and it didn't have a name on it, but I'm guessing he wrote it because it's. When I read it, it reminded me a lot of him. Um.

Okay. Uh.

All right. So that's that's kind of it for Tris. Do you have any questions about, uh, about Tris?

We really, really cool it really, really cool. Uh, you're gonna have to.

Make sure that this.

Makes you implemented. No, but there may be an opportunity if you would like. So we'll see. So we have some projects where you get some choice of data structure. This could be an option. So definitely an option. Um I have a lab that we used to do for it. Um, and I can try to make that available. I can find it. Um, I found these. It'll be in the same place I found these, um, they're very cool, but you can play with them. Look up and read about them. Um, so that's all I had to try. And I guess we can use the rest of the time for any questions you have related to the midterm, or you can just go and study or go in and lie on the grass outside and enjoy the day.

One question. Wait. I can't hear you. No. Okay. So.

Yes. Up to and including getting perfect.

All right.

Go forth and study, everybody.

Yeah. Okay. No no no no no. That's so bad. Oh, yeah. I think John Tyler. Okay, that makes sense. Um.

Good.

Luck. Oh, yeah. Yeah. I have seen that before. Okay. All right. We don't need this nonsense. I have the room for another. Big office. I don't care.

Very spacious. Yeah. Cozy.

The station's In order to gain back the. Spanish you need. Something. Like this. You know the process of getting into season 60. Was that one of the classes that you need to apply to? Uh.

Yes. And like 40. They're changing the rules a little bit, and I think they're doing it similarly to the way we're going to do it in 40. So I think I know. Um, the plan is they're going to identify groups that can just register on CIS. So what we're doing in 40, for example, is we're going to just anyone who's a junior or a senior or a post back can register for 40. You don't have to do the you don't have to fill out the application. In fact, we don't even have the application up yet. Um, our plan what you do in 40 is if you're not in the group, that automatically gets in. Then when you register, you register for a waitlist section. So it would be like another section, okay. And you register for that one. And I think 160 is doing that too. And then our plan in 40 is once people have registered for the waitlist section, we will send them the survey. And then and then we'll do our thing where we prioritize. And it's still like, you know, the closer you are to graduation, the the more important it is to you and the, you know, CSE majors always come first, um, CSE minors before tourists. Um, but there aren't there aren't many tourists in 160 day thing.

As a yes major sophomore, I can get an exodus. Uh.

For which 101 60. Uh, you know, I honestly don't know. For 40, um, I'm not quite sure what the numbers are, but I expect, based on the numbers I reviewed a few weeks ago that we should be able to take most, we should be able to take. Many of the software's will be more than half, I think. So, actually, more than assuming that my estimate of the number of sophomores who apply was accurate, I think we will be able to take over half of them, but there might people might come out of the woodwork and then I have no idea. The big question mark is a lot of people who try to take 40 haven't yet declared their major. So it's right at the point where people are declaring. And so it makes it a little murky because you for 160, we can ask the question, you know, how many juniors are, how many junior CSE majors have not taken 160 yet? And that question for 40 is almost impossible to answer accurately, because you've got this group of people and you don't really know how many there are. So I think 160 is going to do something similar. Um, I don't know whether, you know, have you looked on this yet? I think someone emailed me and said that the waitlist section for 40 wasn't there yet, which disturbed me a little bit. Um, you're. Something's wrong with.

This. There's also. They're also missing some, like.

Like lectures or lab sections and some.

Classes.

Uh, yeah. I think there's some error with 116. That's that's kind of, uh.

Oh, God. Yeah.

But I fallen out of sync. My, my ex password was expiring, so I reset. I, I try to not do that during the semester because it's. Well, it wasn't too bad just now. I just had to retype the password to get a. This is, um. So you're asking about 160. Let's look it up. Let's see. Um, me, I'm very curious about 40.

One. 60. 60. If anything.

I'm teaching 40 in the spring. I'm teaching 40 in the spring, and I'm also teaching my concurrent programing course. Okay, so I see the online 160, which isn't relevant to you. That's the M one section. And then the on the ground section has a section one and a section two and section two. Yes. Has. Okay. So I'm just looking at the enrollment constraint. So enrollment requirements for section one requires completion of 15.

No no no no no no no.

Um computer science or data science majors or posts back or grad students. Okay. So none it looks like they're excluding non majors. And then there's a class. No. Students who do not meet the enrollment requirements can request permission by signing up for the waitlist section. Section two. So? So what I said is true. You sign up for the waitlist section in recitation RW and then so section lecture two. Um recitation. Or you can try to see if you get in first. So I'll tell you how. So what you do is you put it in your cart and then you I'm told there's a thing you like validate cart. Yeah. If it validates, then you can just get in. And none of this, none of our conversation matters. But if it doesn't validate, what you do is register for section two and recitation RW or whatever it is, and then um, and then await further instructions.

All right. All right. Thank you. You're welcome. And do you have a question? Yes. Uh.

40 is going to do the same thing, by the way, if you care.

Okay. Uh, so I'm literally pushed.

Back, and I'm trying to, uh, here's the post-doc master's program in two years.

Okay. Can be done. Could be done. Yeah.

Sanity labels are independent, but.

Please preserve that. Because if you come out a useless wreck, then it hasn't been a worthwhile experience.

And I'm trying to, uh. I see 40 is listed as a requirement for. I think the prospects for a 40 adjacent class by itself does not count because the Masters. And I'm trying. Correct. I'm trying to figure out if there is a useful way for me to take another class and not, you know, bind both feet together while trying to do regular programing classes, because I've asked to a couple of a computer size, I'm not.

Sure I understand the dilemma. So, um, for the post back 40 counts.

40 count, 40 pounds for the post back, but it doesn't count towards the mass, but it does not.

Count towards the masters because it's under 100.

Right? Yeah.

And there are a bunch of classes that can fulfill the 40 requirement. But I'm trying to figure out if that is an actual useful jump to try to accomplish. And I talked to a bunch of computer science majors here, and they recommend that.

Um, our students are often very fond of 4D after they've taken it.

Um.

So my, um, my recommendation is usually for someone in the Masters or post back whether they should take 40 or not. Um, first of all, I must acknowledge a shortcoming of our curriculum, which is that, um, there are upper division courses that require 40, in particular operating systems, for which I, uh, no, that's one of the. No. What if I if you can take it out 40 minutes. That's programing languages. Um.

And.

The problem is that master's students might want to take operating systems. They actually need some of the content of 40, but they don't need the whole ordeal. They don't need the stuff that students spend most of their time on. In fact, they need the but they need the core material and, um, machine structure and assembly language programing. That is the the the overt mission of for you. Um, and Dave and I have been talking about this for years, but nobody ever has the time. What we would like to do is have some course that is basically like the CMU course that we use the book for, for the thing which is sort of very mission specific. Right. Machine structured assembly.

It's that.

That it's none of this other software engineering stuff. Um, and that gives you what you need to take the upper division courses that really required the 40 content. Um, and then so what we thought is it would be nice to have sort of an in the can online course that people could take that would be like a three credit course and maybe give it graduate credit so that they could take it as part of the master's program and.

Then also.

Be.

Part of my peers in the as much as the part of it does count. But also it's a five credit course, which means you pay a lot more. I pay more. It's less about for me, it's less about the pay as much as if I take 40. That's going to be the equivalent about two three level classes that I might be really interested in. So, for example, if I take 40, I'm probably not going to take that special topics in quantum science or the data security class.

Yeah. So so so we back up. And the question that I think you should answer, because you're sort of further along in your educational journey, right, is what purpose would it serve for you. And that means kind of thinking, you know, where are you going to go after the master's program? Because if you're, um, I'm guessing you're going into the workforce as opposed to.

It's unclear. If I were to quit today, I would go back into teaching or not. But today, if I were to go.

Back into teaching.

You teach, uh, high school math and science for really eight years ago.

Oh. Bless you. Uh, no, I, um, it's hard. I, I did this once. I was working part time at a company, and a friend of mine taught at the high school, and they had somebody quit last minute and they said, can you come in and teach algebra two? I said, okay, sure. And it was okay. It was okay. Um, but it's just different. It's just different because teaching 15 year olds is very different from teaching college students. And I prefer teaching college students, but I but I admire the skills because it's it's hard. It's really tough. And it's tough for reasons that aren't always related to the material. And that's the and I find that very challenging.

Kids are kids. Stuff happens.

Yeah. To put it.

Mildly.

So it was a good experience. I'm glad I did it and I'm not doing it again.

Um, well, anyway.

I have some uncertainty as well. If I were to actually end up with a master's today, I'd probably go back into teaching. But I'm also trying to get as much new experiences in the program as I can decide if there's something else out there.

So let's. Okay. So teaching is one option and 40 doesn't does not serve that goal necessarily unless you were going to teach that exact material which is on the way. So um, so then if it's not teaching, what sort of professional aspirations or of.

Still trying to figure that out, I, I know it could be research, could be a database to see. I would love to try look at some special topics, such as the quantum mechanics or the quantum computing courses to see understand what's happening there. Yeah.

So, um.

Our 40 I'm very annoying individual. Um, no, no.

No, you're uncertain. And I have been there many times in my life, so I, I completely understand and I'm not judging it because it it's a thing. Right? It's just what happens. Um, then you have to make decisions sometimes without perfect information. And that's just normal. So we just we gather the information, we can, um, so I'll tell you what 40 is good for. Um, so 40 sort of has two main pieces in terms of what students get from the course. There's the the nominal material, which is the stuff I mentioned, machine structure assembling by itself. That would be like a three graded course, honestly. And, and it would be a perfectly good one and it would prepare you for the stuff that's good for professionally is what we would call middleware or low level program. So if you're writing device drivers or you're working, you're working at a level where you really need to have your hands on, like the memory of the machine.

Um.

And you might not program an assembly language. Almost nobody does that anymore. But you might be programing at a level where performance matters or, um, or resources matter, where you might compile something and then say, well, this is not working the way I need it needed to, and you would look at the assembly and have to know what it's doing and then say, oh, I see where all the time is going and then make adjustments, right? So, um, that kind of work is very much at sort of it's performance optimization, but at a very low level. Um, the better performance optimization usually comes at the level of asymptotic behavior, right? I mean, if you can go from, from n squared to, to n log n, um, you kind of win. And, and you don't have to look at the assembly code to win to, to win that victory. Right. Um, so if you're doing like hard core, back end, low level stuff, um, the core material of 40 is useful. And the other piece is the software engineering piece, which is what students spend most of their time on, on this. And um, so that that would also be a three critical.

Uh.

I love this computer science math three plus three equals five.

Well, it's a.

Negotiation.

In the schools, right?

Um.

Yeah. And, uh, I'm not happy about it, I think. I wish it were less intense. Um, honestly, if where you are in your career, I think that second part is it it could be valuable for you. But really only if you're going to work at that level. I think the software engineering skills you would get by taking, say, software engineering might be more generally applicable. Um, so if you want to work in sort of relatively low end code, if you want to do like embedded system design or you're, you're working at, you know, unusually like compilers or something, but, you know, sort of hard core back end engineering where you're doing, uh, um. Uh, I'll give you an example. There's some there's some folks at Google and in Facebook who have done videos on stuff they've done internally that I often link to in this course because and I also link in 40 because, um. The algorithmic stuff is stuff that we learn in this course, but they get really into the weeds. Right? So like the Google one is they present a thing about a hash table and they realize that which we're going to learn about. And they realize that, uh, at any given moment, something I forget the number, but like 30% of all of Google's CPUs are at any given moment running hash table stuff. So they realize if they can optimize this, they can get a big win. Right? And so then in the talk, they get into the weeds. And the first part of the talk is stuff that anyone in 15 should understand. After we've covered hash tables, they talk about chaining, they talk about all this stuff. It's great. And then they and then they go from there and they start saying, okay, how can we pack this into as few bits as possible and get as many cache hits as possible. And that's the part that links with 40. Gotcha. So if you're working at that sort of low level hackery, even in places like Google or Facebook, then that level of understanding is useful. Um, if you're not doing that, if you're going to be a front end web developer.

You know people.

You just don't do it. It's not going to matter. This the algorithmic stuff will matter. And the low level stuff you have so little control over, it's just not going to matter, right? You know what I mean?

Right?

And if you and if you're doing data science, you're doing data analytics, you're going to be you're going to be deep in the math and the, you know, you know, you're going to be writing systems of linear equations or having help us, you know, nonlinear equations and stuff.

Yep.

Yeah. And, um, and you don't need to look at assembly language code. You need to figure out what the hell this thing is. Computing.

And also the one thing I'm always hearing from all the computer science majors, they say it's less about the content or just about the experience of the work skills they acquire in that class. Help them figure out the rest.

Uh, no. That's true. So it does put you through sort of a grinder, but it, uh, you come out the other side far more capable. But I think that that particular experience may or may not be relevant to you. So I think what I would do for years, I would think more about the careers.

And you're looking at.

Some examples, we read some job postings. Or did you go to the career fair? Uh.

I don't believe I did, no.

Uh, get to the.

Career office and pay attention to them. Robin over there is very good. Uh, she's the only one I know, so I can't. I'm not saying the others are bad. I'm just saying I know one and one out of one is good.

That's a great sample size.

Yeah, yeah.

Um.

Um.

I just, I probably.

Look at job postings, but think about it like this. Think about your investment guy.

Um.

You're not learning about them or learning about chi.

I did.

And so you read the job things, and you talk to people and you say, well.

You know.

I see this, but what do you actually do? What do you come to work in a typical day? What do you actually do? You find that.

Stuff.

And then you think about what does I want to do that.

Was it hard.

Or, you know, when Kim hears that?

Yes. Sign me up. What do you see here? Oh, God.

That would. I would go crazy if I had to do that. Right. So you need to learn about you a little bit. And I would take the time to do that. And on the other side, you're also learning about them. So yeah, it has that benefit. You know you're meeting people networking. So the longer you. But so I would put I would make the prime thing be learning about you. And if the things that excite you are sort of down in the weeds. Oh my God. They packed that into minimum number of bits. Whoa. I want to do that. Is that just really lights your fire the.

Audience for you.