You know this guy is. Only. Joking about the fact you say that somebody has a heart. I don't, I don't think, I don't think I want to say what I think you want. I don't I don't know if this is. One of. You I don't. Know. How? Many. That's so. Small like I have.

So many.

Things I. Don't like. So if I ask on the final, that's the answer you should make. Yeah. If you want to come. Three. Two. One. Guys. That was an extra credit. One. Okay, um, let's, uh, let's start talking. Got a lot to do today. So the main topic is recursion. But I wanted to finish up something with invariants. And I want to just touch on file io very briefly. And then we will recurse and recurse again. So last time I mentioned invariants. Invariants are very important when you become a more experienced developer, when you start interacting with other people, when you start taking over code from other people, leaving code for other people. That is to say, when you start doing larger projects, however, they play a crucial role in 15 and 40, because we're going to see as we get into things like binary search trees, that the choice of your invariants can dramatically affect the efficiency of the operations you can offer. So it's not just an irrelevant thing, it's actually really important. And it's a key way to understand what we're doing. So last time we talked about so invariants are things or properties that don't change. And usually when we're talking about programs they apply a particular points in the program at this point in the program. The running sum is the sum of elements zero through I minus one, right. Or something like that there. Um, that's an example of a loop invariant which we talked about last time. So I'm just going to um, click through until I get to the part I want to talk about. Okay. Um, so just take a moment to review the checklist. Because if you're writing a loop invariant, very important for, uh, sorting algorithms. Um, the steps are these. First you figure out what the invariant is. That's often the hardest part. What particularly the right invariant. Um, and in fact, often the first version of any program I write I throw away because the first version I'm figuring out what are the right abstractions and what are the right invariants. And your first draft is almost always wrong, but now you know it's wrong. And so now you throw it away and write it with that knowledge. Um, so figuring out the invariants is kind of the tricky part. But document it. Then once you do that, then it's kind of a checklist. Once I know what the invariant is. Check that the loop initialization has established the invariant. It must be true now that. How many times have you written a program where there was a loop and you somehow didn't check when the loop didn't run because the continue condition was never true in the first place? The list was of length zero or whatever. Right. You must. You probably saw this in your linked list somewhere. Very common issue. Um, if before you do a loop, you establish the invariant, that basically means you're going to get the right answer even if the loop doesn't run right. So that's really key. Um, then when you're writing the body of the loop, you can assume it's true. So that can be useful to know. But of course, during the process of, you know, two things have to be in sync and then update one before the other. So they're going to temporarily be out of sync. Right? So that's normal. But at the end of the loop you can now tell yourself have I reestablished the invariant. Right. Um, so we're going to see a similar checklist in a few minutes. But I just want to refresh that in your minds because it's so important. Um, okay. So the other major invariant that we're going to talk about, um, and in fact, we'll probably see this one more than looping variants is something called a representation. What is that. Well it's something. It's something that's true of a correctly formed data structure. So given your implementation, given your representation of a credit card transaction, what if I were to be able to look at an instance? What would a correctly formed instance look like? That is, are there data members that have to have some relationship to each other? Credit card transactions. Again, you can't you know, you pay and you bill. You don't want to pay a not bill and you don't want to bill and not pay. You have to sort of get both pieces. Right. So that's an example of um, of something like that. If you've got a list that's that you must maintain in sorted order. We're going to talk about where that could come in handy. In that case there's an invariant where you have this array of elements perhaps, and every element has to be greater than or equal to the element on the left. I had to look because I couldn't remember if it was ascending or descending. But, um, you know, you have to pick. And so then you have an invariant like that. And every time someone adds a new element to the list, you can make sure that you, that you, um, make this invariant be true. So all of our data abstractions are going to have, um, representation. That's uh, the very first one we looked at. The size, capacity and data have to have certain relationships that just have to be true. The capacity has to be the actual number of slots available in the array that you that you use new to create. If that's not true, then these two things are out of sync and your representation is incorrect and buggy. Right? So that's the thing you can check. Um, size has to be the number of current elements the client thinks are stored in there. So that's the number of insertions minus the number of deletions. Right. So we I mean we didn't you had enough to worry about it. And that assignment and the invariants are not super complicated for that one. But but they're there and they can be very useful. And when I showed you the code last time when I showed you my solution code, I had functions that established invariants or verify them. Right. Index is in range. Okay. At this point we have established the indexes range. We can just assume it's true. Now, maybe not quite an invariant but a property of property. We've established a certain precondition. Um, linked lists. You know, front either points to null or some first node, not some uninitialized thing, which is eminently popular. And for early drafts, it's easy to not do your constructor and then it just points. You know, some random value. Um, each node's next pointer has to have that. Um, and the number of nodes currently allocated is equal to the number of elements in the list. Right. Now these sound like well of course those are true. But if you write them down then you can actually check your code. And you'd be if you've ever messed these up and I have messed this up, if you've ever messed these up, writing them down and checking can give you fewer bugs, but the invariants will get more complicated. Um, we haven't done binary search trees yet, but you'll see that we have a binary search tree that's going to have this particular invariant, that all the elements stored in one part of the data structure are less than some value. All the elements stored in the other part are larger. Okay. Um, so we have a checklist, and the checklist is pretty much the same. You specify and document the invariant. Initialization establishes the invariant where are instances of a class initialized. In the constructor that was a midterm exam review question. Um okay. So they're initialized in the constructor. So all of your constructors have what we might call a post condition. Or at the end of the constructor, all the invariants of a correct data structure must be established. If that's true, the second time someone calls any of the methods in the class, right? You can assume it's true, right? Because you established it in the constructor. It was true the client. You've made all the data members private so they couldn't screw it up. So then you can assume it. This is good news. But then if they add and delete things you're you're going to screw it up. You're going to do it on purpose because it's just part of the work. You have to you know, you have to update one variable before you can update the other. You just have to pick some order. They will be momentarily inconsistent. Um, but so you can assume it every time a public function is called. Um, the public function can temporarily upset the applecart, but at the end, you reestablish the invariant. If that's true, then that means the third time somebody calls a function. The fourth time, however many functions they call it, you will always have a correctly formed instance. So can you see how this. You've had math 61. There's a kind of inductive proof that's hiding behind this. If you haven't had 61, you will learn in 61 that there's a thing called an inductive proof that relates very strongly to this. So these are the steps. Um, they're easy. I'm not saying they're, you know, after they're after you put them out, they're, they're they're obvious. But most of us don't program this way when we start. And so it's worth mentioning. Um, so follow the checklist. And the checklist will not help you if the data members are not private. Because suppose your data members were private an array list and a client says, oh, I want to remove an element and they have a removed function, but you know, size minus, minus. It's okay. Right? Or worse, they want to add another size plus plus add a new thing to the array. Oh I've gone off the size of the array. You you I want my money back. Your thing is division broke, right? So if you let them get access to your data members, they will access them. They will screw it up. They will blame you. Right? These are the inevitable sets of public data methods. So just make them private and then they can grumble that they're not public. But then you can always say that you're leaning on decades of software engineering experience. And this is the rule. Um, okay. So I said that that's it on invariants. So I told you I was going to be quick. Any question about invariants. What's the course theme song. How can I be sure? Yes, by The Young Rascals, 1967. Perfect, perfect. Okay, um. Now I'm going to be equally fast. I don't know if I. Oh, um, I was talking to the. I was talking to him a lot earlier today, and that, um, I normally don't do a lecture on file I on 15, they cover it in 11, and we give you documentation. And honestly, there's only like three things to learn. If we give you a you know, if we give you a couple pages and a few examples, it's not difficult. But there are some gotchas and it's worth pointing them out. So I'm not going to go through everything here. I'm just going to hit the highlights. Um, okay. So in, um, in the Unix tradition, a, um, a file when you start to interact with the program is considered a stream. You make a file stream. The file is the stuff on disk. But to interact with the program, you turn it into a file stream. And a stream is just a sequence of bytes and you're going to go through them, you know, one byte at a time or one piece at a time. We can see in a minute, but that's the idea. So I think of them as like conveyor belts. And again, I can't really draw here. But if you imagine that I've got a program and I've got a file on my disk then, and I want to get the data from that disk file into my program, I have to connect it somehow. Right. And so we do that using something called a stream. And you've been around include IO stream streams, IO streams, input output streams. Right. That's what these are. It's for connecting your program to information in the outside world, using this mechanism where you have a conveyor belt that just brings bytes one by one into your program or one by one out of your book. Um. Okay, so you're familiar with a few. Wait, did I put that there? Oh, yeah. So I have a bit of a. There's a thing that bugs me. People say things like put a C in statement. There's no such thing as a C in statement. And it's the wrong concept. And what happens is a year later, people come to me in another course and they say, I don't know how to c in from another file. And that's because they think c n is a kind of statement, but it's not right. If you see x equal sign, why is that an X statement? Is it are you saying y or I've got an x y. That's what I've got to do here. No you would never say that. Well C in and C out and C are the same. They are they're ends of a stream is what they are. And in fact they're global variables that contain an instance of a stream class of some kind. That's what they are. They're global variables. So the verb in C in greater greater something is the greater greater. And so when we see x equal sign y we pronounce it x gets y. If we see c in greater greater x then we could say cn sends to x. You could say that. But we could say read x from CN. So then you just kind of rearrange the order like assign y to x, read x from CN. Right. You could do that. And the same with C. I've instructed the Tas not to use those terms CN and c out statements. But I'm going to I'm going to bet I've not been successful. Um, it's a hard habit to break, and I have occasionally said it myself up until people started complaining they didn't know how to write a CN statement for a file. And then I realized, that's your problem. You think it has to say C it. If those are just variables, you can replace them with other variables Like you can, you can't. You could assign to X, but you could also assign to Z. You can read from can, but you could also read from another variable that contain the stream if only you had one. Which brings me to our next topic. Um, okay. There are three kinds of streams that you will use manually. So C anchor and C log. There's another one are special in C plus. Plus when your program runs they're pre initialized before main. Before anybody hears about main this stuff happens. They're already kind of wired in. And they've got all kinds of special features. And you know deluxe wing bats and things and and so those are those are their own things. But when you want to deal with files, you're going to use the F stream packages. F stands for File Stream. All of these slides are up on um. Off stream is an output file stream output. You'll use those for sending output program output to a file If stream is for reading data from a files, you're going to get program input from a file. A lot of people pronounce it if stream, but that is I get bugged by linguistic things. Um, that bothers me because it sounds like, well, if it's a stream, but but it is a stream. It's an input file stream. So there's no conditionality about it. And if stream is an input file stream, it's not sometimes an input file stream and other times not. It may be valid, but that's or invalid. That's another question. So you can declare variables. These things are classes just like stream is a class. So you can just declare a variable. I would like to have an input stream. What type should it be? If stream input file stream you could call it input. You could. So just like I can pick other names for them, I can pick other names for any of those. I'm just giving names to variables. I've just introduced you to two new types and the library they come from. And in fact there are some. There's a third type EF stream, which can do both input and output, but I don't think we're going to need it. Okay, so if a stream is a conveyor belt and you declare a variable of type stream, well, the variable is one end of the conveyor belt, but the other end has to be attached to a file. Right. So right now if you just declare variables, you've just got this thing hanging off the side of your program. And it's like looking for data, but it's not connected. So how do you connect it to a file? You can use a constructor where you specify the file name. But another thing you can do, which allows you to sort of use the same stream object for different files, is at any point in your program you can open, you can do in stream, open and then give it a file name. Okay. So all the open thing does is it looks for a file with that name and attempts to attach the other end of the conveyor belt to it, and the conveyor belt either runs towards your program if it's an input file stream or away from your program if it's an output stream. But fundamentally, it's the same idea. We've got we've got a stream going between our program and the outside world. We create the the the portal in our program for the data to arrive or depart, and then we connect it to the thing in the outside world using open. Okay, everybody. All right. Sorry. What if like, the file you're passing in might.

Like, change names. And now I'm like.

Oh, that's interesting. Um, um, I was expecting you to ask a slightly different question. Um, which is. But you asked the question you asked, which is perfectly fair. Um, if if the if a file name changes while you're manipulating it, nothing happens. Because once the once the thing is connected, it's sort of connected to the file itself, regardless of the name.

But I was saying like, Um, let's say you have a specific. File name and let's say like a different instance, you're using a different file. It's not going to match up those names. You need to change the code.

Oh well these can be any string you like. So you can read these from the you can read the you can say what? Give me the name of the file you have your data stored in and you can type it in. And then you can open, you know, file name user entered. You can you can pass it anything you like. Um so that's important. They don't have to be quoted string constants. They can be any string expression can go there. It's just the name of a file. And you can get it any way you like. You can you can read it from another file, for that matter. But let's not go there. Um, the thing I thought you were asking about is what happens if you can't open the file? One reason is it doesn't exist, right? Um, interestingly, nonexistence is not a problem for output files. If it doesn't exist, the default is it'll create it for you. You can change that, but if you don't change it, it's going to create it for you. Good news if the file does exist and you open it for output, the other data is conveniently thrown away. Pay attention to that fact. The other data is silently and conveniently thrown away, and you will overwrite it with your new name. Again, there are ways around it, but that's the default. Um, you can still fail to open an output file though, so you can have failed to open an input file because it isn't there. You could also fail because you don't have permission to read the file. Right. That could be the case or an output file. You might not have permission to create a file in that directory. Like if you try to send your output to 15 something, you'll fail. I hope you'll fail. That's the plan because you don't have permission to write files in those directories or you shouldn't. Um, okay. So so because of that, you every time you open a file, the next thing you do is you want to check and, um, don't worry about exit exit. So you just have to assume exit failure is some convenient number at stage one, and exit just crashes the program just leaves the program. Yeah. So what this does though, is if it's not the case that I stream is open, then crash throw an exception loop again and ask for a new file name from the user. Do whatever is appropriate when you can't open the file, right? Um, and similarly for output stream. So whenever you do open, the next thing that happens should be test for success. And I've already spent too much time I need to be more disciplined. Okay. Um. You can write a function. Um, you can ignore this. We're going to I think we're going to talk about templates later. We'll see. Um, the template isn't the interesting thing. The interesting thing is you can write a function called open or die that takes A file takes a reference to a file stream. Never pass streams by value only by reference, either by pointer or by C plus plus reference. The C plus plus convention is always by reference. Never pass a stream by value. Never return it by value. Never use the assignment operator. Don't weird things happen?

Your input. Uh, streams that will not end.

Yes, because the internal state of the stream is. If it's inconsistent, weird things can happen. Um, so, um, here's the thing. You can write functions that take references to streams, and then you can pass it a string. You've known how to do that. You can try to open it. And then if it fails, you can throw an exception, crash the program, return false, or whatever you do for your application. Right. Um, so you don't have to follow a recipe where your code is cluttered with. Declare a variable a string variable. Open the stream. Check if is open. If not, is open. You can put all that in a function and hide it away. And I traditionally call that function open or die. Um, but you can call it something else. Um, yeah. There's a note about the templates, but that's not interesting. Um, this is just a way you can make it work for both input and output streams. That's all. Um, we'll see another way that works that's more relevant to you. When you're done using a file, you close it. That's it. Okay, so declare a variable to pound. Include f string. Declare variables. Use the open function. Use is open to check for success. Use close when you're done. It's important because if you don't close a file, particularly if your program crashes, then data you thought you sent to the file may not actually be there. So that's important to do. Yeah.

Like C and C out there. All both awful instances of IO and I think yeah you have to close them or no.

No you don't because they're destructors. Uh, do all the closing stuff okay. So that's a good question. You can close. I think it's been a while since I've tried, but, um. It's there's some it's a it's not an an if stream scene. It's it's an AI stream. So. Oh okay. So it has a slightly. And I always forget which things are, are removed from the interface. But anyway, the thing is you don't have to close the predefined ones because just as C plus plus initializes them for you, they take care of cleaning up at the end. So that's a good question. Um, Okay, so if I have a file, then how do I use it? Well, you already know how to use it because you know about print statements and read statements or get from statements and send to statements. Um, if I have an input stream, then I can I can extract data from it. By the way, the official name of this is Stream Extraction Operator. That's its official name. And the other one is the stream insertion operator. It sounds very bureaucratic. You know, you can't go to a board meeting and say, you know, less, less. You have to say, you know, stream insertion. We do that. Um, so, uh, so you can use the you can use those same operators. And this is why the question, how do I see in from a file is completely malformed because it just shows a broken concept map in the head of the asker because they think the statement is. They think reading input is called sin, but it's not. Sin is a place. Is is a default place. You can get data frame, but you can make your other you can make your own other places. Right. So that's the that's the big thing. Another thing that's very useful is sometimes when we're giving your programs input, um, we'll do it by line. So they'll be like, this data appears on one line and sometimes we won't say it's online. So like RPN calc doesn't do that. So you can use this if it's not sort of line oriented. But if it is line oriented you can get one line using the get line function. And I'm trying to think that it's at least one more. Two things I think I want to say, um, one is this when you're reading from a file, you can ask if a read operation succeeded or if it failed. So you can ask the stream failed, which means did something you do before cause a failure. If you've been asking every operation and it effectively means did the last thing I tried to fail or did it succeed? And there's another thing you can ask EOF and the file did the last thing I asked you to do and counter an end to file. Right. Very important. End of file and fail. Our questions about the past. So a lot of times people say, well, if I haven't reached the end of the file, I can read a value. Oh no no no no no. It means you haven't so far reached the end of the file. If you attempt to read something and there's nothing there now, you'll reach the end of the file. But there wasn't any data. So it's very common to have errors in loops related to these things. Uh, a a common example, a common way around this is to combine the operation with the check for failure because then you get the. This performs the operation and immediately checks for failure. Right. But the check for failure should always be after the operation is checking, not before. Yeah.

So without fail returns true. If it didn't fail.

No. Returns true if it did fail. While not get line fail. Yeah. Yeah. The English isn't very nice. Well, get line not fail. You kind of like to say or didn't fail or something. Um, okay. Yeah. So fail returns true. If you failed, there's a subtlety there that I'm going to leave off. I think EOF is the other one. Um, if you're typing into, um, on the keyboard and you're reading from c n, then if the person who's typing hits control D, that will cause an end of file condition to arise. Note for C S40, there's no such thing as an end of file character, though. Control D is just this weird contract we have with the shell that they should close the file when we hit it, but it's not the end of file character because there's no sense. Why might the file fail? Well, so if I ask you to read an integer from a file so greater, greater into an integer variable, suppose the. Suppose there's nothing there. You've already read it. You've you know, you haven't reached the end of the file because there are plenty of space characters there, but there's no integer. And so what happens is it keeps going looking for an integer, and it gets the end. It's I never found it. Or somebody writes, you know, hi mom. And I'm looking for an integer looking at H. Whoa. Failure or failure or failure. Right. So it can fail. Um, if you're doing a get line won't fail because, um, except by end of file. Really? Because, um, because it takes any bytes that you could find there. But the other thing is like if you extract an int that can fail, if the thing doesn't it look injury right and float and so on. Pretty much everything looks chiari. So if you read into a char variable then similarly that will happen when you get pregnant. Except there are rules about skipping whitespace and stuff like that. So that's how it can fail. It can fail because you're looking for an X and there's no X there, either because there's nothing or there is a thing there, but it doesn't look very XY. Okay, great. Great, great. Um, right. Here's a locution that's kind of fun. If you think hard, do you remember why the assignment operator returns a reference to the thing on the left? The thing on the left of the assignment? It's so you can stack up assignments right A gets B, get C, gets D, gets E, right. You can do that. You know that. You can do input stream sense to X. Sense to Y Sense to Z. Sense to my name. Sense to. Right. You can stack those up. Works the same way when you extract something from a stream. That operation returns a reference to the stream object. If that's true, you can take the stream object and ask, did you fail? So this is a nice kind of syntactic shorthand. You can always do this and then say in stream fail afterwards. But for loop construction this can be very useful. Simple. The loop coming up. I don't know. We're going to do the other. We're going to do this function first okay. So to the last two things I want to show an example of loop choreography. And I want to show this because very often it's very common in the Unix world to say to write a program that either takes data from the keyboard or will take it from a file and you've already seen redirection, but there's a way to do this kind of internally to the program. And we're going to put that in assignments. And so um, this is so so here's a nice solution to that. Um, it turns out that c n is an ice cream C out and Sierra are both streams. But if stream is what we call a subclass or derived class of ice cream, you don't have to understand what that means. What you have to understand is that because of the way the types work in C plus plus, we can write a function. That takes an ice cream note not if stream ice cream a reference to and an o stream, not off stream. And if you do that, you can pass it either an O stream or an off stream. Either an ice cream or an if stream. So you can pass in C in and C out or Sierra or C log. All of those are output streams. Um, but if somebody opens a file you can pass in those. So this turns out to be really handy, particularly in an upcoming project. You'll want to do this. Um, okay. I mentioned reference parameters always. You can use pointers, but if it's C plus plus we should use C plus plus references. Okay. That's all I want. Why isn't there an example? Oh, Pooh. Um. There is. But. It's not in the slides. I forgot, I just, um, I want to give it a try. Hold on. Nope nope nope nope, not that one. Or maybe that one. So let me just put this out there. I'll then begin it a bit and then we'll we'll see. Um, if you're not sort of combining things in the loop, then there's a little bit of choreography you want to get right. Um, so this loop is going through a bunch of numbers and checking to see if each one is a prime number and notice what it does. The loop test checks whether you fail, but it tries to read something first. Then the first time you run the loop, did that first attempt to read something fail? If it didn't fail, then we can process whatever it was that was read, and at the end of the loop, we try to read again and then we go back and test. So the standard loop choreography is try to read and then the loop is test for success process answer. Try to read again. Check for success process answer right in that sequence. I promise we will get questions at the outset. My program is reading the last data value twice. It is not reading the last data value twice. What's happening is you are processing the last reading at the last data value twice. Because you got a success and then you haven't reached end of file. So you go through, you read something, but it's not there. And since it wasn't there, the stream extraction operator did not update the variable. That's what if you reach into the file or you failed and the variable you were reading into isn't updated. And since it wasn't updated, you processed the same element again and only then you detected them. So this this choreography is something that you should learn and take to heart. Okay, I file I owe there any questions about file item. What's the difference between the stream and the ice cream. And then the ocean of the ocean. So I have a stream and I stream. Um. It's a bit beyond the scope of this right now. It turns out that every if stream is an ice cream, but not every ice cream is an if stream. So I stream this the parent class or what's called the base class. And then there are a bunch of different kinds of input streams you can have if stream is the one that we attach to files. And so that's what we're going to use in the class. But you can have other ones and they're all different kinds of ice streams. And so if you write a function that takes an ice cream, that means you're only going to use the ice cream operations on it. And that means it's happy to take an ice cream or an if stream or any other kind of ice cream. Uh, we haven't really talked about how inheritance works in C plus plus, but that's the for those of you who've in Java, it's the superclass. And so you can pass any subclass to it. If you have an in Java, you just have to take my word for it. And I will wave my hands vigorously and say that it works. So which one's the pirate class? The ice cream. Ice cream is the parent class. Ice cream.

Uh, so you will be able to treat them like one, like at a time of year.

If you use Gitlin reads one line at a time. If you use stream extraction, it reads one thing at a time. So, for example, suppose I have, um, suppose I have a line of text and it says one zero space minus sign two. And then I extract an integer. What happens is the string region one says that's an integer region of zero. That's an integer region of space okay. Integer. Done. Figures out that I'm in ten, returns ten, puts ten in the variable, leaves the leaves the conveyor belt with that space on the front. So if you read a chart, you would get the next space. If you try to read an integer, it skips whitespace. It's a space. Okay. Forget it. Space. Ignore it. Minus sign could be an integer. Right. Is the next thing a digit? It is are. We found an integer then. So it goes like that. And so if you use the stream extraction operator it just it leaves the conveyor belt with the, the, the the first unused character at the front. So it's not line oriented. And a lot of times, you know, line you don't want line oriented sometimes. So it's a it's a good question that will become clearer, I think, when we get to the next project. And if and of course we can review and we'll help in office hours. So just definitely now okay. I want to uh, I want to get to the fun topic because because it's the fun topic. Um, what do you mean? Oh, no. Oh, yes. Yes is the proper response. Recursion. Recursion. Recursion I often refer to as the Popeye spinach of programing. It does once. Once you understand that your programing muscles bulge and no problem is is outside your grasp. Oh, but you have to understand it first. But it's not hard. It's not. It's different. So it takes okay. It's hard at first, but it's not. It's not impossible. So you tell me what. What's a recursive definition. What does that mean? You'll often get I often see people on the web say, oh, you don't have to understand recursion. I've been programing. You're better than they are. If you understand recursion. And you're worse if you don't. Okay. I'm just going to put it out there. Understanding how to use all the tools is better than not understanding how to use all the tools. It doesn't mean they're not good. It doesn't mean they're not serviceable. But it means in this one area they are deficient and you won't be. Okay. So you have a question. All right. Well.

No, you just said what does makes it recursive. And that's how it calls itself.

That's a recursive function. So yes. Yes. The key idea is self-reference or self-similarity. So people who love recursion also tend to love uh, um. Oh. What's the what's the set? That guy at IBM, the, um, you know, the fractals. We like fractals, I can't remember what's the name of the set that defines the fractals of the Mandelbrot? Yeah. Mandelbrot was this researcher at IBM. So he's the one who came up with all those things. Um, so recursive definition refers to itself. A recursive data structure contains it can't contain an instance of itself because that's not physically possible, at least not in the limit. But it can contain a reference or a pointer to it to another instance of itself. And we've seen this in a linked list. And as you saw in the homework, we didn't really need to talk about recursion, because what's called structural recursion means that the recursive task kind of mimics the recursive data structure, right? A list is either empty or non-empty. Okay, here's my recursive function. Are you empty or you're not empty? Okay, what's the answer if you're right? So it very much follows the data structure. Um, a recursive function, as you perfectly put it, is a function that invokes itself directly or indirectly. So we won't see the second one today. Now you are all officially. So CSS 15 is a requirement for CSE majors, which means that you must join the CSE major club. This means that you go to cocktail parties and stuff like that. And so you must make and laugh at recursion jokes like these. Um, this is an actual search I did on Google some time ago. Recursion? Did you mean recursion? Ha ha ha. And, um, I found this one. Um. This is an actual index entry for a computer science textbook. Right. So, um, so this is a I worked on a book, but we only ours is indirect, so we have recursion. Com a mutual c mutual recursion, mutual recursion, c recursion, common mutual. So we so that was our origin. But uh, so okay. So uh, so now that you've understood the jokes, which after all is the most important part. Um, the, the big idea here is one that we use all the time in computing. Divide, conquer. And you have a big problem. You break it into pieces, you solve each of the pieces. Now, most people say divide and conquer because they think that's it, but it's not it, right. If if I'm going to design and build a computer, I might say, okay, you guys organize the CPU and the memory. Um, can you work on the disk drive and the disk controller? Can you guys work on the Bluetooth thing? Can you work on the mouse? And then you all finish. Are we done? Well, now we have to wire them together, right? They have to. You have to put the. You have to put the results together. Right. That's the glue part. Okay. So a recursive function solves a problem by breaking it up into pieces. Now there should be some. There will be some pieces that just look an awful lot like the original problem. This is self-similarity. It's the same. Oh, there's a delightful picture I used to put up and I meant to look at. I forgot there's a tourist town in the UK where they have a scale model of the town, but like, you can walk through the scale model. It's that big. And in the scale model is a scale model of the town. It's a it's a scale model of the model town. And then inside that there's a scale model of the model of the model town. And I forget how deep it goes. But but it can go a few layers because, you know, the buildings are like this big. You can you can walk around knee deep in the buildings. So it's pretty cool. Um, so one or more of the pieces looks like the same problem. And then you glue the solutions together. Um, it is traditional in CSS to use the factorial function as an example. So if you've forgotten what a factorial is, the mathematicians just write an exclamation mark after it because they find it very exciting. And the definition is the factorial factorial of negative numbers. I don't think they define that so well, lets us pretend it's not defined or it's not defined for us. But zero factorial is one. Um, any other number greater than zero is its factorial. Is that number itself times that number minus one times down to one? Okay, everybody all right? I don't think this is probably not new. Okay. So if we look at an example that's five factorial. We just took the definition and kind of replaced it. Everybody okay. Now um human brains love to find patterns. And one of the things you might do is you might observe. Wait a minute. That piece looks kind of interesting that that's exactly that's four factorial, right. But kind of factorial is the problem we're talking about. Right. So you're you're that little self-similarity thing is tingling. Now you've got that sense okay. That's pretty cool. So if five is five times four factorial then four is four times three factorial. You're getting the pattern right. Cool. Then, uh, the drumroll and we have we write our, Okay, so I think most of you have seen this. You've probably seen it in 11 or whatever intro course you took. Um, but you can see that it reflects the definition, right. What, what what is factorial of zero. Well that's one we know that if it's bigger than zero, then well, wait a minute. What we said is you multiply that number by a thing to the right, that is in fact the factorial of n minus one. So think if we ask for the factorial of one, what would this do? So one is not zero. So it'll do this. It'll multiply one times factorial of one minus one which is zero. Which will invoke it again is zero equal to zero. Yes it is. It will return one. And then this function will return one. It'll multiply one times one and return one. In fact. Let's try it out. Um, so here we're just going to do factorial of two because otherwise the stacks go off the top of the slide. But if you want to, you know, get some bigger space. You can write it yourself as much as you want. So main starts to run and means going to, uh, just call factorial of two. So main doesn't even have any local variables. We're going to call factorial. So factorial is going to get an um it's going to get a stack frame. You guys call it I think activation record stack frame. Um, and n is going to be down to two because we pass in two. Right. Is to equal equal zero. Um, no it's not. So we're going to multiply two times whatever we get back from factorial of one two minus one, uh, is one equal equal to zero. Well we kind of just went through that case. No it's not. So we're going to call again and it's already beginning to leak off the top of the screen. Um, is is is the top n equal equal to zero? Yes it is. So return one and then one times one is one. In the college level math. Here we go. And then two times one is two. And that's how it works. When I teach 11 I usually teach recursion before loops. Because if you've already taught functions, you can repeat without having to teach any new programing concepts at all. If you understand functions. How do you repeat? You just call the function. So the cool thing is, if you understand how functions work, you understand how recursion works. There is nothing new there. It's exactly C plus. Plus doesn't say oh no, they're calling the same function. No, it's just it's a function call. Whereas the function it's this one. Is it the same one you're in? Who cares? I've got other things to compile. Don't ask me these deep questions about existence. They called it a function. I've got a function. I'm calling it right, and it does the exact same process every time. So that's what's so cool. Repetition. No new mechanism, no new syntax, just functions. Functions. Um, in functional programing languages, you often don't. You don't have to do that. I love programing languages because loops confuse functions I understand loops. Tricky. Okay, so um, if if you're writing a recursive so if you're designing a recursive function or you're analyzing a recursive function, you want to think about two kinds of cases. There's what's called a base case. There may be more than one. And there are general cases or recursive cases. So base cases, recursive cases. The base case is simply a case where you know the answer. It may be complicated. You may have to like read data from a database and do all this stuff. It doesn't always mean simple, but it means no recursion is involved. Right. I can assemble it from the from other pieces I have at hand. Write that sort of base case is a recursive case is where you've broken the problem down into pieces, and one of the pieces is a smaller version of the problem you started. We were trying to get the factorial of five. Maybe if we knew the fact. If I only knew the factorial of four, I could tell you the factorial five. Right? So that's that's the self-similarity, right? If I, if if I'm doing the Towers of Hanoi problem, which I have some examples of, I don't think we'll see them today, but that's that, you know, like that kid's toy where you're moving the stacks of disks from one peg to another. It's kind of fun. Um, if I know how to move, if I want to move four disks from this peg to this peg, then I can move a smaller pile of disks to this temporary peg, then the big one, and then move the smaller pile. Right. Okay. So let's look at factorial. And where's the base case. Well it's kind of right there right. See no recursion. Um, when you're designing a recursive program, it's a good idea to figure out the base cases first. Um, and then the recursive cases, the next one. In this particular program, there's one base case. One recursive case. Um, when we're beginning with recursion, we often tend to have more base cases. So for example, it's very common in Lisp Recursions the base case is very often the emptiest. And then but very often you'll see pseudocode. It'll check for the empty list. And then they'll say And if the rest of the list is empty, that'll be another base case, which you could do. But if you construct it well, you can often just leave that case out. In fact, it's surprising how many student programs just comment those lines out and it still works because it would recurse to the base case and it would detect it the next iteration. Um, so you can simplify your code a lot. But anyway, start with what, you know, start with the base case. And then once you have that you can think about the recursive case. Key thing um, you must make progress towards a solution with each step. Right now it doesn't always have to be an integer that goes down. It could be a list that. It could be a pointer to a node in a list that moves one more node further down the list. Right. That's another way to make progress. You go toward. You march towards the end of the list. Um, there could even not be a value per se, right? If you're designing a robot and I want to go and get the drink of water. Then what I do is, do I see the drink of water? No. Take a step. Now go and get the water. Do I see? Can I reach the water? No. Take a step. Can I read the water? Not take the step? Right. So that's a recursive process. That would be a void function. Basically, it just, uh, you know, get yourself a marginal distance closer to the goal, and then and then it's the same problem again, only with the shorter distance. And, you know, notwithstanding, I hope to get the water eventually. You know, if you know this paradox, um, okay, uh, if you don't make progress, then life is entertaining for a while. So, for example, what's going to happen?

Is that it will.

Go forever or until it overflows?

Uh, yes. Which is the. So if you've heard of the site Stack Overflow, this is where the name comes from. Um, uh, so, um, in theory, it runs forever, right? If I have a machine with infinite resources or, um, if the program doesn't consume any resources, which in some situations can happen, um, it would run forever in this particular case, in C plus. Plus, it might not run very hard to tell. Um, Professor Mendelsohn and I were doing the final exam for 41, so we thought we'd put a, um, you know, a factorial function in. And have students deduced by looking at the machine code that it was a factorial function. And when we compiled it with GCC, there was no there was no recursion. It was a loop because the compiler had said, hey, how you doing factorials? I know how to do that, but it just it just got rid of our function. So we had to come up with a different question. Um, We're just turn off optimization. So so you can't assume it. But, um, mostly on our systems and C plus plus mostly can't do the optimizations that other languages can sometimes do. So in C plus plus what normally happens is you run out of space and you run out of space because you're trying to make an infinite number of activation records, but you don't have enough memory to store an infinite number of activation records. But you can store maybe a billion and then you run out. Or that's actually on our systems, the stack is actually configured smaller than the heap. So it's funny on our systems you can actually run out of space if you put things on the stack, but if you put them on the heat, you won't run out of space and it's the same amount of space. Um, but they configured that way specifically to catch these sorts of runaway recursions. Okay. Um, let's look at another example. And this is so, um, you guys know, the, um. It's not just NASA anymore. You know, there's space, all these people, but, uh, uh, there's a job when somebody needs to launch missiles and rockets into space, there's a job that somebody has to say five, four, three. Right? There's got to be somebody who has that job and has to be somebody who's very calm, because otherwise, you know, it's scary enough. You know, you got rockets and 200,000 pounds of fuel and you're sitting on top of it. And the last thing you want to hear is five, four. So it has to be somebody. So we're going to get a voice synthesis thing on that project. And we're just going to count down this thing. So we assume that we can send our data to a voice synthesis engine. And it'll, it'll it'll go um okay. So how do we countdown. Well. Let's see. Which? Well, first, can you think of a base case? If n is zero.

Just a laptop.

Yeah. They don't usually go zero. They usually go blastoff or we have liftoff. Very confident. We have liftoff while things are like exploding. I shouldn't make light of it because it's a dangerous business. Um, okay, so that sounds like a base case. If you get to zero, you can stop counting. You can just blast off. You're done. That's good. Like the engines. Off we go. Um, now, the recursive case is sort of interesting. Oh, sorry. If we're if it's not a base case, then what do we have to do? Uh, we have to recurse. Recurse and recurse again. We recurse. It's another one of those bad jokes. You're obliged to say from Okay. So we have to rehearse again. There's something else we have to do. We progress towards you. We have to make progress. Right. And how do we make progress?

In a smaller version.

Okay. We can we can call a smaller version of the function. And we'll go front to back in the green.

The the numbers affected by.

One. So we'll subtract by one for the recursive call. Excellent. And that was also what I was gonna say. I was just gonna say call it again but with n minus one okay. You're leaving something out though. Yeah. We actually have to say five. You can't just keep it your secret, right? And we have ways of. Right. Yeah. You actually have to say the word or, you know, somebody has to say it. In our case, we'll just print it out or, you know, we'll pretend we're going to say it. Um, I'll go down to Elaine's lab. I'm sure she's got the voice synthesis engine. So we'll just use users. Um. So we're going to say n and then we count down from n minus one and recurse as you guys told okay. So I don't think the code is going to be um. Super complicated. Stuff. Speak to me in C plus. Plus.

Uh oh. Um.

Well, we can't print anything yet because we need to check for the base case. We need to know what case we're in. Yeah. Yeah. Okay. If count is equal, equal zero is one version. Then plus one, then print. Blast off to see out. Yes. I'm going to keep doing this to you guys. Um, I'm going to say if somebody says to count down from negative ten, I'm going to go. Yeah. Blast off. You could do other things here. If it's less than zero, you can throw an exception. It depends on the application. In our case, we'll just blast off. Um, okay. And then the recursive case, I think we sort of know. You told me we say count, and then we count down from count minus one. Cool. Sorry. Okay. Um. Not surprisingly, it works. Um, now, I just want to ask you something. I'm going to skip the next few slides, but I'm going to pose a question. What if we reverse these two statements? What happens?

Would it just flip the order of the avoid what prints? So I would say blastoff. One, five, six, nine and ten.

Yeah. So we would count up that. Which is interesting because the activation records would still count down, but you don't print, right? So it would go down. And then the first thing that prints would be blastoff. And then after each return you would say the thing. So if you want to count up function, you rename it, you rename it up, and then you switch these two lines. Cool, right. Another approach is you could you could add an extra argument. So you could you could say count from two. Right. You can do that. Um, but this sort of pushes your understanding of if you understand that you can just switch those things. Okay. So quick review. Um, start off by thinking about base cases. What information do you need? What is the answer? Right. These are places where you should be able to get the answer with no recursion. The recursive case is a little bit tricky, and this is the part that works on the brain. And but this this makes you a better engineer. Why? Because a recursive function is both the implementation of a function and the client of the function. So to program effectively, you have to play the Jedi mind trick of okay, I'm going to implement this function. And I'm an implementer and I'm an implementer. Oh I have this problem. If only I had a function that solved this problem. Oh but I do. But how does it work? Not my problem. I just call it. Right. So that that mental trick really gets at this client implementation distinction in your brain and it really exercises it. Um, so, um, for the general case, you assume the function is going to work for all smaller cases, you assume it as a client. So now it's just one of the many tools at your disposal. Then you break the problem down where you try to engineer it so that you get a smaller version of the original problem. So, um, you have to make sure that you move towards a solution somewhere. Um, either you get closer to the bubble or the number gets smaller, or the string gets smaller, or the file has fewer characters in it or whatever. Right. Um, something has to take you closer to a solution. Um, then you perform any tasks you need to, uh, to take care of in the current call, which will involve solving other problems and then gluing everything together, and, uh, and that's it. I told you it was easy. That was sarcasm. I did tell you it's easy, but it's not true. Um, but it will become easier as we go through. Well, basically, from here on out, we just go through many examples as we can. That's the plan. Okay. Um, so we can do some from two. We can do exponentiate. We can do multiplying without multiplication. If we took the star operation away from you, how would you do it? Um, this one is sort of fun. I've done a different version of this, and I kind of like the way this one works. And then something called GCD and power. If we don't get through them all, they'll all be on line. And we. And you're welcome to discuss. Um, so. Some from two.

Well.

Why is it doing that? I've got an extra slide in here. Well, that's a pity.

Oh, bad.

Okay, what's the base case? So we have two. So that that's a good place to start. What we have to. So. And right away we have an edge case. If someone says the sum of 1 to 1, what do they mean? Should it include one or not? Basically, is it closed on both sides or is it open on both sides, or is it half open like we talked like we saw in your range errors. Right. We had a half open interval. So this is a reasonable question. And if you use various programing languages where this thing is kind of built in or things like it, like the Python range function, some of them in Python, they assume a half open interval. In Erlang they assume a closed interval on both sides, so it just varies. So we have to decide what we mean. So this is a great place to do that. I'm going to say that both the left and the right indices should be in. So that means that if I say sum from 1 to 1, I expect the answer to be one. And I have to do that because that's what the code looks like.

I can't change it.

All right. So what's the base case in that case. But very close.

Not equal to well equal to.

Then you could return the thing. You could do that. So that's one bit one kind of base case. Is there another one.

From zero to.

Yeah. If from is bigger than two then there are no numbers in the range. And so what's the sum of no numbers. Sum is well defined for this. So the sum would be zero. The sum of zero numbers is zero. So that should be okay. And I have to click through a shockingly blank thing to get to it. But there it is. And notice in this case we've got from from and to and the from value is kind of marching towards the two value. Eventually they'll be equal. But when they're equal we'll add from to whatever we get when we go. So eventually there'll be equal. We'll come to this case again. The front will be on the other side, and then we'll get zero back and then build up there. But the other one was perfectly reasonable and we just have to decide what we mean, and I hadn't, I had specified. These are fun. You said a wonderful recursion lab in 11 that I stole from you. Um, okay. Uh, how about raising the number to a power? Any insights? What do we. What do we think? Are we going to do? Well, what's the base case? Yeah, I mean, these math humans always are pretty. Mathematicians are pretty good about spelling out the base cases, so that's that's helpful. Um, yeah. So if the exponent is zero, then the answer is one actually provided B is not also zero. So I'll just say let's ignore that for now. You can throw an exception. You can do whatever. But for now ignore it. So a base case of the exponent is zero. Otherwise you can see we're going to follow basically the same pattern right. So the base case is if the exponent is zero what's the answer. If the if the exponent is zero it's This one.

Unless.

The base is zero. But I said not to worry about that. I should have written here. Assume the base is also not zero. I should have said that. There we go.

If you do this in logarithmic.

Um, you can. And so I want to leave. So that's a, that's an excellent observation. And let's leave that as an exercise. Um, because in fact that's a that's a good way to do it. So but while you're, while you're on the subject, this is, this is linear in exponent. Right. So the number of iterations is proportional to the distance exponent is uh from zero. And it requires that much space to space also proportionally, because there's an activation record for each one.

Okay.

And I don't know you guys getting bored yet, so multiply if we, uh, if we're using addition. Um, you can use one of these to count down and then just add up that so you can either add add end to you can either add in n m times or you can add m n times. Either way is perfectly reasonable. But um. Okay. So all of those have sort of a similar flavor. This is a good point to pause for questions. Is the next one is a little bit more unusual?

This could be a good question.

So who uses Sentinel? Anyway? Suppose something costs some number of cents. Well, maybe it costs 100 million cents. I don't know, because some number of cents. And suppose we have a certain number of denominations, let's say quarters, which are worth $0.25, dimes, $0.10, nickels, $0.05, pennies, $0.01. Right. Which is in the US, these are common, common denominations. So the question is if I'm making change, if you said, you know, can you give me, you know, this much money in coins, how could I do that with the minimum number of coins as opposed.

But it's in a minute.

And there's an example there.

You can call the function and the value will be the number you started with, minus the biggest number, the biggest coin you have.

So you're going to the recursive case. And the basic strategy if you want to minimize the number of coins, is if the amount they give you is larger than the biggest coin, then you're going to use the biggest coin. So you're going to give them one of those. So that's one coin right. But now you need to find out how many coins it would take to give them the original amount minus the value of the most of the largest. So for example, if I have 63, um, by the way, you can find certain denominations where this problem becomes really interesting, but we'll put that aside. Um, for 63. The biggest coin I have is, is worth 25. Is 63 bigger than 25? Yes it is. So that's one coin I can use. And then if I know how many coins it would take me to get from 63 -25, which is 58, I don't know, 38, 38, 30, 38. Um, then it's one plus that. Right. Okay. So we kind of talked through that already. Um. Now there's a little bit of a bug here, actually. Maybe.

Let's see.

So suppose I have $0.06, then, I'm going to say that's one coin plus six. I know that's going to work. That's going to work. Okay. Okay. I think we're all right.

Are you sure this is the correct answer?

Well, how can you be sure?

You have to think real hard. You can write a proof and you can test it. Those are always the answers. You can analyze the code and try to find edge cases, to sort of figure out where you know where you want to test. Of course, which is why we're making you do all this testing. How do you ever know that your code is correct, right?

Well.

The answer is if you're a human, it's never it's never correct. Um, so, uh, I went to a wonderful talk a long time ago. This guy really changed my view of testing, because I always thought of it as kind of this onerous thing you have to do. So I would write the code, test the Testing. But of course it doesn't work. It's of no use. So you haven't. If you write code but it doesn't work, then you haven't actually accomplished anything yet, despite your feelings of accomplishment, because nobody can. But I think it was Dave. So is this anyway one luminary in software testing? And he said, I love it when I'm finding bugs. I love it because here's the thing the bugs are there. If you're not finding them, you're testing is bad. It doesn't mean the program is good. It means the testing is bad. So he starts with the assumption that any block of code he's got is wrong. And as long as he can keep improving it, he's making progress. So that really should change my view on testing. I see that's that's an interesting point of view I like it. I like it. Oh, the bugs are there. They're there. Okay. Um, so that maybe. So we'll wrap up in just a minute. Um, I do want to mention that sometimes you will make a recursive helper function. You saw it for Prevent this.

We already did examples.

But this next one is sort of easy. So look through this on your own and then post questions on Piazza and talk amongst yourselves, and I'll see you on the way.

Out. I didn't. See the point. Yeah. This is. What? I would like to do. The phone was actually crying. I was crying. Like, I try not to cry. But it's all right. Yeah. I. Got one for you. You always have to have a unit.

But then what happens is sometimes we'll talk more about this. There's a the strategy we're using is called a greedy.

Strategy.

Where we always try to pick the biggest. And we can pick the denomination so that the greedy strategy doesn't give you the minimum.

But yeah, I know I was like, what? I had to make a play. Here you go to right here. Was that.

The weights? And the biggest thing.

Was I said, but I have like all my stuff right now. And I was like, oh yeah, it's easy. So I'm Like, uh.

So I don't I don't know if we could characterizations the denominations that work. And I just know that there are some that work and some that. And I, of course, do a lot of examples, but I haven't.

I think you have one. I don't know.

If you're asking me whether one is correct. I don't know, I just don't know. It's a good question.

No.

Because we know about this work because of the numerical systems, uh, like binary based. So yeah, it's only like exponents. And so I think.

That might work and that's it. Yeah.

And I think, you know, an honor system actually does work. The um, with 25 five, I'm trying to remember.

About one, five, five.

You have to have what. Yeah. Um, yeah. So anyway, um, there are systems where the greedy strategy doesn't work, and I don't have a good characterization for them, but they're not. They're not rare or hard to find. You're there. Is that a good question? Thank you. Um, I have a question.

So I've been working on mentorship.

Excellent. And I, as.

We all have, um, and I was trying to I was trying to implement the, like, uh, the, the stream and stuff like that and working on that. And I was just trying to see if a way to like, test that. So I, and I was trying to do it through the tests. Um, but I know, like, like my function takes in a, like actual like, as you said, like like a file stream like that. Yeah. An ice stream, and I don't. Is there a way to testing? Uh, like, actually still make that function work? Because for how do I connect it to an actual file. Well, you have to.

Make test files or test data files.

This is just so I could. So a lot of.

Our tests, that's how a lot of our tests your code.

Dot. TXT file. Correct.

Um yeah. So you can that's if you're reading the station's.

Text.

File. That would be a file. Then you could do that and you could make different.

Ones, right? You could. Yeah.

Station test stations.

Like three stations too, of course. But but what was happening was I was trying to do that. And then um, is is there like, oh, do I have to like include the station dot txt at the beginning or. No, you.

Know, so pound included just has to do with the header files dot h files and C plus. Plus did away with the H convention for the system ones. Yeah because they all had that h. And the observation was why are we making people type dot age where we can just sort of.

Yeah, yeah.

So so but um, but the include has nothing to do with the file. Okay. So so other other than you have to pound include the, the definitions for the library you want to use to open and manipulate the file. So that's the, the extreme.

Yes to the upstream. So if I want to unit test and I use one of those files inside like like aware because like it's like let's say the the function is called read file. And then I have like the name of the thing. I could just put station txt in there. Yeah okay. Cool. Okay. Then I think I was just implementing it wrong because I was trying to do that and it wasn't working, so I just didn't know if I could do that in the unit test. Should work. Okay. Cool.

Should work. Exactly. Should do that. Yeah. So sounds good.

Yeah. Thanks so much.

For your question. My question is kind of.

Crazy theoretical because I've done some recursion in the past. I'm pretty sure that you probably do that, like searching function or something.

Like, okay, well you see.

That you have a.

Recursion with a.

Loop decided that that usually.

Reverses.

How.

So basically we're going to see.

Exactly like how exactly.

Does like the stack keep.

Trying that.

It doesn't have to. So if you uh.

Because you have like a.