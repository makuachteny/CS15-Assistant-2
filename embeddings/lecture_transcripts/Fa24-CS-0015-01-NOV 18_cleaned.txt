As you may have observed, um, connecting to the screen isn't working, so, um, I could have just brought my notes from when I didn't use slides, but I didn't. So, anyway, um, we'll make do. It is supposed to come, so we may have a break shortly. We'll see. Um, but I want to go ahead and get started. Um, so we've got two topics today. Um, one is that and the other is, uh, hash tables. Um, okay, so you guys know what a set is, right? What's a set?

This is an unordered collection of elements where you.

Only appear once. Unordered collection of elements. Um. And no duplicates. Right. Okay. Um, so you've seen this in math. You can have a set of numbers, you can have a set of all kinds of things. Um, we can have a set of, uh, um, we can have a set of names. We can have a set of student IDs. In fact, um, at the beginning of the semester, I do this pretty frequently. I get a feed from CIS, I load my roster into either an Erlang or a Python program. I get the IDs out, I turn it into a set. I do a set, subtract to find out who's added the course, and then I can, uh, and then I can update my internal rosters and stuff and add only those people to Piazza and grade scope and write all the stuff that we do internally. So, um, so essentially these things you learned about in math, but they're surprisingly useful. They come up all the time. Um, in real life, you can have the sets of game players, any number of things. Um. So the set operations are you can sort of guess. Right. We want to be able to add something to the set. Um, we might want to be able to remove something from the set. We might want to ask the question is this particular element in the set. Right. So those are sort of key. And of course we'll probably want to have size and is empty. And those things um in addition to those Operations will likely going to want classic set operations like union, um, intersection and subtraction. So if you've forgotten your high school math, the set the union of two sets is the collection of all elements that's in either of the set. Um, so you you can think of if you take the two sets, you put them into one big set, except that there can't be duplicates, right? So you just each thing that's duplicated appears only once. Um, intersection of. That's too small. Okay. I'll have to write bigger. I haven't done this. Um, intersection is you take two sets and you identify the set of elements they have in common, the set of things that are in both sets subtract, which is the one I use a lot for finding out who's added or dropped. The course is you take one set and then you remove any elements from that set that are in some second set. Does that make sense? For example, suppose I have all the roster for CSS 15, and then I have the set of all the people who have submitted the assignment. I could do an entire roster minus set of submitters. That's the set of people who haven't yet submitted the assignment. And then I can send them a helpful email, or I can just alert my staff that we've got another 20 coming in or whatever the whatever the case may be. Okay. So questions about sets.

Can function.

Only I know in advance. It would be more fun. All right. So I'm going to skip through this quickly because you can't see it anyway. Um so I have a bunch of examples of union and so on. But I think are there any questions about that? You know, how set union and intersection and all that works, right? I don't have to show you that.

Exactly.

Um. All right. So we use them all the time. Um, the classic thing is you, you really mostly want to know is something in the set or is something not in the set? Do you want to know the relationship between two sets for the cardinality? Um, if I could share my screen, I just actually did that very exercise. I got the September in November rosters from CIS, and I just loaded them up and did a set difference. Um, you'll have to trust me. I just did it now. Um, when? I should have apparently been checking to see if this would connect. Okay. Um, so let's think about things for a minute. How would you implement this, given what you know now? How would you implement a set? You seem to be 615 graduates. So you're completely fluent in all the data structures and abstract data types we've seen so far. We have two. You haven't said anything today.

Um, yes.

Okay, if that makes sense. You can put things. If I've got n things, how long does it take to put them into an AVL tree? All of them. Not just you. Anyone. Can log n log n. I've got to put n things in and it's log and each insertion is is log n. Yeah.

In case. It was.

Said which is not mathematically it happens. You get like integers and characters. And so you could do like a priority queue.

Um okay so interesting in C plus plus you can't really put um, different types of things into one set. Now what you can do is you can make a thing that is, you can make one type that actually has multiple things in it. And we use this for the RPN calculator. Right. So we had a datum which could be a number or a code block or write whatever. Um, so you can do stuff like that. Priority queues are give you efficient access to things, but they're highly optimized for find max and find well priority queue is find the most important thing. And if they're implemented by heaps then that would then you want to find the minimum of the maximum. And that's they don't really give you an advantage if you want to do is in because they have that uh, if, you know, if I'm looking at a node and this isn't the value I want, which way do I go? And the answer is I have to go both ways so they don't really get. So that sort of structure doesn't really give you an advantage. But but uh, balanced binary search trees do um unordered lists would be that I guess. Right. So inserting is uh is constant time, uh, whether it be an array list or a linked list. But, um, searching for something is linear. Well, if you don't want to have duplicates.

Don't you have to search.

The array first are. Good point. So there are two ways we could do this. One is we could lie and tell the and tell the client no duplicates. And then we just keep duplicates and and that allows us to insert in constant time. Um, however that decision bites us later. Can you guess where it means?

Uh.

When when you remove. Right. Because now it's not enough to find the one copy of the thing and remove it. You have to find all the copies of the thing and remove it. So, um, so we've already seen that we can start to play tricks right behind the abstraction boundary. We can do all kinds of things, and we can play tricks that make certain things more efficient. But usually there's a downside. Um, if we have a sorted array.

Of binary.

I think you mean binary search. Maybe.

I think what we did last time and last class.

Oh. Oh, um, we could do that. The problem is that heaps give us don't give us really any benefit for searching for arbitrary elements. They're great for finding the most important, which is either lowest key or greatest key, depending on whether it's a min hyper max. Um, lab this week is heaps, by the way. So that's a very timely question that's going to come up.

And yeah. Uh, what about a hash table?

Um, well thank you for, for, for reading.

For.

Being caught up. So a hash table is another approach that we're going to see. Aha. And I think somebody is going to help get the slides. But I got my.

Lead over here.

For okay. Wonderful. Thank you. Um. So my screen is kind of dark I will revise. Yeah I was doing it. I was noticing on my machine that it was sort of you could say I was connected and then something. Yeah. So now it doesn't say no.

But now you say, okay, well I just. Yeah I did yeah.

And so it was flashing. But now of course many things are happening.

But it's been like that. Okay. I don't know if that's what I'm. Trying to say. Um.

The slides or keynote presentation.

Okay.

So I have a.

Question. Or like a rule of thumb. Okay. Yeah.

Thank you. The first misstep, I can sort of be kind of. Like I'm making.

Do.

Um.

I was like, oh, my gosh. All right.

So where were.

We? Oh. Um.

Sorted array list. This is sort of interesting, actually. How would you do so? Set union. Um, we're going to take two sets and put all the elements together, right? One way to do that is you make a new set, that's the result, and you just take the N elements. Well. So we have to say are the two sets the same size is one size n and one size m. Okay. So suppose set A is of size n and set B is of size m. Then if we if we're just going to insert things into a set that uses an AVL tree, then we have n plus m times log of n plus n right. So if we took the sum to be n then it would be n log n. Right. Everybody. Okay. Um, if we did this with sorted arrays this is kind of interesting actually. If you do it naively, you might suspect that it's n squared. But there's a trick that you've seen.

You could do something akin to a merge, right?

You could do the merge operation, and that's sort of funny. Did I say intersection or union?

Union.

Okay, so so we've got our two lists and we're going to set them up like a merge. And then we're going to to, to union them into a sorted array, inserting into a sorted array. If you know that this element is larger than anything already in the array, is constant time because it just goes at the back.

Right.

So we're going to take these two things and then we take the smaller one. Put that in the result. Smaller one. Smaller one smaller one. Oh tie throw one away. Put the other one in. And you just keep going like that. And now it takes time n plus n. So it's linear. Then the number of elements that you're, that your union, which is actually pretty slick. Isn't that cool. I think it's okay. That delights me. Um, what else do I want to say about.

Sorry? Um.

I think I missed about the end of this one. So now I have the next slide, which is going to be. Oh, um, right. Sorry. You have free rein of the computer. Do anything except delete all my files.

Um, or.

Yeah, just like encrypt them and then demand money in exchange. Um.

That would make you want to cry, right?

So that would make me want to cry. Yeah. Um, so back to AVL trees. Um, balanced binary search trees are very common implementation of sets and in fact, um, and hash tables. The other thing we're going to talk about is the other most common implementation. And if you look at the standard template library and C plus plus you'll see that it has both. It has something called an ordered map and an unordered map. And the ordered map is ordered because you have to be able to compare elements. Right. So binary search tree is it? If it's less, it goes left. If it's right. If it's greater, it goes right. Um, so in order to do that, you have to be able to compare elements. So that's the ordered map. Um, interestingly, for the hash table, we don't really have to compare elements except for equality. We don't have to compare less than or equal to or greater than. Um, and so that's what the unordered maps. So any question about sets or their various implementations. Because we're going to explore hopefully soon we will explore the uh the hashtags. We've got two days for hash tables so I can just talk faster next time.

Wait. If we go.

To YouTube videos, I put them on 22X. Do you guys do that? Okay. So now I'm going to practice doing that.

Um, if we're doing the merge operation don't both of the array be sorted?

Yes.

So if is it still why is it called unordered or is that a different thing.

That's a different thing. So we so we have different implementations of sets. One is we're implementing every set as an as a sorted array. Um, and so now in searching you have to you know, you have to it's linear because you have to put things in the right place. Um, it was kind of linear anyway for array list because if you well, if you have to check for duplicates then you have to do a linear pass and. Right. So um, so it doesn't really hurt us for insert. And then you've got this cool trick for doing things like union and intersection is similar. You can do sort of a similar merge trick for intersection and subtraction. So all three of those can be built on top of it. That's a good exam question. Um, okay. So we have um, we have the ordered sets, which gives you this log n behavior. Um, C plus plus has been built in Burling and Elixir have them, they call them uh, um, they call the unordered one maps and the other one, they give it away and they say it's a tree, general balanced tree. And I can't remember what Python does, but they do something. No. No joy.

The only trick I have left is to try starting your piece on your Mac with the cable connected. Um, other than that, there's. Okay.

Um, well, so maybe my PDF is done for, um. So let's see if I can log in, you know, and now I have to remember my password. Oh, no.

Yeah. It's like the one ones that I was like, okay. Yeah. Yeah, this is.

Interesting. I actually got here early and and spent my time looking at some, at an example I was going to be and I didn't check. But then you should have done that first.

Up.

Well, this one is up.

Oh. And. He wasn't. Do you want me to hide it on the screen while you're logging it and not show sensitive information? Uh, no.

I don't think so, because I think I'm just going to show the slides. So this is going to be a bit wonky, but we'll live. We will live.

Um, I got it wrong.

Okay, well, maybe we won't live.

Why would.

You make that bigger.

On.

The screen here.

There's an option for you to play.

Oh. That's interesting. You guys read that?

Yeah.

Okay.

Um.

And I can look at my speaker notes to make sure I don't forget anything, but I think we can do this. We can do this. So thank you very much. I appreciate your help.

I'm sorry that your computer's not working on.

Schedule a time to.

Come with your laptop and the situation.

Okay. In the meantime, I'll reboot after it after class. So then I'll.

Have to just make sure this is all. All you doing?

Uh, that's the kind of.

I mean.

Okay.

Thank you. All right.

Um.

All right.

Thank you. Oh. Interesting day. Okay. Um. All right. So, um, what are hash tables? Well, hash tables can be used for sets. Um, but they're useful for other things, too. And we've talked a lot about key value pairs. Right. So you have some key that you want to look up. Um, and uh, right. So that's what a finite map is. A finite map, is a mapping from some finite collection of keys to the to adapt to values associated with those keys. So if I look up, uh, if I look up Noah, who's teaching Kes 40 with me in the spring, and I look him up in my address book, I get all this information about him. Right. So I've got sort of a key value. An address book can be implemented as a, uh, finite map that maps names to contact information. Right. Um, okay. You should keep in mind, as always, that the key can be very complicated, right? Um, if you're boarding planes, the key can be, you know, some can be. Well, it can just be your your, um, confirmation ID, but it can actually be a set of a collection of information about you. Right. So the key can be complicated. The value can be complicated. And in fact, um, we'll get to an example in just a minute. So, um, examples Dictionaries. You know you want to look up a word. It maps either a word to its definition. But you guys know this. When you look up a word in a dictionary, you get sometimes etymological information, and then you go to bless you and then you get a list of definitions. Right. So already it's not so straightforward. It's not one definition. It's a list of definitions. Um contact list. You get complicated stuff out, hospital records, the list goes on and on and on and on and on. Um, okay, so here's a here's an index from a book that you can't read, but hopefully you recognize it from. It's, uh. Okay. If I can begin this. Let's see. No.

Okay.

Um, so it's a little bit hard to see here, but when you look up something. Um, so here's a term, and I can't even read it here. Um, so here's the term. And then there's some page numbers after it. Right. So what are the keys? The keys are strings that are words or phrases were, you know, they could be somebody's name because if they if their name appears in that book, I think there are some proper names here. Um, and then you get the page number or numbers that that thing occurs on. So you might say the values are a list of pages, but if you squint really hard but don't hurt yourself, you'll notice some of these are actually page ranges. So we'll say, you know, 567 to 610. So okay so list of page ranges. And then sometimes the pages are in Roman numerals. So like VII might be one of the page names okay. So maybe they're strings. Maybe they're I don't know. I've got to represent page number ranges. And I've got to keep track of which numbering scheme they're in maybe. And then they're cross-references. See also. Node. c Linkedlist node c tree node C. Right. So you've got these cross-references. So what you can see is that the um depending on the application, the keys in the values can get can get pretty complicated. And part of designing an application is thinking about what if you've got a key value pair kind of thing. What um what are the appropriate keys? What are the appropriate values? The keys are the things you want to look up. The values are the things that you want to find. Okay. So we want to insert a key value pair into this, into the, um, into our finite map. Um, if somebody gives us a key, we want to find it there. We want to answer the question, is it here which we would use for sets. That would be enough, right. But in the more general case where we have a mapping, we want to find out, you know, what's known as a phone number, which I won't tell you. Um, unless he tells you, unless he gives me permission, I might want to remove something that probably wouldn't remove Noah. That seems. That seems mean, but I could remove somebody else from my content. Um, and then we might want to answer questions, you know, for the set, one has keys. Basically. Is this thing in here that's a boolean. One is an empty size. All that stuff. Okay. Everybody okay with this is just finite maps review. We haven't talked about hash tables at all yet. Um, most languages have some kind of, uh, built in or library provided support. Um, as I mentioned, C plus plus is both ordered and unordered maps. So here's an example. And they often overload the square bracket syntax so that you can look things up. Um, you put the key inside the brackets as if it were an index, but it's not an array. In this case this is a it's an unordered map. So this one's a hash function. Um Python does the same thing. Overloads the square brackets. JavaScript does the same thing a lot of languages do. That's pretty common. Um, okay, so how are we going to implement them? Well, we could use linked lists. We could use array list. We could use balanced binary search trees. Um, we could use heaps. The problem with heaps is they're good for finding the min or the max element, but they don't. But if we want to know if some arbitrary thing is in here, then they don't really give us an advantage. Um, balanced binary search trees are absolutely used for these things. But of course that wouldn't be a new topic, so we're going to leave that alone. Um. Okay. So short on time. So I don't know how much to spend on this.

UNKNOWN
Um, oops. It's just been converted.

Um, should we just go down to the end? Um. Okay, so we've got, uh, um, we've got linked Linkedlist, which is its order. One to insert, but find is and the remove is an array list sort of looks similarly sorted. Array list has this cool behavior where you can search using binary search and log n times. That's sort of cool. I mentioned the merge technique. That's pretty nifty. And then you've got balanced BST which gives you this reliable log n. And I have to say that looks pretty good. And it looks good enough that most people use it. But party time hash tables give us the possibility of constant time for all those things. Now, when I say that, I have to, uh, there's some caveats. That's not worst case, really. That's average case, but balanced binary search trees, average case or log n. So, um, so if we design things well and implement them well, we can expect on average to have constant time insertion, removal and lookup, which is pretty cool. Um, I know it's nuts. Um, and I mentioned that this is so popular here, a variety of programing languages that have something built in and they call them different things. They, they call them hash tables and Haskell, SML and racket hash maps and rust in Ros. Um, Ruby just calls them a hash. Lua calls them a table. Um, and then, you know, map gets used in C plus plus Erlang and Elixir. JavaScript calls them objects, which is hilarious. Um, and PHP calls them array, which is equally hilarious. I think, um, the point of that exercise is just to show you how important they are. They're so important that almost any language, if it's legitimate, is going to have some facility for this stuff. There's just so.

Much of.

What's that? Literally, Java is not a legitimate no. It has them. Um, and I've used objects that way in JavaScript. Anyway, it's another story. Um. And as I mentioned, many languages allow you to choose if you've got things that are comparable and you sort of like the predictability of log n and log n is, after all, pretty good, you can choose a balanced binary search tree strategy. Um, or you could choose um, the hash table, hash map, whatever you want to call it. Um, you can choose that if either if the keys aren't comparable. So you don't have a meaningful less than operation on them. Right. Which could happen. Right. How do you know which, uh, um, which chemical ID is less than the other? You know, it might not make sense to have a less than operation. And if it doesn't, then hash tables are an excellent choice. Um. And often they can be used, um, for all sorts of things. Okay. So, um, so what we're going to do now is we're going to slowly work our way in to implementing hash tables, and we're going to do a variety of bad things first. So not not bad in the sense of not bad in the sense of poor choices, poor engineering choices that would perform horrendously. Or actually the first example is is not going to be bad. But anyway, you'll see. Um, so let's take for example, suppose our keys are integers. So that's very nice right? If keys are integers we understand integers. Those are great. Um, so for example, if you wanted to um, if you wanted to map integers to a month, name integers 1 to 12 to a month, right. You know, you could you could do it the way you might have learned in CSE 11. If the month is one, then the result is January. If there is a elseif elseif elseif else but or you can just build a table and I can tell you that in my various JavaScript things. I've written this table many, many times, and then you just use the month number as an index into the table. Constant time. Right? Um, now, this isn't really a hash table, but but that's the idea, right? The idea is how do we get constant time access to things? And indexing arrays are a way that we get constant time access to things. And if the if the keys are already integers in many cases, it's pretty straightforward to get that mapping. You don't even really need a full blown hash table. You can do a thing like this and do table driven lookup. Um, you'll learn about that if you take 40. Um, when you, uh, um, when you implement an emulator, it occurs to me there's a thing on the previous slide I forgot to point out. I don't know if you noticed it. This sort of hash table thing is even used in hardware. I know, they're called content addressable memories. What's the thing you want to look up? And I'll tell you what location it's in. Oh, this. This gets used quite a bit in, in internally in, um, in sort of the greater CPU, uh, stuff. So that's pretty cool. Okay. So we've got, uh, um, mappings from integers to strings. We know how to do that. Um. Okay, maybe if we, if we could build a list of all of the students at Tufts, and maybe the key is their age, and then we can find out how many people are 20. How many people are 21? 21 turns out to be important in a lot of contexts, right? So if you're above 18, you can vote. If you're above 21, you can drink alcohol and you can drive if you're about 16. I think most students are probably about 16. But maybe if you are, um, okay, so in a case like that, you know that the ages are likely to fall within some range, maybe 16 to 100 for, um, for some of us on the older end. Um, and then the keys can be integers. So, um, we're going to keep underlining this point when you have key value pairs. If you have a key that can map to multiple things, the usual thing is you make it map to a single list. So every key maps to one value. But that one value can be a list. In fact, that one value can be another hash table. I've used that structure before. So the the values can be very complicated. And in fact they would be right. So maybe if I look up 20, Alice, Bob and Carol are all 20. Um, and we wouldn't assign 20 to each one of them in turn because each key maps to one level. Understanding this will be very important for your last project. Oh, that's too bad. Um, just occurs to me that for us, it's going to sort of make it hard to build any sense of drama because you can just sort of see things. Bless you. Um, okay. So in that case, we could have an array that we're indexing from 16 to 100. And if you know you're indexing from 16 to 100, then when you when you get an age, you subtract 16 from it. And that's the index in the table. And then inside each table slot you put a list. I don't know linked list array. It doesn't matter just a list or something. Um okay. So when can we get order one access? That's when the keys are integers in a reasonable range. And we're going to have to soften that a bit as we go. Um, because then we can use them as an array index and array indices are very efficient. We can get constant time access. Um, okay. Uh, let's consider non-integer keys and we'll do this in a couple of steps. Um, so here's the thing. If the keys are strings like somebody's name or a struct that represents a passenger, right? What we have to do is we have to convert that thing into an integer that we can then use as an index into an array. Everybody okay with that. So that's how we get constant time index into array. But we have a thing that can't directly be used as an index. So we need a constant time strategy for converting whatever the key is into an integer. That can be used as an index of an array. So that's the that's that's how we're sort of building this out. Um, okay. And we're going to think about this actually in two steps because it turns out that, uh, well, we'll see why later when we start to implement these, but it's it's worth thinking about it separately. Let's take a string object or a patient struct or something and convert that into an integer with no regard for reasonable range or anything. Right? So I'm happy to, but I need to get an integer out. And you can imagine all kinds of things. Like you take the characters in a string and you add them up, or you multiply it by stuff, or you, you, you do something where you look through and you, uh, you accumulate bits. We'll see an example of that. If you take cybersecurity, they do stuff like that. Um, so we're going to get some integer. But then we need to make sure the integer is within whatever the range is of our table. And you guys know how to do that. How do I take an arbitrary. So suppose I've got a table of 15 elements. The indices go from 0 to 14. How do I take an arbitrary integer and deterministically get a number in the range 0 to 14 inclusive.

Mod.

Mod 14. Right. The modulus operator. So we're going to do this. Um so we're going to do this in two steps. We're going to take a hash function that takes whatever your key is and converts it to a number without any regard for reasonableness. Just converts it to a number. And the number might be too big. We'll say it's a non-negative integer. Let's say that, um, and then what we have to do is we sometimes call the next function of compression function, which gives us which is the modulus usually. And that just makes sure that it's within the right range to index your array that we're using. Okay. Um, now there are good and bad choices for hash functions. And um, so I could tell you a little bit of a story when I was working with a startup, um, sort of in the last century, literally the last century Wednesday. Um, I was working with a startup last century and, uh, And we had a very particular need to, um. We wanted a hash function that had very particular statistical properties. We needed to we were mapping things to hundreds of servers, and we wanted to be able to make sure that the mapping would sort of distribute relatively evenly among the servers. And we had very particular keys that we were doing based on the message sets. And so did we come up with a hash function? No, we did not. We hired we hired a couple of mathematicians in Moscow and they came up with a hash function. So when you're writing hash functions, you use the built in one. There's a great one in C plus. Plus it's a hash facility. It's not really a function, but you can use it like a function. You'll see how in the lab next week. And um, so let the professionals do it generally because we because it's really hard, it's really hard to make a good hash function. The start up.

End up going anywhere.

You know, the tech bubble burst and, uh. um, I think the company sort of limped along, but I, I bailed. Um, well, if I didn't want to bail, I had to move to New York, I didn't know. Um. They did. They couldn't fund the Boston office for two people.

Uh. All right.

Um, so I did not make many millions of dollars. All right. Uh, okay. So let's, uh, let's look at an example just to sort of understand what kinds of things we're up against. Um, let's suppose that we're going to make, like, a Scrabble dictionary. Uh, dictionary for two letter words. Just two letter words. Not one letter words, not three letter words, not 14 letter words. Two letter words. So go to leave or depart. Ox. Bovine. Frequently used in agriculture. And we'll just assume that everything's a string here. The key and the value are both strings. If you've got multiple definitions, then the string includes one period space. Whatever. Okay. Um. Hi. A common greeting. So, any idea about a hash function we could use for this? Hang up for a second. No. Okay. Sure. Uh.

I guess get the first letter.

Multiply it by some number, plus get the other letter in and multiply it by some number.

Excellent. Exactly. And in fact, a number suggests itself to me. 26 suggests itself. So we can treat a two letter word as if it were a two digit number base 26. Because there are 26 letters in the English alphabet. Um, there are only 676 of these possibilities. So now I can have an array that has 676 slots in it, and I can and then I can have all possibilities. Um, the hash. So if I've got two letters, we would multiply the first letter by 26, the second one by one, and add them together. So the hash of ox in this setting would be 26 times 14, because O is is letter number. So A is zero, B is one, C is two, and so on, and O is 14 and x is 23. So 387. That's where that's where ox we go. And the word at 80 would go in slot 19. So a zero remember this is zero times 26 zero. Okay. Um this is actually this particular case is something called a perfect hash because you know that every single two letter word is going to have a different hash and you can support all of them. This is pretty rare. But when it comes up, it's it's useful because it can be very efficient. right? 767 that's like nothing in memory. So just 676 whatever. Um, okay. And if you go online, there's a simple implementation that you can have a look at. Uh, okay. Where's the compression? Well, for this one, we don't need one. That's true. Um, okay. Now, here's the problem. Um, we can't do this with all English words, because the largest English word is has many more than two characters in it. And this, this grows very, very this grows really quickly. And of course, what even what even is an English word. Right. So here's that place name in Wales that has like 50 characters in it. Um, Supercalifragilisticexpialidocious has 34. Um, the longest word in a major dictionary that's sort of a regular English word, is about 45 letters, which is longer than supercalifragilisticexpialidocious, but not as fun to say. And of course, my my colleagues in the chemistry department loved inventing long names. And so they actually, the longest chemical name is 189,819 characters long. That's big.

What is.

Uh, what is it? I don't know, but I'm going to guess. It's poisonous. It's certainly it's.

Certainly.

I first thought of it like a protein. Like the biggest protein that exists.

Is it okay?

Um, cool. It definitely is poisonous to hash tables. Okay. Um. So for fun, I. So, um, if you're going to, if you're going to do this as a 34 digit base 26 number, then you have 26 to the 34 possibilities, which is that you don't have this much memory. Nobody has this much memory. This is larger than the number of atoms on Earth. So, so so you don't have that much memory. So we cannot do this.

Right?

Um, yeah. There it is. So there are about ten to the 50th atoms on Earth, according to wherever I looked at. Um, and the other thing about that is that number is huge, but we only have about 700,000 common English words, which is an infinitesimally small amount of that space. Your intuition about large numbers, by the way, really, um, all of our intuition of large numbers kind of stinks. So you have to calculate these things out to be careful. Okay, so. Oh, here's the stuff. Right. Um, so this this brings us back to what I mentioned earlier. We're going to divide up the hash function into two pieces. Well the hash process of the two pieces, the hash function itself is going to produce a number. That might be unreasonable right. But it's going to take whatever key is, you know. So you give it a struct, you give it a string, you give it whatever your data, um, is represented as. And then it gives you back a non-negative integer. And then we're going to compress that into some reasonable table range. And we're going to do that by just taking them on. Right as you suggested. Um okay. Questions about that.

Uh, now about this in particular. But our, our hashes then an invariant of knots.

It depends on what you mean by math. So, um, you mean a variant of this, a hash table is a way to implement a finite map.

It's a way to.

Yes, but of course, in some languages, they'll tell you that when you say map we say hash table. So some languages reveal that they implement that. They implement maps with hash tables. But a map is a finite map. It's just a way to get from a key to a value. And you could have You could use a balanced binary search tree to do that. Right. So another way to say it is a finite map is an abstract data type, and a hash table is a data structure. It's a particular way to implement the abstract data type.

Oh, okay.

Um, okay. So for example, if we had uh, an array of size ten, then what we have to do is we would get some, we would, we would run some hash function to get a hash value out. So you run the hash function, you get a hash value. And then you compress that into an index into whatever size table you've got using mod okay. And so we'll do some examples that again are not great um examples. But let's do it. So here here's a way to oh um when you have a table sorry. When you have an array that's being used in a hash table, the slots in the array are sometimes called slots, but they're often called buckets. And the reason they're called buckets we'll see in a little bit.

Um.

Okay, so let's take this crazy hash from the way that we get to a bucket from a key is we'll just multiply an integer key by two mod by ten, because we have a table of size ten. So we can have integer keys, but the keys can be like 40,610. And then we can double it and mod by ten. So let's insert seven seven times two is 1414 mod ten is four goes in slot for everybody. See. Right. You see why I picked mod ten. It's just going to be the last digit okay. We insert 1818 times two is 36. That's going to go in slot six. Um then 41 is going well 41 times two is 82. That's going to go in slot two and 35 times to 70. That's going to go in slot zero. Everybody okay. You okay. Because it's going to it's going to get worse in that. So just be sure that we are.

Now why are we doing two times key. Because that actually has the number of ones that are possible. Why not just do keying like for.

Just for just to have a pedagogical thing. And we sort of want to force the next thing to come up more easily. So, um, it's not a well chosen example. You should never use this as a hash. It's purely an artifact of let's do a lecture and study a really bad hash function so Mark can talk about collisions okay. All right. And speak. Oh I've already so when you insert 13 what happens is 13 times two is 26. That's going to go in slot six. So this is called a collision. Careful careful if you are mapping keys to multiple things, like in an index of a book, you'll map a string to a list of numbers that represent the page numbers it occurs on. That is not a collision. That's that's part of the application, right? The application is mapping keys to multiple things. And so they're just going to put a list in there right. So if you're implementing hash tables not your problem. Right. That's the that's the domain experts problem. Whatever their application is doing their problem. That's not a collision. A collision arises when the when the client thinks they have two different keys. They're not the same keys. Right. But you're going to put it in the same table behind this scenes in the implementation, because your function is going to send them to the same slot in your, in your array. That's a collision. And that is the implementers problem. Right. Because from the client's point of view what I, I can't have keys 13 and 18. Why not? Why can't I have those two keys? Right. So it's very important to to distinguish. Application issues where keys map to multiple things. And. Implementation issues where distinct keys that the client would say these are different. They have no relationship to each other. Why are you putting it in the same place? Right. If those mapped to the same place in the table, that's a collision. And so we're going to have to figure out how to manage collisions. So I kind of gone through this already. Um the key thing is that a collision is an implementation issue that arises when two different keys wind up going. It doesn't even mean, well, yes. You have a question.

Um, as far as.

Implementation of hash tables go, are like the C plus plus hash tables implemented such that if they hit a certain number of collisions, they rematch.

Uh, well, we're going.

To talk about strategies, but the short answer is yes. Yes, but it's not collisions. There's a thing called load factor, which I think we'll talk about on Wednesday. So um so that's so, so yes, there are things they do. And we're going to talk about some of those. Um, and it definitely arises. I put up a link to a video from about ten, 11 years ago that was a problem report from WhatsApp, where they had a particular approach to hashing. And when they rolled out something, they said, great, we're going to put more space, make it go faster. They gave it more space. It ran slower. And it turned out they had a bug that was way upping the number of collisions, and it was just horribly screwing up their performance. And it turned out it was like a two line code fix, but but really interesting and real world. Real world.

Wait. So in other words, are you like, going back to what we were talking about? Are you saying that two different values can't have the same key or two keys? Two keys can.

Be a collision is an artifact of a particular implementation. It arises when two keys map to the same slot in the underlying array, and that can happen in two ways. One is whatever hash function you use actually sends them to the same value, right? Because the hash functions can be complicated, there's a certain probability that if you take two distinct keys, they may wind up with the same hash. Now the mathematicians can be pretty serious. They can reduce that probability to be very, very, very low. But it's never zero right. So they can hash to the same value particularly if you have a bad hash function. Um, but then the other problem is that you now have to modify to fit it into whatever table you have. And that process will can generate collisions. So you get collisions either because your hash function sends two keys to the same hash value, or they may hash to different values, but they compressed in the same slot in the table.

Question is there a.

Difference between a bucket and a value?

Yes, a bucket is the location in the table. Um, and and we'll see that we have we have some choices. So we'll come to it in a minute. Yeah. Um okay. So collisions are going to happen. They just are. And we have to deal with them. Because if we're the implementers, because there are problem, the client doesn't doesn't know about these things. Right? You what are you telling me? That you know that Sue and Jim have the same phone number? They do not. Right?

Right.

So, um, so how do we do this? Well, first you try to avoid them. And how do you avoid them? You hire mathematicians to devise really good, uh, um, hash functions. The one in the C plus. Plus S is actually plus is actually very good. You can pick appropriate table sizes. And the minute you start modding, if you're a math major, you can sort of see, you know, that maybe they're notions of like, you know, prime numbers might be good sizes for tables, or at least relative prime of some things. You can sort of you can imagine there are mathematical things you can do with the table size that would help. Um, but nonetheless, whatever you do, they're going to happen. And so you have to deal with it. You can't eliminate it. You can just reduce it. Um, so how are we going to do that? Well. Yeah. So yeah. So how bad can it get. Here's a hash function one. You can be a key. And I tell you one right sends it sends everything to the same slot at the table. That would be bad okay. So that's kind of silly. Um. Now if you, if you have like the two letter one, that's called a perfect hash. And there's nothing wrong with that. That's good. You won't get collisions in that one because it's structured so you can't get collisions Every distinct two letter word has a different hash value by just by construction. But you can't always have a perfect hash function, so you can't have that. Um, okay. So, uh, let's let let's do a quick example. Suppose I'm hashing you guys and we don't have enough time to do this. Um, Chris, Greg used to do this, and he would have people, like go to the corner corresponding to different hash buckets, but we don't have time for that, so we'll just do show of hands. Okay. How many of you were. So just the decade of your birth. So how many born in the 1980s? Uh, 90s. Okay. Phew. All right. Uh, 2000. Yeah. Okay, so you can see that we have a lot of collisions. If one bucket corresponds to the 2000 seconds, um, 20 tens. Anybody? Anybody 14 years old.

Okay. All right. Uh.

How about months? How many of you were? How many of you have a birthday in January? Okay. Uh. Uh. February. Similar. Similar number. Uh, March. Uh, similar number. Uh, April. Oh. Poor. April. Okay. I'm April 2nd, so. Uh. May. Okay. This looks similar to the first few. This is interesting. This looks like we're spread out so far, June. Um, okay. July. Interesting. Usually June gets a bit more, so. That's interesting. Um. August. September. I'm trying to figure out what has the most. I can't really tell. October. November. Oh, this is working. This is working too well. All right. Uh, what did we say? November? Yes we did. November. December. All right, so that's spreading out pretty well. Um, if you use the day of the month, that tends to spread people out better, because it turns out that certain months tend to have more people born in them. But the day of the month is a bit more randomly distributed. Oh, by the way, I have to mention that your hash function can't be random, right? Because if you put something in an array based on a random number and then you have to look it up again. So so so just pick a random number is not a valid hash function. But you want things that are pretty well distributed right. Um okay. So it's fast. It's deterministic, meaning that you get the same answer every time. Otherwise you can't look stuff up. Um, you want low probability of collisions that you're still going to deal with them and you want to spread out the keys. Well, for reasons that will. We'll see. Um, and just for fun, here's the Sha 256. Here's a diagram that represents Sha256, which takes you, takes a message, and pads it out to whatever that is 1088 bits, and then the and then puts it through this series of transforms until you get a 256 bit hash at the end. And it's pretty well distributed, very low probability that different inputs will produce the same output. And two to the 256 is a very large number. It's more than there are seconds in the history of the universe. So it's a there's a lot of space. Okay. Um. We're going to look at two general approaches and a couple options with one, um, for dealing with collisions. So, um, the first thing is if there are collisions, you have to store the key in the table. Why? If you're going to put two things in, if two things go in the same place, then you either have to find somewhere else to store the second one or you have to, you have to put them in a list or something. And that means that now you have multiple things. When you do a lookup for the key. For a key, there are multiple things that might be a match. So you have to be able to test the keys for equality. Not less than, greater than, but equality. Right. You have to be able to do that. Okay. Um, so the first thing we're going to do is instead of just storing the values in the table, we're going to store a struct that is the key and the value okay. Everybody. All right. Um okay. So that's important. Uh, chain is the is a, uh, a very easy to understand, very easy to implement way to do this. Here's what you do. Are you ready? You take your array. And in each slot of the array you put a list of key values. Right. And then anything that matched to that thing just gets added to the list. And so then when you look something up, you find the slot, and then you go through the list that's there, and you search all the keys until you either find it or you find that it's not there. Now this means that lookup time is linear in the longest chain length. Does anybody see that? Alright, so I've got all my slots and this slot has three things in it. Don't don't don't. So now I have to look at three things. But if our hash function spreads things out very well and the hash table is relatively large so that there's enough space, then what you hope is that the maximum collision, the maximum length of the list, which is the maximum number of collisions on any given slot, is actually relatively low. So in that video I told you about with WhatsApp, I think they were assuming that their max collision size was supposed to be seven, but it turned out to be like 10,000 and then they got in trouble. Um, okay. So uh, so chaining is actually really easy. What you do is to insert a key value. First you compute the bucket so you do the hash function. Then you compress it using mod by the by whatever the current table size is. And that's the next thing we're going to talk about next time. Um, if the key is in the um. Is in table bucket, then you find the key value object in the list and update the value. You sort of combine it. You just go through the list and search for it. Um, and then you change the value. Right. And then um, but if you're inserting came to a value and the key isn't in the list already, then you just add key value. You make a key value struct and you put that at the end of the list, or you put it in the list on everybody. Okay. Right. So how you insert is first you look to see if it's already there. If it's already there, then you update the value. If it's not already there, you add it and then you know how to look things up in a list. So linked or array list doesn't matter. Um, so let's go through some examples. And we're going to use a terrible hash function. So this is another terrible one right. And what we're gonna do is we're just going to take the first letter of the word and and use that as the index. And we'll just subtract the letter A from it. So we assume it starts with a letter. Okay. So when we initialize our hash table we have an array of some length. And then what we do is in each slot we put a list. And we have inside we have emptiness right. So they all start out in. And so then we go through we add a 400. Right. I don't know why. Maybe that's a page number. Maybe it's a frequency count and a, you know, your Huffman code okay. And then what's the next word. Cat. So then we add cat. So now we have this list um that just contains cat ten. And then we add aardvark. So now we're going to get a collision. And so now we have slot zero. Now has two things in it. Because slot zero has a list. And that list has two things. Sense. Um, and then what comes after Aardvark is that bag. Where's bag? Should be. Oh, so the next one. Yeah. Bag goes in and then, um, drum and car. So we had drum goes in there and there's slot three which is the D slot which is slot three. Um car. So now cat and car, there's a list of length two here because two things collided on slot two of the table. And that comes next. That's it. Okay. So now suppose we want to look up. So someone says tell me the value for car. Right. Uh okay. So then we just we do the same hash thing. We say, all right, um, car. Um, so C is the first letter. That's our hash function. It's going to go right here. So now we just go through that list We find either we find cars not here, in which case we had to throw an exception or return an error value or not found or whatever. In this case it is here we can return zero. Complexity. Well, I've already sort of given away. Um, the answer could be order n, right? I mean, if you have the hash function that said one all things hash to slot 1 or 3. Well, now it's effectively everything's in one long list. It's linear. So you just have to you want to make sure that that doesn't happen. Um, but if you have a good hash function and the size of the table is reasonable for the amount of data that's in there, then you get average time order one complexity. Because what happens is, if you have a good hash function and a good size hash table, the depth of the collision lists is basically bounded by some constant right. The WhatsApp people thought it was bounded by seven turned out to be something else, but then they fixed it and it went back to seven. Okay, I just want to pause there. So that's solution number one. Um, I'm trying to figure out how much I want to do now. So I wanted to get at least through here today, maybe we can do a little bit of linear probe. Okay. So um, we want constant time access if we can get it, at least on average. And that suggests arrays and indexes. Not all things are integers. So we we hash them to get an integer. We compress them to be a valid table index array index using the mod function. And then when things collide we have at least one option. We can make a linked list, and each slot is a table that's pretty quick to tell. You start the next row because it's uh, it's the next one is not hard, but it's a little bit.

So, Once that once the limit of their hatchet thing to be seven. Does that mean that their table has to be one seventh the size of the total number of possibilities, which in the case you mentioned, is the number of atoms in the Earth? Yes.

So yes. And so we're going to talk about table size a lot more on Wednesday. And yes, it absolutely assumes that you're right. You're right. Um, so I'll just since they're up here I'll tell you the next bit. Um, so open addressing is a different strategy. Chaining will work. Even if you have more things in the table, then you have slots in the table because you have linked lists, right. You can just add to them indefinitely. It's not good for performance, but it's correct. It doesn't give you wrong answers. The open addressing assumes we have extra space in the table, so that assumes there are some slots that are not in use, which suggests immediately we have to keep track of what slots are not in use. We're gonna have to figure that out. But the key idea here is we're going to use extra space. And there are three methods linear probing, quadratic and double hashing. And uh, maybe. So I'll just I'll give away the thing and then we'll review it next time for, for linear probing. What this means is you hash a value, you find the the slot where it belongs. Oh, no. There's something already in there. So what's the easiest thing to do that uses spare space in the table? You just search for the next empty space in the table and you put it there. Right. So that's that's going to. And now if there are no empty spaces in the table, that process is indefinite so that you have to have extra space in the table. But you put it in, oh gosh, there's something there. Is there something there. Yes. Is there something there. Yeah. There's something there. No. Okay. Put it there. And then what I want you to do for next time is think about, well, if that's how we put them in, how do we find them again later. So that's step one. Step two is what do we do if something gets removed? And with those two questions, we'll leave. And we'll see you on Wednesday. And either I won't use the darn display or it'll be fixed.

Here tonight because I have.

Like 800 tabs on two different.

You know, all the. All the ones. They say don't take big on this, but, you know, I'll go and go. Oh.

That's making me very sad.

You. Okay. So what do you do? Oh, you love me, you know? Yes.

So what.

You do? Yeah. I forgot my marker. Oh, well. I think I might, I also might like.

So just sign up for section two and lab section. And then in the next day or so, we'll send you an email. I give you a form you can fill out and you can say I declared my major on whatever day.

Okay. Thank you. Thanks so much. You're welcome.

So good. So. I love Friendsgiving because we all my friends. within plenty of US houses.

I try not to reboot during the semester. This is terrible.

I quit the mail.

Thinks it's quitting.

Maybe I should have dinner at six. Not just not after this, but I think I should do one. Well. I.

Are you in your next?

Yeah.

Do you. Have you been attaching to the thing?

No.

Oh, good. Because it wasn't working today, so I thought.

Excellent.

Thank you. I'll tell you, I'm here to support Doctor Chris on his to. Okay.

Um.

So suggestions? Yeah.

Well, it told me to reboot my machine with it connected to the projector, so I'm going to hang out for a minute while my machine reboots. But.

I mean, it's worked.

All semester.

So.

I know it's been pretty well. I mean, one week out from the end of the semester, so. I like that. But one more thing. That's because I know that. And then we're going to make some calls to me. So. How are you doing, Michael? You get your stuff done.

Uh, yeah, I get in there.

Oh, my gosh.

Thank you. How are you?

Yeah. Get in there. Yeah.

How are things.

With your life?

I feel like it could be so on my lap.

Oh, okay.

Okay. Yeah. So as I go, so goes my lap. Um, yeah. I'm just, um, pulling in my data and getting into the point where I can actually do some statistics on it. Nice. Yeah, because I know what I saw. Let's see if the numbers back here.

Yeah, right. Cool.

Yeah, except I missed my pigeons. You really are not doing okay. Yeah. No.

Where's the log out.

Yeah. Oh, no.

How do I log.

Out of.

Change?

There it is.

Um. Sign up.

It's not in the place I remember, but I haven't used windows in, like, 15 years, so. Okay, this is not good. So now.