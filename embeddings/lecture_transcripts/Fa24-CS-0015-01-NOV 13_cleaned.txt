Be working out as your partner for, uh, for the final project. Uh, working with a partner is required. Um, but I don't want to. Is another reason to not work with partners. Um, it's actually a lot of fun. Um, when you work with a partner, um, we do something called pair programing, which you do for all assignments and 40 assignments and 105. That, um, is a key part of. It's a very useful, um, when a program is also available for, um, for open minded, uh, be kind. Um, and you do, what you do not do is divide the work in half and you have. That's not how it works in pair programing. Each of you is there 100% of the time nobody works without the other. And you can read the documents about it. We have ropes up. Um, if you look at the biographies and.

UNKNOWN
If you look at the reference links on the website.

I think we send you to the CSE 40 pair program and have the same idea. The idea is that one person is typing and the other is paying attention and catching errors and making sure that you're doing everything through the stack and just checking. And then you trade off with 99. Um, you also designed together. Um. Which is extremely rewarding. So, um, I've been I've learned a ton when I started sort of essential care for my fellow instructors. Um, professor Mendelsohn and I have worked a lot together, CSS 40. And whenever we sit down and we say, okay, let's take this thing together. We we have a great time. And I learn a lot and I, you know, contribute as well. And I have particularly fond memories of programing The professor is now retired. But, um, we've had some bugs in, uh, some stuff here for CSS 11, and it was very difficult because we had to debug code running on.

UNKNOWN
A machine that we didn't have access to. It's very challenging.

And I just remember he sat there and we finally got it to work. I came up with this really ugly packet at work. And um, and then the next morning I was walking by my office and she said. Okay. So, um, uh, so anyway, um, engage in the process, find a partner, and that will be cool. Uh, it may not be possible for the partner, but I can't say that I often get requests from five people who say, well, they're not the only people that maybe, I don't know, but. Um, I know it's a bad joke. It's okay. Um. But here's the deal. People tend to drop and they don't tell shifts, so I don't actually know who's in the class. In fact, I can't. And then some people get sick. I can't know. And then some people have emergencies and have to travel. I can't know that in advance. So I can't promise anyone that you will work alone. So get a partner. And then if somebody fails to get a partner, then we'll talk. But you have to actually.

UNKNOWN
Um, okay. So it's fun. It's really fun. Um.

And then, like I said, you learn a lot from each other, which is the which is the big thing. Okay, so on to today's topic, which is something called priority. So that's a metaphor for life. Um, so what's a priority queue? Well, it kind of is my computer in the sense that you're going to there are entities waiting for something. For something. And you. And you want to provide that service to them. And there's some ordering. But it's not Python. It's not a regular Q um, it turns out sometimes some things are more important to others. Uh, an example of this is in metaphor. So this goes back to Napoleon. And. So like if you go to the emergency room, um, do you get served in the order you arrive? No. I mean, if you go to if you go to the Starbucks in JC, you get served in the order you request going in, but you don't expect that in the hospital.

UNKNOWN
Why not? Order!

I've got this. I've got this pain in my foot that's been lasting for six months. And then somebody comes in with a heart attack. They jump the line, right? They go first. Because if they don't get. If they don't get served, they die. And if I don't get served, I have to deal with this thing for another hour, right? So, uh. And this is what triggered the Foley and developers in the ward, because they need to, um, provide medical service and provide it to everyone in a timely fashion. So they divided people up into categories, really four categories. Categories. And it was true, which is great, but one of the best is getting the service. So that's why this is true. Um, yeah. The Life-Threatening. The people who need care right now or they will die. They go first, right? And then, um, people with less.

UNKNOWN
Urgent conditions and. So this is.

I found this one. Um, so. Yeah. Uh, so first to die, right? They go first. Um, you need some significant intervention, but life is not in place, right? So maybe, um, so the example of that might be a kidney stone. You're not going to die. Probably. And you've got time and patience. So you go ahead. And the person with the Dalton is always right. Um, you might need medical treatment, but, um, or medical attention, because whatever they have, they can't do.

UNKNOWN
Anything for you. Or if it's something minor decided by itself or you're too far gone and.

No intervention is going to save you, which is, if that's. That's the point. Um, and of course, we have a ready administer and registering for cancer. Right. Because, um, we would like to take everybody that we probably can't go in and see how much. I don't know how many everybody does, but, uh, take care. But here's the deal. In the spring, if you're a senior with a CHS major and you haven't taken 40 yet, you're either in or you don't get a diploma. They go first.

UNKNOWN
Right here in that cast.

And then you sort of work back from there. Right. Um, I'm graduating next December, but I'm abroad in the fall. Okay. You go in. Right. So, um, and so we have to do that, uh, we have to do that sort of priority process. Um, so the priority queue is the abstract data type. Um, and it's similar to stacks in the sense that, you know, people get inserted and they find the they get inserted in there, there's a drill. Um, and then what you want to do is you want to be able to find out what's the highest priority thing in the queue, not what's the first thing in the queue. What that refers to.

Um.

What is the highest priority? If there are ties, then we can talk, right? So some applications might say, well, there's no implicit ordering to call you. Or you might say, well, if there's a tie within the tied group, there's a there's a Fifo word. Right. So if you've got three people with priority 14.

UNKNOWN
Then maybe you take them to their level.

So that's what a priority is. I've already mentioned hospital triage and this is with 40. Um, it comes up all the time in key us. So this is not none of the things you teach in CSC 15 are obscure or rare. They're all we teach them because they're complex. Um, so, you know, you see this reporting? That's a rather complicated. Operating system student. So every time I typically last time I checked, I had over a thousand programs. Right. I only have ten cause, so only ten. One at a time. The operating system has to pick which among these thousands should be granted access to the CPU for major priority.

UNKNOWN
The percentage of priority queue mechanism. Um, we see many.

Algorithms that use it in different ways. We're going to study Dijkstra's algorithm. We've already looked at companies in 160 or 70s of the algorithm. That works. Um, and we had a recent episode where when Covid vaccines were rolling out, not everybody's happy. So who gets them first? Well, the people more likely to die if they don't. Um, okay. So I hope you can appreciate that prior to use the code, it's important and you can at least get some idea that it's not an unusual occurrence. It's a thing we often want to do. Um, so how do you what do you what do you need to figure out? You need to be able to assign priorities.

UNKNOWN
Um, it's a very difficult position. Um, in the Fifo queue.

You can say where my in mind. How many people are ahead of me? I can't answer that question. Right. If you're sitting there, uh, and and the heart attack comes in. They weren't there before, but they're in front of you now. So there's not a clear answer to where am I on how many people are trying to. It's not a physician assistant. Um, and for equal priorities, I already mentioned you can you can try to have Fifo within a particular category, or you can leave it undefined and let random properties in C plus plus work. Um, so those are your options. Now one confusion that comes up.

UNKNOWN
Right away is that um.

We're going to use numbers for priority. Right. So we'll say, you know, your priority 18 and your priority seven and your priority 23. But which of those is more important? But not surprisingly, there are two approaches. And because there's not an obvious reason to pick one before picked up. So one is that the higher the number, the more important you are. So the number is kind of the importance. But many systems, including the lower numbers are more so. And that was the category one priority one where the people who needed urgent care priority two were less. So it's important that you establish that you that you pick. And there are reasons for that which we want to talk about. Um, but then you pick and that you're consistent within any application. So priority queues are about importance. And the priority number is just an ordered thing that you can use to establish importance. But the interpretation has to be clear. Okay. And another thing to remember is that there are keys and values. So you go to the hospital and you're a priority 19, whatever that means. Um, and then, um, your priority number comes up. They don't just treat the number, they treat you. So there's. So we've got keys and values that are going to be sorted. Um, and usually we have the priority is associated with the key. It can be the key or be some function of the key. Um, and keys and values can become uh, sometimes it's a separate thing. You go to the hospital and they give you the patient ID. There you go. Right. But you're getting on a plane. And what do they use for the priority? It's this unholy mix of how much you paid for the ticket, and whether you're a military veteran and whether you have young children and how old you are. And, you know, it's this combination of all of these things, right? That's a very complicated priority. Um, what's the key in that case? Well, they're probably a few keys, but they also have like a reservation ID that often sits right. So keys and values can be complicated. The key can be part of the value, or it can be a separate thing that you assign. Um, and the keys, like I said, can be complicated. And deriving the priority might involve sort of complicated stuff, none of which we discussed. Other than to acknowledge it. Um. As we did with the binary search, trees will mostly just deal with the keys and the values are along for the ride, right? So when you store it, they sort of disrupt the value, or there's a struct or a value in it, and there's a function that maps those things. That small matter of programing. Right. The values are the things that are the most important in the end.

UNKNOWN
But the keys are the things that determine where everything goes in a data structure.

So as we get into binary search, trees are really just talk about keys and we're going to do some there. Um, but the the keys may not be comparable, right? The keys are numbers that you can do less than or equal. Um, but often if the key if the keys are some function of passenger data, uh, then your ordering relation can be complicated. You're going to have to find your own function. Right. Um, and you can use less than or equal to or greater than or equal to depending on whether lower priorities are more important or higher. Um, if you find one and that's cool, you just find a value that takes the place of less than or equal.

UNKNOWN
To services before or.

Whatever. So. And if you're going to write your own comparison function, then you have to mimic certain things that we know and love about less than or even so, the paradigmatic one is less than or equal. Not less than. Less than. Um, and so you need three properties that you probably learned in high school algebra. So here we go again. Um, and you have to define them for, for all the elements working as appropriate. Um, reflexive. If I compare a thing with itself, I get back. True. So I my priority is less than or equal to my priority. Which makes sense. Right? That's called reflexive. The properties are called the graphics. Anti-symmetric. That says that um, um, if if I say that, um, um, you come before you and I swap you and then I say, well, if you come before two, then I can't get this. The only way I get true in both cases.

UNKNOWN
Is In fact, you. Just needed to say yes, sir. That means you're. Right.

So if you just like if you say A less than B and B is less than or equal to a has to be equal to B, it's the only way. That's true. Right. So that's the anti symmetry would be that you can swap them is equal to is symmetric. If A is equal to DV is also equal to a right. So that's symmetric. So this is antecedent um the third one is that major should just feel free to speak about transit. Uh so if you compare less than or equal to you and you compare less than or equal to you, then I know that you are less than or equal to you. Right? That's the transitive property. And that's going to be important because if you violate that, then none of the things I talk about when we get to heaps are going to matter because.

It's going to blow up.

Um, so whatever you do, you have to do that. And like I said, if you're ever confused about it, just say, well, what would that sign or equal to do on something and just try to follow that step. Um are at reflexive, antisymmetric and transitive. Okay. So as with all of our um the sorting is algorithmic, but all the other things we will study here. You basically put down the priority queue is like that because for key value pairs, um, the highest priority can be the minimum and maximum key. And for the sake of today I'm going to standardize. We're going to assume lower numbers are more important. So. Uh and want to be able to easily get the minimum value. Um, this is crucial and maybe not obvious to any of you, but keys have to be immutable. What does that mean? It means they can't change their value. So like to keep a struct. You can't like assign a part of the structure. It's a string. You can't update parts of the string, at least not while it's in the data structure. Because we're going to put it in the data structure based on the ordering. If you can change it. You might change the order. But the data structure is just going to be aware of whether you change something or not. And so then you'll change some piece of it and then it will be in the wrong place for it. Right. So he's happy. At least as long as they're in the data.

You're saying that things are mutable, but the values.

Can't change, so.

I think it's immutable.

No no no no. Sorry.

Um, that's the value of the keys. Okay. Uh. Yeah. So hold on. I'll fix that, because that's, uh, I see your point, and I appreciate it. And I will fix it. For instance.

UNKNOWN
Key values that. This is.

The key. Must not be.

Um. How about. Just must not change. You must not change. Okay, so we'll go with that. Thank you. Um, I realize now that's very confusing. Um, okay, so, um, with all of that preamble, what do the basic. What functions do you want? Well, um, if we're if we're using a situation where lower number, lower priorities are more important, then we're constantly going to want to know what's the minimum of who's next, who's next. Right. The person in the hospital wants to know who goes next. So who is that? That's the in this case, the most important person, which is the one with the minimal key for our the, um, we might want to know what is the minimum key, right. What, um, you know, do I do I need to prep the or, you know, do I not need you know, you're the you're the most important person here, but you're not You're not at risk of lightning, right? Um, so I might want to know what's the mid element? Who's most important? What's the min key. What's their what's their priority value. What's their priority? And, uh, and then I want to move it into more to provide the service. So we take them off. And then of course, we always need things like, you know, how big is the priority? How many things are the priority. The size is the position that we need those things. So to give you a sense of how it might work, um, we're not going to settle on a data structure yet. We're just going to treat this abstractly. So I'll just write the things that are currently in the queue as is set, and the order doesn't matter. I'm not saying anything. You're going to talk about implementation later, but let's just go through the operations and see how it works. Okay? So like any of our containers, the priority queue starts out empty. And then if we insert something it goes into the priority. So remember, we're inserting a, um, a is the thing where insert that's all the patient data or all the traveler data or what have you. And then the key here we're using the party. So that's the party file. I don't know what it is. I just know it's more important than ten and it's less important than one. Uh, okay. And we can put more things in. And the, um, the those things get stored in the queue somehow will solve that problem. Um, and then when we have a bunch of things in the. Well, at any time, you can always ask what's the minimum? Maybe gets an exception if we're worried about the details like that. But if the queue is not empty, then we can find out which is the the most important priority. Which is the lowest? Five is the lowest. The three is the lowest. So B is the is the minimum. And of course if you ask for the middle you don't actually change that part. You can ask what he is and we just figure that out. Um, and then of course, we might want to. Okay. The, uh, the, uh, the doctor is free now. Uh. Who's first? Let's take them out of the priority queue and.

UNKNOWN
Put them in the exam in the O.R., wherever they're going. Um.

So movement is going to change the party, cuz there's one less over, and we can decide whether we move, then returns it, or whether we have these elements with the SPL. Right. You just pop return the value to take off, or you say, what's the top? And then you pop those your details, you can work out. But one thing that we're moving in has to do is take it out of the party wherever it has to. Ask how many things are in the party. Now, you know, this is a This fight is the Lord's Prayer. And then we can keep removing things. And then if we remove, everything is empty. But it's, uh.

UNKNOWN
It's crucial to be clear. Well. The only word about the problem is the priority. What does that mean? Well.

So good point. And in fact, we're going to think about how to implement it in a minute. Um, but you're right that you can't just do the same thing you did with the regulations.

UNKNOWN
Okay. That was the key. Element in that one.

Right. So as usual, I will ignore duplicates in lecture. But the option basically there are two options. One is try to preserve faithfulness among things that are equal. And the other is ignore the issue and let whatever happens in the data structure has to be. And I'm not going to say anything about it right now, but that's it's an excellent question. Um, I can tell you what the what the Unix kernel, what the Linux kernel does is within a priority list like. So all things that are priority for, um, the first one that arrives. The one that's been waiting the longest at priority four is the one that goes. If you're willing to give a CPU for something with a priority. Oh, I let it go on the slide. Did you notice the slide said nice. Um, so in Unix you can change the priority of the A program. You can run a program, and then you can nice it and change and ask the OS to give it a different priority. Here's a rule you can't make your stuff more important. You can only make it a message. And that's why it's called nice. Because by voluntarily making your program less important, the CPU will let other people go first. And you would do that. Why would you do this? Well, because I'm running a thing that's collecting data. It's going to run all night anyway, and I'm going to go to bed. And, you know, it doesn't need to. If it finishes an hour later, who cares? Because I'll still be sipping my coffee. It doesn't matter. So I'll nice it. And then and then other people can use the machine. So this can be used so that that is more useful to.

UNKNOWN
Me. What, that.

Oh. Um. Interesting. Yeah. So it's going to take it off the queue and reschedule it under the new priority. So good point and very perceptive. So yes. You can't it can't keep its position in the queue. After you have to take it out, then you can come up with a new key. And then from the OS point of view it's a new thing right. Good point. Um, it does that in turn. Um, okay. So you were asking about implementation. So my previous slide, it just put them in the set in the order they came. And it's a set. So the set wasn't there's no coincidence. Um, now we could do it with a list or a link list because we could do just what we kind of did. There you have it. You put things in the list, and then whenever anybody wants the minimum you go through, you do an order n search and find the things at least seven. Right. We all know how to do that. That's nice. Um, you could um, what we're going to talk about is. So we can keep the list sorted, which has its advantages for array lists. Linked lists? Not so much. Right. Because, uh, well, linked lists have an advantage in the sense that if you keep the list sorted, then it's quick. It's not linear to find the thing with the minimum elements. And if you've got a front in the back pointer, it doesn't even matter whether it's ascending or descending. If you do it with a with a sorted array list, then you definitely want to sort the keys in reverse order of importance, so that the most important thing is that we care, because that's where that's where you're going to keep you're going to keep saying, what's most important. Take that long, right. So you want to be able to do that. Um, binary search tree. We couldn't find any searches. So, um, I've already started thinking through the process. So, um, an unordered list insertion is order one, put it at the back of an array list, put it at the front of the list, or the front pointer for the front or the back to the front and back. But minimum element and movement order because you have to, you have to find the thing and then you have to remove it and.

UNKNOWN
Copy the data around, uh, are there necessarily a finite number of priority? It's an excellent question.

Because sometimes yes and sometimes no. So the Linux kernel has a fixed number. So it uses a very particular approach. We've been discussing it. Um but sometimes the priorities are relatively important numbers that come out, and there's not really a fixed set up.

UNKNOWN
This is another way of doing this.

Oh, perfect. Yeah. So, um, uh, well, array of cubes or an array, which works really well with the issue of what do we do with these and that. Okay, so you've already figured out the, um, the Linux kernel uses uses an array of cubes, each each array slot, all the things with that priorities. It just has a fixed number of rows. So so you guys are way ahead. Uh, if I order the elements in the array list, um, and inserting becomes order n because you find a place to move that over. But minimum elements are moving in that order one if the minimum is at the end. And ignoring that issue, as we often do, of having to grow the, um, or just assume that things are, which is because in most cases, um, for an ordered linked list, what do you think? Insertion. Because you have to find the takes and then do a constant amount of, um, minimum elements. Within an element is order one. Now because it's sorted, you know, it's either at the front of the back and you can have the front of the handle or back pointer. So you can just you always have a pointer directly to the minimum element.

UNKNOWN
So that's going to be constant. And movement is also.

The general BST. For If the tree is balanced, it's log n, and if the tree is not balanced, the daughter end. So it's kind of a worry. But a balanced BST, like if you use an apple or a general balanced tree or actually or something like that, um, then it becomes log n n because it's log n to insert the minimum element is always going to be the leftmost element, right. And that will always be the right place. But if the tree is balance then it's going to be logarithmic. Okay. Um and then we've already. Oh sorry. Yes. Sorry. Did you like when you mentioned like that we always have a pointer to the minimum. Um, I think I understand what the order of this. Right. This one. Yeah.

UNKNOWN
Right. We're always going to be able to get it, but to use it again, how? We know the log n to, um.

So this is a balanced binary search. So like an AVL tree. So in an AVL tree finding the minimum element is log n because you have within a constant factor you've got log n steps you can get to any from the root cause we have. No. Um uh, I'm not assuming that here that the idea that we have a pointer to the minimum is in order to make this. So in that one, the ordered linkedlist has a pointer to the front and or the back. And possibly the back and be sorted in ascending order. The front pointer always comes from there. And the universe sort of like that okay. So there's no real advantage to reverse sort of that. I think just because you can't do binary search in it, but you don't have to do binary search. It's all we care about is right.

UNKNOWN
We're not searching for arbitrary things.

Um, and so you guys already kind of figured this out. Um, if you have a sort of small number of known priority levels, like the triage, which has for a while, George, um, then you just have an array of size four and you put a queue in each one, and that thing is a regular queue, then you get Fifo behavior for each priority. I think. That's how the Linux kernel. Uh. Okay. So. Right. So maybe we have a system like that where we've got, uh, we've got four queues and the first one is low, and then the 32 has 433. That's three people and 44 as has those. Um, okay, so just drink that in for a minute and, uh, and let's analyze the time complexity. How long does it take to insert into a table?

UNKNOWN
A little way.

Maybe if we say that the number of, uh, categories is currency. Yeah. So it's a it basically you sort of have to, uh. Hold on, hold on. Yeah. So insert, uh. Yeah. Order one. Sorry. I was just thinking about the next question, which I've now given. Um, so access in the queue is order one because you just index based on the priority and putting in a queue is quarter one. If we saw that before, it's not a problem. So order one minimum element.

UNKNOWN
Um. So what's that. What was it.

Then?

UNKNOWN
The number of priorities. Correct order. Number of priorities.

Because you have to go through and find the first that the highest priority is on empty queue. And then you take the name. Right. And then once you have the queue then.

UNKNOWN
It's 4 to 1.

Then it's kind of the same thing. So this works really well if you know the number of priorities in.

UNKNOWN
Advance and it's relatively small. Um.

And like I said, the Linux scheduler I group last I did this. Recommendation for anyone wants to know more. Okay. Um, so it sounds like we've done pretty well, honestly. we've looked at several ways to implement a priority. And if we want the log n behavior balanced binary tree seems to work. So why why don't we just stop here and go on to the next topic? Well, that's because there's another option, and it's, uh, and it's insanely cool and it's widely used in practice. Uh, it's similar to BST. So we're going to see, you know, log in and stuff. Um, but it so it does. So educationally it has some advantages. And then it's going to show us a really cool representation trick, which is just stupid. There's an ingenious use of invariants. And one of the invariants actually is looser than say, an AB. And that's interesting that the loosening of invariants can somehow lead to better performance, which is really cool. Um, and the other thing is that they're they're excellent in practice. They tend to be very cash friendly, you say. Um, and the constant factors tend to be really, really good. So the binary search is not particularly cash register a binary or, sorry, a binary heap. And if you implement it.

UNKNOWN
The way we will discuss.

Uh, so heaps are a particular data structure. That means we put the data in memory in a certain organization. And it's going to be really good for priorities. Um, and we sort of went through that, uh, that already. Um, so it's a it's another option. It's similar to VSTS. Um, it's got intelligent data structure design and various methods, uh, in variance with a looser variant leading to better times. I'll tell you what these variants um, but because we used the word heap, I remember when I learned about this, I thought, is that the way the heap works when I allocate stuff on the loop? And it said, that's a different thing. Maybe they have a priority queue, but let's, um, separate that in your mind. This is a different word, also pronounced heap and spelled.

UNKNOWN
So what's that?

Oh, um, it should be lowercase s. No, wait. It should, it should be a queue. That's priority queues. Or maybe it's peanut butter and salad, I don't know, uh. Typo. That was. That might not be right. So I was I was mucking.

UNKNOWN
Around with this slide. Um, okay. Um. All right.

So remember we said that priorities can be the number lower numbers can be more important, or larger numbers can be more important. So there could be two types of features. If lower numbers are more important you're going to use a minimum. If higher number of priorities are more important than going to use a maximum. We don't really have to discuss whether I'm going to discuss matters. If you have a maxi, here's what we do. Everywhere you say C less than or equal to, you use greater than. And then just anywhere you see the word minimum and everything holds true. So there's no difference. And of course the operations on a heap, it was designed to be good for priority.

UNKNOWN
So they're basically the same as. What they are. Um.

Okay. Are you ready? A binary heap is Here's a binary tree that satisfies two invariants, which are usually called the shape property, or the shape of the tree or the heat property. So two invariants. Remember AVL trees we had. It was a binary tree where it had the best invariant plus the balance of the angles. So this is going to be a binary tree that has a shape invariant. And a key thing here. It is not the same as a BST. Okay. So just get that out of your mind because those invariants are off the table. It's a binary tree but the invariants are different. Okay. Um, so what is the shape of them. Well the shape invariant says that every tree must be some poly binary tree, not a perfect binary tree. That's unusual. A perfect binary tree would always have, uh, two to the k minus one.

Nodes in.

It, you? Can't. You sometimes need to add one element to a to one of these things. Right. So that's unusable. So, uh, we say that the tree has to be complete. What is complete? It means that the way the tree fills up is that each level fills up completely and in any extent in any non-empty. So empty is also. But any non-empty has four levels except for the last one, and the last level has to fill up from the left. So you can't like take 18 off here and put it over here. That would violate the shape. Okay. So all the levels are full except possibly the last. If the last level is in full, all the elements are correct and all the holes are correct. So there could be foliage for square as a whole. There could be no, but there's no know, it's a dollar.

UNKNOWN
At that point.

And as always, I'm leaving out the values for.

UNKNOWN
You know, their structure and their behavior. Um, okay.

So that's everybody okay with this property. Now this sounds this sounds worst, right? By nature. I mean, this is worse than maybe elsewhere, but as long as the balances are within one and this is like, no, can't have any shit. This one. Right. It's this, this shape, which is it's going to be so powerful, you won't believe it. And it's going to be so easy to implement. You won't be. Okay. So what's this heap invariant all about? Well, the heap invariant says parents are more important than their children. Sorry, guys. Um, this is not a popular position, I guess. Um, as a parent, I don't really feel this way, but I do feel like. Um, Parents are more important than their children. Um, okay. So what does this mean? This means for me. Remember, lower numbers are more important. That means that the key in a parent's value has to be lower than superficial. But that sequence is flooding. So what is, um, crucial? The order between children doesn't matter as long as I'm the most important one. Who cares who's on the left side? Right. That's the. That's the winning ticket. Um, and so this is not a BST because the BST order. Absolutely. Um, okay, so let's look at it at a couple examples. Um, this these are both valid. This is a valid argument and that's a valid match. In order to check that it's valid we check the two invariants. Do they have the right shape? They're all full except for the lowest level which is partially full. But all the nodes are on the left. Check Shut up. Then we have to check the heat. Property for 95 has to be less than ten and eight. Ten has to be less than 12 and 1114.

UNKNOWN
1312 is less than for three.

And similar analysis over here, except substitute is greater than or equal to four less. Okay. So what I want you to notice, uh, one of the hardest things about the heat algorithms is, is this the psychological pain that it can produce when you're trying to implement it and you become distracted? So I'm going to try to set this up in a way that will help you when we get. So just look at these for a minute and ponder, um, could we, if we need to add an element to the tree? Could we put it here?

UNKNOWN
Yeah, we put it.

All nine elements look like this. That all look like one, two, three full levels with two nodes at the left of the next one. All trees of any size. All heaps of them of any particular size have the same shape. So. And here's another thing. How many leaves? About half of them. That's a property of a complete binary. So there are nine things one, two, three, four, five, eight. There are therefore four internal spikes. Right. All nine peaks have this property. All ten elements by out of ten. So it has to go here. Right. So that one will have one, two, three. And that's not a heap anymore. We'll find that will also have five. All of this is going to come back.

UNKNOWN
In a way that's really interesting. Okay.

And just a reminder. So that was mostly about the state property though we do check with that property. So remember both of these are perfectly valid binaries. All I did is five is less than ten and 12 and five is also less than 12. The series is not recorded, but that's the place where it's less restrictive and somehow that less restrictive ness is going to buy us some logins in the future, which is which is counterintuitive. Great. Um, okay. We already went through this exercise. Um, forget the values from it. Just the shape factor. Any new thing has to go. Can't go anywhere else. Now, if it goes there, it might violate the heat property. But I'm only asking about the cheap price. But if I'm going to add a 10th note that has to go on the left of the left, no other places to go. Because the rule says this double has to come up from the neck down.

UNKNOWN
If you do this.

Then we have two.

UNKNOWN
Incomes. That's not acceptable. So.

It may or may not violate the equal. Okay, so I've already said this, but I really want to pound on, um, all heaps of sides and have the same shape because the complete binary tree requirement. So the question.

UNKNOWN
Is. I don't matter. It just has to be greater than any of the values.

Above it, no greater than its parent. So I get it as parents, which by the transitive property of the relation means it's also you only have to check against it. So the point of that comment was that for purposes of the heat property, it matters whether it's greater or less, but for property. But in terms of maintaining the shape to have a location.

UNKNOWN
On the third we have, um, a key with the value of is pointing like when we're in certain elements and put it at that point. And then we would put that in afterwards. What would happen.

Right. So well, um, we're going to go through that algorithm is to take. But the first thing that would happen is we've got a 20 year and then the 18 would go there, the same property would be good, but the heat property, not so much. So as with AVL trees, we had to rebalance when we violated the invariant. When we violate the heap invariant, we're going to have to redo it. So we're going to we're going to do it in those two steps. We're going to we're going to get the shape and then we're going to do the heat problem. So we're going to always do them in that order, which we'll come back to. Um. And it turns out that this, uh, that the sheet property gives us a really super efficient, cash friendly way.

UNKNOWN
To implement these things. Um, okay. So, um.

How can we do it? Now, the truth is, based on the definition of the heat, you can have nodes and pointers. You're used to that. You know them, you love them. Um, they can be very warm in the hearts of people, but we're not going to get the great performance that we want that way. You'll still get the log in. So we'll still be asymptotic. But we're going to but we're going to sort of soup it up and do much better. Um so what we're going to do is we're going to use a data structure that gives us constant time, access to all of the elements. If we know, um, You know the index? Right. Yes. That's what we're going to do. Um, now, interestingly, when I first learned about neatness and trees, we implemented them with the rings. We just did the, the, the pointers that we used with the indices in the array. Right. Because what is a pointer value? A pointer value is an index into the global array of memory. That's what it is right? Uh so if that doesn't make sense, just know that we're going to use an array list. And we are. And that's going to give us constant access to elements by index. Okay. So how are we going to do this. We're ready to see. The algorithm. This is nice. It's amazing. Um okay. So we're going to have an array list and it'll be a current size. Of course there is. Right. And Capacity, but you guys have done already this enough. So from each point of view, one is another person. So there are nine elements. Um, we're going to put the, the, the things in the heap in the array in a level order way. Right. So a level order traversal, which is a good time to brush up on each person. So five it's first then ten, eight and eight, then 12, 11 1413 1211 1413 1022, 4312 okay. In there. Now we're going to do a second trick, which isn't essential, but is really nice for making the math, the arithmetic workbooks. We're not going to use slot zero. We're going to waste a slot. Now remember it can't be empty. We're just going to agree not to look at it.

Okay.

So whatever's in there is in there. If you want to put something in there go ahead. But we're not going to look okay. So this is really neat because now we can. we have this. I know. 123456789903. I know that's become awkward because you can actually get away. All right. So that's that's what we're going to do. Um, so if you do a breadth first traversal of the tree, um, so if I gave you a tree as a node and pointer data structure, you could do a breadth first traversal and you've done that in lab and then emit the things into the array and in increasing indices. And that would be sufficient. Okay. On an exam you could just read it off in level all the way. Okay. Um, oh. So, um, let's take a moment to think, um. Where is the parent of the node containing 12.

UNKNOWN
In the array?

So here's 12. So that's an index for what's the index of the.

Uh, two.

Two. Right. Here we go. Um. Great. And where is, uh, where is, uh. Uh. Let's see, where is ace? Left, child? Uh, the left child. So let's see. Each left child is 14, so eight is in slot three and 14 is in slot six. So close. Just double. But but you've already answered the next question, which is where's the right child. Which is double plus one. You see the pattern, right. And this is this is just a property of the level order traversal of the binary tree. Because it grows it doubles in size in each level. Right. Are you seeing where this is going? So now, um, to find the left child, we don't have to store the left child anywhere Because we can calculate. If you know that you're in slot nine, then we know your parent is in slot. What's that? For the floor of nine divided by two. Four and a half for that is four. Right. So can you see where this is going to be very efficient. So it's cash friendly because we're storing it like this. You guys you'll earn more cash friendly music. Um so I'll just put it out there. So your preference. Um, okay. So, uh, the left child. So if I'm at index, I my left child. If I have one, it's an index. Two, I then my right child, if I have two is an index two I plus one if my parent is at I over two. But doing um the floor of that. So we talked about for two. So floor is the largest integer less than or equal to the value, so the 4 or 4 is for the four of 14.144, and 4.5 is for the 4 or 4.999 is for the that you just round down and ceiling as those brackets.

UNKNOWN
Um, for some flashbacks or children's videos. Um.

There was a video on this. Wow. Okay, so the, uh, the ceiling is the smallest number, the smallest integer greater than or equal to two. Now, the cool thing about four is if you do integer divisions, you plus plus. Right. So that's pretty awesome. Okay. Um, so this makes these things easy to compute. And now if we, if we give you a slight zero the all these plus one and minus ones and these sort of things. But because we used one, it works out. I do want to explore, to sort of figure out what the corresponding things would be if we put it in slot zero. Um, all right. So it's worth mentioning that, uh. Um, so here are some practice questions that you can use to, uh, uh, get more and increase your facilitate, which are these are also examples of questions that you might see on the exam in the future. So, um, we could ask, is it a valid name? But here's the interesting thing. How could it be invalid in shape? You can't. Unless there are holes, it can't have holes in an array. So as long as the array has valid values in it, which it does, and as long as we know the length, the shape property can't be wrong. You see. So this is this is kind of one of the rationale for the problem. If if we could have holes in the tree, then we would have to like have another array. That said whether this array slot has a valid value in it. We're going to see examples of that later. But this is really cool. So the shape property. So then you just have to go through and make sure that every child is more important than its parents. If it's a mean that needs to lower key. Right. Um, so is it. Well, um, two has to be less than four and 16, which is so four has to be less than that. And slot two. So 01224. So that would have to be nested 7 to 9. And you just go through. Uh, if that's too complicated on a scratch paper, you know that this is a level order traversal. So you just draw a tree and you go two, four, 246179 54. And then if that makes it easier because. Because the math is so simple, you can use either representation in life to understand it. So don't don't make it hard to think about if you if you find the other thing. Um, what's the parent of the node that may not. So 012345. So that's in slot five where the parent. Five over two is two with integer arithmetic. So 012 so forth. Um, one of the um children containing nine for their slots became nine, right? Um, do all the trees in the array again? You just level order traversal. Just read this. You put the tree and then to generate the level order traversal which means. That Uh. So, um, this one I encourage you to think about. So if I give you a tree. Uh, not this one necessarily of any size, but I tell you, it's about 15 minutes. What is the position of the last, um, non-lethal. The lowest level and. Right. Most non-lethal. That's. We're going to need that. So. Uh, so those are, those are also popular exam questions. But, you know, here are some more.

UNKNOWN
Um. All right. So how am I doing with them? Okay. Um.

All right. So what we want to do is given this representation, this data is one way of organizing things. Um, how would we implement the team? Ricky. I mean, besides, it's an array that's all the size of these things. So the ones we care about, the main element, main key or the insert balloons, and we'll just we'll just focus on these. Um, okay. So main element is the easy one. How do we do this? That's great. It's the root of the tree. And where. So if the so if the tree is not empty, it doesn't have any. Sorry. If the tree is empty, there's no meaning. But if it's not, then it's the root. And where is the root? And the next one? Right. Seriously. Return h sub one where h stands for a pick a better name. Um, okay, so return h sub one. Here's the only way the root can't be here, since the tree doesn't have any elements. If it has the elements, then a level order traversal always goes inside the network. All right. Um, okay. Ready? Now, the other ones are a little more complicated. Okay. But, um, before we go there, I want to give you the meta algorithm. So remember we had a meta algorithm for, um, uh, the merge sort and quicksort. So we have a meta algorithm for basically all of the mutating, um, operations on a.

Single person. Um.

Okay. Uh, so if we're going to modify the data structure. Ready. Step one ensure that you have, um, the shape in here. Start with that. But the elements are out of order.

La la la la la la la la la.

But it's greater than the parents. La la la la la la la. Okay, this is the psychologically challenging part, because you're going to insert a thing into the tree and you're going to know it's in the wrong place and this is going to kill you, but you have to put it in the in the wrong place, where you have to put it in a place that shape property dictates or take it from you. You have to you don't have any choice about okay, so you do the shape property first. Or if you if you want a choice, it's going to get a lot harder for you. Okay. So always reestablish the shape. And then anytime you mutate the structure shape first okay. Um, once you've done that you almost certainly have violated the invariant. And so then you do that in a separate in a separate step. And that is the hardest thing in the world is to is, is to know that you're putting something in the wrong place, but to do it anyway and to say, okay, the next step, we're going to deal with it. Um, right. So, um, and of course, if you, you know, if you take an element out, the heap size goes down a certain size. So don't forget that it can be very easy to go through a complicated algorithm to get something simple like that. Oh yeah, there's one more element in the heap, right? So don't forget that. Okay, so how do we insert something into a binary. So suppose we're going to insert key value e into this tree. Where does it go.

UNKNOWN
To the left of 1111.

Why. Because that's what the shape property dictates. But isn't the heap property wrong? Yes it is, but but that's it. There's only one answer, right? If you're adding a new thing to a tree, this whole section of it has to go in the leftmost position of the first level that has space. It has to be Otherwise the problem is wrong. So you're absolutely right. It has to go to the left of the left. No other choice. This is why I like it. Because you don't have to. You don't have to think hard about it. It's just. Where can it go? Um, okay, so it's going to go there. But what does that mean for the array representation? Where is that? It's. Yeah. So if you if you've got a size elements then it's the size plus one if position. Because size plus one because we're not using slot zero. Okay. So now they're really um so there really is we can use the size.

UNKNOWN
Index in a way that we may actually have that.

Okay. So it always goes to the end of the array straightaway. Do I have to see if there's already a value there? No, because the size plus one is the position index. The slot in the array is by definition, right. Does it matter? So this operation is like super easy. Um, so we just. Add it to that position. Um, okay. Yes. Now, maybe we had to increase the size of the array. You guys know how to do it? Okay. Um, it's going to be very efficient. So this is just awesome. Okay, so now we have. And now we're back to the shape property, right? Because, um, all complete binary trees in their array form are just the sequence of n of n um values stored in sorted order from position one through n, right. So if I need a 10th element, it goes into like ten. I have nine, 11, three, nine, seven, 11. So I love that because that makes this part of the algorithm really easy to do. So just always put it at the end. Okay. So that's not the end of the story. And so here's the rest of this is uh if you want to insert the key, um, into the entity, then what you do is you first put it in h sub heap size plus one. Right. It's the only place it can go. We're just going to, um, increment the heap size because now you've got ten, right. And at this point we've satisfied the first part of our algorithm. Right. So heat property. Sorry. Um. Shake property, establish heat property. Then, um, what are we going to do about that? Okay, well, this is a little more complicated, but.

It's not trivial. Um.

You. So how could it be wrong? It could be wrong because its value is in many less than the value of its parents. Right? Or if it were greater than or equal to, it's fine. So the only way to do this. And here's where the other problem comes in. You don't care about the children on the other side. So you just don't. You just have to live with our parents. So if we put something in a in a. If you've added a new node at the end, then all you have to do is compare it to its parent. If it's in, if it's already greater, you're fine. Greater than or even if it's a. If it's less than, then what are you going to do? Well you have to sort of bubble it up. You swap it. And then if you've just done a swap, then you have to look at that parent. Are you still in the race. And you keep going until 1 or 2 things happen. You find a place where your parent has a lower key or correspondingly different message. Um. Or you get to the root. In which case.

UNKNOWN
You're the king of the community. Uh.

So that's it. And then once you've done that, now the heat property is established. And this is important because all we had to do was compare along a path from the leaf to the root. The worst that can be is log in because it's the tree. Right? Okay. So constant time. Put it in log in. Potentially worst case steps to bubble up to. The worst case is to put in the thing that now has the lowest value and it has to double all the way down. Okay, cool. And we didn't care about the other options. Right. And so this is this is really.

UNKNOWN
You can share this program or process. Just remember in your own. Welcome here. Uh, so it doesn't.

And so then the question is, can you prove it? And the answer is 160 will prove it. So can the count 15 tradition will go. Yeah, it works though. And uh, and no, but I encourage you to sort of draw some examples because when you draw some examples, you sort of get more condensed and then uh, and then in 160 you'll actually I think we do proofs. Um, it's a good question. And you definitely want to do the proof before you publish the algorithm. Definitely want to do that. Okay. So let's let's work it out. So if we insert nine into the tree as we said we were going to do, um, we we've done the shape properly. So then we just go up. So nine compared to 11. Well that has to switch nine compared to ten. That's not nine compared to five. Oh sorry. Uh it does have to switch this. I can't remember the question. And then it's nine less than five, so that's cool. Okay, cool. So we've already worked it out. Um, worst case is let's go back to that. Uh. We've already worked it out. Worst case is logging. Um, here's mind blowing thing, and I don't remember the proof of this at all. You can go to this paper from 1975. If you have randomized keys to amortized cost.

UNKNOWN
Wisconsin. So in practice.

It's not surprising. So um, so we've inserted but now we want to remove. And that's going to be the other more complicated one. Um, so if we remove it we're going to take five out. But then now the tree has a hole. Trees can't have holes. It's not allowed. Okay. So you have to put something else there. Step number two. But the tree now is going to go down in size by That means the last note of the tree is going to be an invalid index. Invalid slot in the array. Okay. So we've got we've got a slot without a useful value. And we've got a value that is in a slot that's not going to be usable anymore. Right. So you've got an empty house and someone who needs a house. You put that person in the house, right? So all you do is you take the last element who, when you decrement the heap size is going to be an invalid index. So you got to keep them in the heap since you're going to vacate one slot and put them in, the slot was vacated. So you just take the last element 13 put it in. So if you're going to return it then you have to save the value. Um, then you just replace the root with the last element of the array after the size shape property. Done. But didn't we mess up any property? Yes we did. And we're going to fix this. This is the psychological challenge. Because you can't put that there. Can't possibly go on there. And the answer is, well, from a shape point of view it does, but it's wrong. Well, that's the next question we're not answering now. All right. So like I said, that's the challenge. Um, just as we bubbled up. Now you have to double down. Doubling down is a little bit more complex. So the thing you just put in the room probably does change. So what do you mean? Um, well, you have to. It has to sort of take that approach. Um, how do we do that? Well, um, this one is maybe a little less obvious, but the way you would know is that if you compare it with the children. Right. If it's if it's less than both children, it's fine. If it's, uh, if it's, um, less than one of the children, then you swap it with that. If it's less than both sides. It's greater than one that it's greater than both of the children. We have to pick one tropical storm. Oh, and very important when you're doing both of these things. You know, when you're bubbling up, you have to check, you know? You can't go to the left of slot one. So when you're at the root and likewise, you have to stay within the size of the umbrella. So you can't go beyond that. So that's how you know. Do I have a reptile? Well, is my index times two greater than the heap size? It is I don't I don't have a lot on the list. So that's. Not surprising. So remove min. Okay. We did that. Oh, no. Oh, no. Right. Sheikh. Property violated. Ah.

Okay. Great.

Okay, so we take the last thing, put it there. Now we have a well shaped heap of size nine. Okay, so, uh, 13 is larger than nine and eight, but we're going to swap with the smaller one. Um, 13 is smaller than 14 but it's larger than 11. So we swap for that one.

UNKNOWN
And we're done. Okay.

Um, so you can see this is also log n, and it's a bit of a rush, but I want to show you the next thing because the next thing is nuts. If I've got an array of elements and I want to put it in a heap, what I can do is just create an entity and put them in one by one. And that's going to be n things I put in for log n, so n log n, right. This is awesome. You can do it in linear time. What. Oh this is completely not obvious. So if you think you understand why this works, I want to study it. study this. Um, but here's what you do. Uh, we could do b n log n, which is the obvious thing, but it's not terrible. It's very easy to program. Here's the next. You take the array elements and and if you don't mind giving up the array, you just make that the, uh, the contents of the there you go. Or you copy them in one of the order n for the moment, you just copy them in order so you can say, all right, um, 14 goes in slot one and nine goes in slot 213 and slot three. So just put them in shape. Properly accomplished. Right, right. The shape property is correct. As long as you have a sequence of elements starting in one. That's the 15th of the Welsh entry. So we've accomplished step 1NO and then he properties. What is the heap size. And everything starts. Now here's the trick. You ready? A leaf Belief can't be out of order with respect to its children because it doesn't happen. So we don't have to look at the leaves right away because at least a priori believes as much as far as we know, aren't disordered yet. Right? We can't know that. So what we do is we have to find the first element that isn't a leaf from the right, which is the rightmost node that has at least one child. And then we notice that about half the nodes are, our leaves are. So you just take the size over 2 to 4 of that. And that's where you start. That's the first node that has initial go back and sort of sketch this out. This is the first number. And then what do you do. You down from there. So the first time you do it you look at the first one and it's got 1 or 2 children and you compare those. You might have to swap it with a smaller. Don't do that. Now you look at the next. Now you look at the next slide in the array, which is the next node that has changed. And you don't increment. So you just start to go half way back from the right of the array. So halfway back to the right of the array. And then you go element one. You don't go up to the parent. You go element wise. And then you just down each of the elements.

UNKNOWN
So this is not so cool.

And I'm not joking. This is the pseudocode. And the real code isn't much different. And here's what's crazy. Uh oh. There's an example. But we don't have time. So look at the last few slides which sort of walks you through an example. But I just want to give you the final bit of information, um, which is it's led, it's linear quarter. And so you can build a heap from an arbitrary array in it.