If. My roommate had. This. Let us begin. I hope you had a lovely weekend. Um. It's beautiful outside again, so let's hope it keeps up. Um. All right, so today we're going to start our second data structure. But before we do, I just want to remind you, um, homework one is due tomorrow night. Um, I think some of you are done, but, um, many are not, and that's fine. Like I said, it's due tomorrow night. Um, my recommendation would be that you finish it today, and then if anything comes up, you've got time to deal with it. Just a rule. I don't always observe myself. Um, but then I pay for it. And so I would like to save you that pain. Um. Yes.

Do you think the highest auto grade school.

No. We take the last auto grader score. So if it goes down, it goes down. We take the last one. Uh, no. So, um. Yeah. Um, anything else I want to say about homework one? Um, there's some questions that haven't come up, but they often do, so maybe I'll address them first of all. An array can't have holes in it. So oftentimes some folks are tempted to like delete a sub three. And you can't do that. It doesn't work. Um, the way that new and delete work is you use new to allocate one new instance of an object or one contiguous array, all one by one in memory. And then when you delete and you get back the address at the beginning of that storage, and then when you delete it, you give delete the address of something that new gave you. And that same block of memory gets recycled. There's no no partials. You can't, like return an element of an array. And part of that is inherent. C plus plus guarantees that array owners are one next to the other in memory. And you can't just go in and remove parts of your memory that isn't a thing. Right? So you have to deal with that. Um, if you want the client to think that something has disappeared, then you have to arrange it for it to appear using client operations as if that happened. And we'll talk maybe a little bit today about a related topic. Um, another thing is there's no such thing as an empty memory location. So not only can you not return an individual location that's part of an object that you allocated on the eve, you can't recycle that, um, nor in memory, regardless of heap or otherwise. Is there such a thing as an empty memory location? Often students want to write, you know, if a sub three is empty and there's no such thing as is empty. No such thing. Um. Here's why. So memory is filled with bits. You've heard of bits. And that's what we think of. I mean, ultimately, there's the electrical engineers know that there are voltages and currents. And, you know, the particle physicists know that they're quarks and stuff. But at some point we say zeros and ones, um, and every, every bit in memory is either 0 or 1. It's not zero, one or not initialized. It's 0 or 1. There's no there's no third. I don't know what this is or this is empty. There's no there's no such thing. Um, and therefore you can't look at a memory location and say, are you empty? Because the answer is no. Of course there's no such thing as an empty location. It might not contain what you want, but that's a very different problem, right? That's under control. So no. No partial deletes. Um, no such thing as empty memory locations. I feel like there was a third one that I kind of wanted to mention, because it comes up again. No one's asked this on Piazza, but it's been a few years. Maybe they do all this in 11 so well that it never comes up in 15 anymore. But it used to come up in 1501. Um. Well, that's all I have in my head right now. Um, you can if there's time at the end, we can, uh, we can pause for questions or post on Piazza, which is kind of what it's doing. Um, bless you. So today we're going to look at our second data structure of the semester. It's called linked lists. And you'll recall that we had an abstract notion of a list. And this was an abstract data type a list is an ordered sequence of values. Ordered means one. There's a it's either empty or there's a first element, because if it's not empty, there has to be some number of elements. And one of them is first because it's an ordered sequence of elements. Um. If there's more than one thing, then there's a second of. If there are more than two things and there's a third of them and so on. Right. And so if I have ten things, then there's a first, second, third, fourth, fifth and so on. And being computer scientists, we index them with if they're ten things 0123456789. Um. And okay, so that's what the list is. And we talked about why a basic C plus plus array, which is in many respects a list. It's an ordered sequence of elements. They happen to be stored next to each other in memory, which turns out to be a bonus in many regards. Um, the downside is they can't change size. So when you allocate an array, you have to say how big it is and how big is it after that? That's the same size. Can you change it later? No. If you'd like another array of a different size you do, you can do that. And if you want to copy elements between arrays of different sizes, you can do that. But you can't. You can't change the size of an array. So we came up with this way of implementing this abstract notion of a list that allows you to add and remove elements, because that's kind of what we do with lists. Um, and the first one you saw was an array list. And we had all of these. We had all of these operations. You can add something at the front of the back. You can ask, how many elements do have I stored in there. You can add an element at any position so that it becomes the new. You know, if you give it index four, it becomes the new thing in slot 401234. So that makes it the fifth element. Um, you can remove elements. Um, you can't remove memory cells but a list, you can remove something from the list. Right. So there's that. You can ask if it's empty. Um, you can get elements out. You can change elements. Right. So we had all these operations that we had before. And what you've done is you've implemented them using this technique of array lists which can dynamically grow. They could dynamically shrink to. But we we figured you had enough to do this week. So we didn't ask you to do that. Um, okay. So is everybody. This is this is not new. Um, so I kind of already said all this, um, array lists, implement the array abstract data type. And now that you've had a chance to even if you're not done, you've at least had a chance to look at them carefully. Um, and we know that one advantage they have relative to C plus plus arrays is they can change size. That was kind of the this is how we got there, right? We said you can't change the size of an array. But if you hide the array from the client and you can play games, you can copy stuff over, you can add new buildings to your hotel and now you have more rooms and stuff like that. Um, so that was one of the key driving factors. Um, another one that you've seen is that, like arrays, you get fast access to each element. Now, it's not as fast as an array because you have to like there's a pointer. So it's a little bit more complicated. Maybe, maybe maybe maybe. Um, but, um, but on the whole, it's pretty fast. And if you want element five and you want element 10,000, from a certain point of view, those are equally easy to get to and equally fast. And that's kind of cool, actually. Um, and the reason that they can be fast is that because all the elements are the same size, they're homogeneous, and because C plus plus guarantees they're in adjacent memory locations. You don't have to like, go and search for things. You can calculate where the next thing is. Right. So if a thing is in zero address the array that's where it is. If things in sort one, it's the address of the beginning of the array plus the size of the first element. So you skip the first element right. So if this is an array of people cells um uh and this is slot, this is slot zero. Then the address of beginning is here. And then if I add the width of a seat, slot one. If I add two times the width of the seat slot two. Now do you see why we start with zero? It's the thing you multiply by the size of the element to get to the next, to get to the next slot, but you don't actually have to go slot by slot. You can just calculate this. Oh you want slot 10,000. Well that's 10,000 times the size of a zombie. And I just I add 10,000 size of zombies to the beginning of the address and boom, it's right there. Right? And I just go, so that's pretty cool. Um. I don't know if you noticed that, but that is very cool. Um, and whether you thought about it consciously or not, you've been using that fact all along. But it wouldn't be called engineering if there weren't trade offs. Right. That's kind of what engineers do, is we say, well, what do you want? And this thing is better for A and B, this thing is better for B and C if you want to do most of the BS and CS. I pick the second one if you want. And if you want to, and if you want to do X, then scratch and figure stuff out, right? Um. What disadvantages? Yeah. Some insertion operations can take a long time. Yeah, some insertion operations take a long time. Can you give me an example of one that would take maybe the longest possible time? Well, you just.

Insert something at the zeroth index.

Yeah. The way we're doing it now, if you insert at the beginning, um, you gotta you gotta copy stuff. You know, like I said, you can't just add a new cell to the beginning of the array. Um, you have to make a bigger array. And then when you copy the elements, you know, or if there's already space in the array, you have to move them over. Right? Okay. So copying for insertion operations, you might have to in the worst case you have to move every darn thing in the array. And if they're 100,000 it's 100,000 things that got to get moved. So that's a that's a pain point. What else do we got.

Just having to increase the capacity like semi frequently can be an issue.

Yeah we're going to talk about that. So when you increase the capacity not only do you have to allocate stuff but you have to copy the whole array. Um so adding at the end if you have space is fast because you already have the slot. Right. You just put the thing right there. Um, but adding at the beginning of the middle is potentially slow. And then when you fill up the array, you have to do it again. That's pretty slow. Okay. Any other negatives?

We see the reading at any point. But the last element right.

Deleting the last one is easy, but the the rest are involved. The same kind of copying around. And of course the worst thing to delete is the first slot zero, because then you got to move everything over. Um, okay. So um, as we said, certain insertions and removals are expensive because of all of this copying around. Um. Um, I think you're fully aware of this, but if we want to insert, you know, 42 at the beginning of this list, you can't just, uh, you know, you can't put it here and then move it, move the list over you. You can't do that because you this memory might have been given to somebody else, right? You don't know. You can't backtrack and hypothesize what's there, but that's you're not supposed to you can't rely on anything. Um, so we have to put we have to move everything over, and you have to be careful how you move it over. Right? Because if you move this over, well, now you've just lost 17. So you have to start from this, and you have to go. Move move move move move move move move. Now there's still a two here, but you're willing to blow it away to put 42 here because you made a copy of the two of you. Right? So I don't think I'm telling you anything you don't know, but it's, uh, it's just worth pointing out that we're going to have to do that. So then we get this list. Now it shows an empty cell, but of course it's not empty, right? You know this. If I say x gets y, y doesn't become empty. It still has its old value, right? So two is still here, but we showed it as empty because semantically, the way we're thinking about the array is okay. That cell is now free to be used for something because we've copied the value out. Where. And the something of course, is to put the new elements at the beginning. Right. Again nothing new. Now what's interesting about this is when. So we've been doing this this kind of interesting computation to X. It turns out that if every time you increase the size of the array, you multiply the size by a constant factor. So anything two or more is great. You could do 3 or 4. But to to suffices. This actually in aggregate if you have an application that runs a long time tends to work out pretty well. I'm not going to prove it to you. That's what happens in CSS 160. You'll prove it. Um, the amortized cost of this is actually constant in many applications, which again, you don't know what that means yet. We'll know what it means later and you'll prove it in one second. Um, but the the the intuition behind it though is if every time you doubled it, then you pretty quickly suppose an application has 10 million things in it. You actually get to 10 million pretty quick, right? You get to, you know. So a million is uh, is about two to the 20th. So. So if you're doubling every time, you know, it's about 20, 20 copies, which is pretty interesting. And if you do the math, it turns out to not be as bad as you think. Which is why this is one of the most widely used list implementations Available in the real world because it's not as bad as you think. Um, and actually and in fact, the on the average in aggregate, it's, it's actually very good, which is not intuitive. And if you ask me to prove it, I have forgotten the proof. But if I ever have to teach 160, I'll learn it again. So would you recommend if we only multiply it by two in the homework you can to change it to that. You're in charge of your implementation. It must work. Okay. Um, the one I showed in class started with a zero sized array. And of course, zero times two is still two, so that would obviously not work. But I don't know what you did on yours, so you just have to be sure yours works.

Isn't I mean, so if it's a million and.

You know, that's 20 times and obviously not they're not all a million, but many of those are with tens or hundreds of thousands, like copying tens or hundreds of thousands of elements 20 times. Sounds really time consuming.

It does. I warned you this was not intuitive and it was not intuitive to me either. And then you do the proof and then you go, you know, I kind of still don't believe it, but. And yet the proof is correct. Bless you. And not only that, um, people people have measured the heck out of these things, right? I mean, Facebook and Google use these things internally and believe me, if that if it were untenable, they would they would not be used. Right. So, um, uh, I guess I can tell you this. You know, that string is a class, right? It's implemented as an array list of characters. You're basically implementing strings for the homework. C plus. Plus has a has a separate mechanism that, uh, sorry, the string mechanism also does things like supports other languages and which is, you know, for products really important because you want, you know, you want everybody's money. And if they speak a different language, you want to be sure that they can still give you their money. So, um, so it has all this other stuff that isn't really germane to the data structure. It's just kind of other stuff. But, uh, but the essentials of a string are it's an array list of characters. That's what it is. And that's why you can append elements to a string. It it does the same thing. When the string runs out of capacity, it doubles it. There's a wonderful video which I won't talk about. Um, I usually talk about it in 40 because then you really understand the bits and stuff that start doing that.

Um.

So first of all, the copying is even though in, in the, in the limit, it's not bad, there are still times where it's a little unpredictable. I'm adding notes fast and adding a no, it's fast and adding a note. It's fast. I'm adding an element. Okay, now it's done right. So it's a little unpredictable. And there are applications where unpredictability can be a problem. I often think about automatic braking systems in cars. You know, it's gotta work in so many milliseconds. Basically, before your head gets to the dashboard, it must work. There's a hard limit here. And it can't be like, well, you know, every you know, if you turn the radio on and off 16,000 times, then it's going to actually take an extra 200 milliseconds to deploy the airbag. It's like what? No. Right. So there are times when there are times when even if an aggregate, it's good, you would choose something else because you need the predictability. Right. So that's it. Um, but it can also be space inefficient. And that's interesting. Right? Every time you double, every time you expand the capacity, you essentially have 50% unused space. Now the application might use that space, but in general you can expect to have a substantial amount of wasted space. If you've got a million things you know you'll get up to, you know who knows? It depends on exactly where you start and what your you know. Is it two x plus two? You know, it depends a bit on what it is. But, you know, you might have 25% unused space. Right. And that can matter to um, so we've we've got this this time thing which is subtle and interesting. And you're just going to have to take my word that for most applications, the time thing is not as bad as you think, though for some it is as bad as you think. And um, but the space efficiency is kind of an interesting dilemma. Now, one solution we could do is we could say, well, instead of doubling the capacity, we'll just add one each time. So there's never any excess capacity, no space wasted. Or we could add ten. Right. So if you add a constant value though then you lose the time inefficiency proof does not go through. So you lose that. So so this is a very clear what we call time space tradeoff. You can make it reasonably fast for 99% of applications at the expense of wasted space. If you care about the space you're going to. It's not going to be fast and efficient. So I said, we're engineers, but I want it all. But you can't have it all. That's part of what we do. That's the world we live in. You can't have good things. You can't have nice things. Yeah.

Um, wouldn't there be another, uh, inefficiency when, for example, you fill up your ArrayList and then you delete a bunch of elements, and then let's say you don't use all that space anymore?

Yes. And that's why, in fact, a lot of, um, I mentioned that they can shrink and the ability to shrink is actually pretty common in the real world. Um, very often the, the, the API id is if you have an application and, you know, you've kind of gotten everything you can tell in this and it might shrink to, to avoid wasting space. Um, but they didn't ask you to do that. But you're absolutely right that, you know, if you're not using, space is wasted. And you can get that by adding this thing and never using it. Or you can get it by using space, not using it, but not returning it either. Right. So both of those work. You're exactly right.

Do they usually shrink automatically? No. Okay.

Um, and if you think. Well, um, after you take 170, you'll realize why. Okay. Um, so we're going to do linked lists, which. So it's going to implement the exact same abstract data type. So it's going to be a list. It can grow or shrink. You can add to the front. You can add to the back sink. You just take the h file and you replace array list with linked list. And then the private section is going to change. But the public section the only change is array goes to length replace string array. Right. Um, so same operations from the client's point of view. You just give them the dot h file with the new private section, they recompile. Their relink should work. Performance will change, but the semantics won't change. So that's really interesting. I've been using I've said semantics twice now. Semantics means the meaning of the thing. What it means syntax is kind of the form on the page. Right. So a syntactic rule of English is you end sentences with a period. That's a syntax rule in C plus plus you put a semicolon at the end of a um non compound statement. Um declarations begin with the type of some content. Right. So those are syntax rules. Semantic rules are what do they mean. What does it mean. Um if you have a for loop it means you do the initializations. Then you do the test. If a test is true, you do the body, then you do the updates, then you do the right. So that's the cement. The semantics are what does it mean? Um, so we're going to have the same kind of list semantics, but we're going to have very different cost tradeoffs under the covers. Um, all right. So I'm going to tell you the key idea of a linked list. And this is really great. All right. So I'm going to define a linked list. A linked list is either empty or not empty. If it's empty it's empty has no elements. If it's non-empty, it contains at least one element. So it contains an element. And it contains the list of all the elements after the first one. That makes sense right? So I'm going to if I'm back to my my list here, I'm going to divide the list into the first element. And then I've got I've got an ordered sequence of remaining elements. Wait a minute. Ordered sequence of elements. That's a list right. So I just say, you know, I've got this concept of a list I'll just reuse. This definition is recursive, right? A recursive definition refers to itself. Okay. So we'll see how this works. But basically these two cases we're going to use to guide how to guide our implementation both functionally and in the data structure. Right. Because when we say we're going to represent a list in this way, we now have to represent an empty list and a non-empty list. So we now can answer those questions somewhat separate. Right. What what is an empty. How do we implement an empty this. How do we implement a non. Yes. Okay. So I'm going to use the example of boats. But I drew them very quickly this morning though I daresay it's no worse than it would have been had I drawn by hand on the board. So I'm going to draw a boat like this. So it's a rowboat, and it has a hook on the front, and there's a rope attached. Why is there rope? Attention! Well, so that you can. So you can tie the boat up. Because otherwise they just drift out to sea, which is. So we have a boat. And the way we're going to organize a list is we're going to say. And so we're going to put our data elements in each boat. So maybe we're going to have like a parade. And we've got, we're taking the, we're taking the, the fourth graders out for the boat parade. And you put a fourth grader in a boat, and then you put another fourth grader in another boat. But you might look. Like a tree, you know, you know, you put and then the third first grader, you get the idea. Okay. Now the thing is, if this is so, this is how we're going to implement a non-empty list. A non-empty list is a boat that contains an element and a way to get to any remaining islands. Right? Okay. Um, at some point, the party's over, right? There has to be somebody at the end. Now, if you if you tell each kid in the boat, they have to keep track of the person behind them, then the person in the back feels really awful because it's like, well, how do I keep track? And why not special, right? So so you give them a balloon and you give them something. And and so we're going to represent the emptiness. All right. Now the cool thing is if you've represented your list this way, kind of each element keeps track of the element behind it, but also all the elements behind it in a way. Right. So this person is keeping track of the empty list. This element is keeping track of this thing which is which keeps track of this one's keeping track of this, which keeps track of this, which keeps track of this. Now, as the implementer of the list, you have to keep track of something. But now it suffices to keep track of just one. You just keep track of the first one, right? And of course, you know, you can have a dock and you tie the first boat up. And this actually is. I mean, okay, it's it's a little crazy, but it's not it's not completely nuts that you would have a dock and then you would tie all the boats together. And when people want to rent the boats, they take the first one, they pull the second one in and they tie it there, and then they go off and they have a good day with the first one, and then they insert it at the back or somewhere at the end. Right. Okay. Everybody clear on the concept of boats because we're going to we're going to descend into C plus plus now.

So were you the last boat. What's that. Where do you tie in the last one.

So each boat is, if you like, is tied to the boat in front of it.

And the last one.

The, the last one is tied to the next is the last one, which is tied to the next to the next to the last one, which is in this case tied to the duck. Um, but then after the last one, that's the difference is after the last one, since there are no more birds. You need a way to. You need a programmatic way to distinguish boat from not boat. And so we have to consciously represent what what's the thing? That's a list but not a boat. What's the thing that's a non-empty list which would be an empty list. How are we going to do that. So I'm going to start with the non-empty case because that's more complicated. Um. We're going to use this concept of a node. Um, in computer science a node is typically an element of what we call a linked data structure. It may or may not contain some data, and then it contains a way to get to other other nodes. We're going to see nodes for the next six weeks or so a long time. Um, okay. So um, this is a linked list node. And for a linked list node you can see a non-empty list contains a data element. And the the rest of the list which might be empty if there's if this is the only element Okay. So we're going to represent that pretty directly. It's going to be a struct struct in class in C plus. Plus are actually the same thing when the program runs. They're only different at compilation time in terms of what the default visibility is. But if you've been good about using public and private, you're not relying on it. So you could actually change the word class to struct and all your code would still work. Trivia C plus plus trivia. Um, normally when we sort of glue a bunch of data values together without abstraction, we we call that a struct. That's kind of a convention. Um, but C plus plus is wackiness. Okay. So what we're going to do is each node is going to store one data element, and then a way to get to the rest of the elements. So I just wanted to clarify what do you mean by whose addresses represent non-empty lists. Um, well, because we're going to have two. I'm trying to keep in mind that we still haven't figured out how to represent empty lists. Okay. So a non-empty list is going to involve a node. An empty list may or may not involve a node. We have to decide that still. So that's still pending that decision okay. Okay. Um all right so we've got an element type. Now you can't actually you can't actually put a node struct inside a node struct. When I was in high school I went to see a movie and I forget the guy's name. You know, there used to be this guy in Hollywood who did, like, all of the film trailers. In a world where mice rule the universe or whatever, you know, that that that person with this voice that makes you scared of whatever they say. Um, and they came on and they said, inside every man are our two men. And we just lost it, my friends, because we say it inside each of them, or inside each of them or two more. And now the universe is filled with these men, and you can see the flames and bombs that are involved in this movie. I don't remember what the movie was, I just remember this line from the trailer. Um, so you can't do that because computer memory is finite, so you can't, like, have a node that contains a node that contains a node that contains a node that contains a node forever. So you have to break this cycle. And being good software engineers, we break the cycle with indirection. So what we do is we we don't store another node inside a node. We store the address of another node inside out. Right. Okay. Um we'll see what that means in a minute. But how are we going to draw these? It turns out that you can draw them like any other struct. It's a box with a label for each thing. You can do that. But because linked lists tend to have a lot of these things going on, we tend to simplify the drawing. And we do what's called a box and pointer diagram. I think it's obvious why it's called that. Um, and this one we've labeled data. And that's what usually we leave those off because in a linked list One of them is always the data and the other one is always the link, and some people put them in the other order. But those people are weird and they know and they're not all. I'm sorry. I, um, one of my dear friends and colleagues in the department does it that way, and he's no. So, um. And he does it for a very good reason, which you can talk about in fortnight. Um, okay. So now if we have a whole bunch of elements, we draw the picture like this and you know that. So this is the way we think about memory. But this is a precise memory diagram. It's not just the way to think about it. This is actually a struct with two slots on the left. One contains the data element. The right one contains the address in this case of another one, and so on. That's okay. Um, so. In the array list we were still using arrays. And one of the big things about arrays is that they represent contiguous storage. This is good because it makes it fast to get the individual elements, but it's bad because it's sort of at the heart of what makes them hard to resist, because they have to be contiguous. Right? And this is why you have to like if you insert a new element in the middle, you have to, like, copy everything over. Right. So, um, so that contiguity is both their strength and kind of an issue complication. Um, so in Linkedlist, the idea is that each node can be anywhere in memory because you just you store the address of the next node in the address of the next node in inside each node. So, so now each node can go everywhere. Everywhere. Right. So, um, would you do me a favor and pick someone behind you and point to that? This is not to be considered rude, okay? Point to someone. Okay. Point to some. Somebody far. Yeah. Oh, good. Okay. So now we've got I think you're pointing here. Okay. So if we traverse this list we go here, then we skip a bunch of cells. We go here, then we just then we're nearby. But then for some reason, we come all the way over to this section memory. Okay, you can put the hands right so you can see that now we get some flexibility. Each element can kind of go anywhere and we keep track of the order instead of by instead of using the order of memory to keep track of the order, we we we make that explicit by using memory addresses. Okay. You're the first. And who's next? Okay. You're the next. Right. So that's how we keep track of the order. So inside your class you're going to have to keep track of something. If each node looks like this then you just keep track of the front. Or it's suffices to keep track of the front. Um, because from the front you can get to anything. Right now, if you see that there are problems with this, um, just keep it to yourself. You're absolutely right. There are problems with this, but it does have some advantages. um, you just follow the links to get to the next place. Okay. Um, now, I said that, uh, we we need to represent an empty list. And the way we're going to represent an empty list. Is this a node whose next cell has to contain a value that would indicate that the list is. Now that that the list of remaining elements is empty. There's nothing after this. Right. And there actually, you can do this in several ways. Um, but this is a situation where you have to use a sentinel. Have you guys heard of Sentinels? I know they must do this in 11 because they may not call it that, but. So a sentinel in computing is a device that stands at the end of something. That's how you know you're done. Now, the critical thing is a sentinel can't look like a data element. Right. So if you're if you're reading in a list of ages, you could say any negative value can represent a sentinel because nobody is negative one years old. But if you're measuring temperatures, negative values are valid things. So you can't use a negative. You know, you can't say -one degree Fahrenheit is essential because it could be -one degree Fahrenheit. Right. So we have to pick a pointer value. We've already committed to this, but it can't actually be the address of a node. In fact it can't be the address of a non-empty list. So we need a way to have a special pointer or a collection of pointers that don't represent lists. And the easy one to do is there's a built in thing in C plus plus called the null pointer. And the null pointer is is defined to be this. It is a pointer value that is guaranteed not to be the address of any object a regular user program can have access to. That's the definition. So it's by definition illegal for you to dereference it because by definition it is not the address of anything you're allowed to touch. That's its that's its definition. So trying to trying to touch the thing behind it is bad. And mostly on our systems your program crashes at that point with a segmentation fault, which is good because if it didn't, just weird stuff could happen. Right. So crashing is better than weird stuff. Okay. And so we have two ways to notate this in our C plus plus code. We'll notate it. New helper. That's its official name. In our diagrams we'll just draw an arrow that goes to an empty set. There. That is this is the address of nothing to see here, right? That's what I mean. So we'll use this. This is the most common choice. Um, I have done other ones, but I confess I did them mostly to prove that you could have other choices, which is not really a valid software engineering decision. Um, okay. So does everybody up to speed on what we're doing. All right. Um, now, you'll notice that in this situation, adding to the back is tricky because you have to, like, you know, you've got to, like, jump from one vote to the next and you can go all through memory. Um, and that's going to be a problem that persists. But you could keep track of the last element separately in your implementation. This is pretty common. They're often called front and back. They're sometimes called head and tail. There's some time. Um, I feel like there are other names for them too. Um, head and tail confuses me, but that's because I grew up speaking lisp. And then, uh, and so our our we ours are snake tails, and these are sort of more like pigtails. Um, anyway, you can keep track of the back. There are a million variations on linked lists. You'll see one in the homework, actually. But let's stick with this one. This is called a singly linked list. And we're just going to keep it simple with a front. I'm just pointing out that the first variation you might think of is, oh, it's so hard to get to the back, but can you track it with that? Have another private data member called back and store the address in the last minute. But what if there are no elements? Well, you kind of have to figure that out. What if there's one element? Well, I guess it's both the first and the last, isn't it? Um, so each each choice comes with its code complexity and advantages. Okay. So, um, a linked list can be either empty, which will represent with a null pointer, which again is the most common choice. Um, or it's non-empty. So it's a node with a piece of data and the address of the next element or the address of the thing. You dare not dereference the null. Okay. So we said the definition is recursive.

What? This may be a bit weird, but what if you make one of the nodes point to a previous node, and now there's no. And you're never going to get to know.

If you do it on purpose. We call this a circular list. So the question is what if? What if you make the last run, you know, point back to the beginning? Um, if you do it by accident, it's called a bug with a, with a list with a cycle. And can it happen? Oh, yeah. Have I done it? Yeah. Did I wait a long time for some things to happen? Yes. And would I still be waiting had I not taken action? Yes. Right. So yes, you can absolutely create cycles. But the interesting thing is you do them on purpose. So linked lists are you'll hear people tell you, oh nobody uses linked lists. That's false. It's just false. Have you heard of Linux? All of the lists in the Linux kernel are linked lists. And in fact they're all doubly linked lists. And almost all of them are circular linked lists. So and don't tell me Linux kernel performance is not performance critical. You're not going to get away with that. It's absolutely performance crap. Uh, okay. So, um, so let's look at a list and consider add to front. Okay. So this is what the list looks like. Let's figure it out. When you're doing it. The labs in the homework really draw the pictures first. Bring pencil and paper to life. Absolutely. Um, because the code is sometimes the code is hard to write. But even when the code is hard to write, it's easier to do with pictures. And there are times when the when if you get the picture right, the code is almost trivial. So you want to leverage that if you can. So let's consider adding a front. So what do we have to do. Let's have somebody from further back. Yes. Uh, redefine Brian as we want to have to the front and then connect that to the previous one. Okay, I don't have enough slides, so I'm just going to keep track. So you're absolutely right. So now this used to be the front of the list, but you're going to add a new one, so you're going to have to update front. That's important. And front is going to have to be updated to be the address of what did you just say, uh, address the previous front. Well of the value you're adding, which is going to be the previous to what used to be the first out. Yeah. This is why the pictures are better. The language is harder, C plus plus is even worse. But even the English is hard. Yes. You're going to have to you're going to have to make a new node and then you're going to have to put Sophie in it. Is it Sophie or Sophia? Sophia in it. And then and then front has to point to Sophia. So we're missing a step still though. But that's that's exactly right. And yeah.

Uh, first you want to make sure that the Sophia node points to, in this case the above node, the first one, so as to not lose the address of the above node.

Yeah. So you just you just said something that's really important so that you don't lose. Here's the thing. Nobody's keeping track of these pointer values except you. So if you assign a pointer variable, a new value, whatever was in there is destroyed. If you care what was in there, you needed to have saved it somewhere else first. Right. So order matters when you're doing these updates. So what you're going to find is generally when you do a modification to a linked list, you can build like a collection of pointer variables that need to change. Um, and then you have to go through using your programmer muscles to be sure you do it in an order that doesn't actually lose any data. Really important. Um, so you guys have pretty much spelled it out. So I think we can we can walk through it, we can create a new node that has Sophia in it. Then Sophia is going to be the first element of the list, which means the list of elements after Sophia begins with what used to be front right. So Sophia the note the new node arrow next gets front. We're going to copy the pointer value out of here and store it there? Then Sophia will point. To. But. Now Sophia is the front of the list. And we have. We have to have. I should have written it here. We have to have a temporary value keeping track of Sophia, because otherwise she's going to float out to sea on their boat, which would be most unfortunate. Um, and then we have to make from point to Sophia. And now you can see if somebody goes to the front. Sophia is first problem second, analysis third. And everybody has effectively moved back one with no need to copy the elements. Okay. Um, kind of walk through this, but, uh, I will tie my shoe and let you absorb the information about how we did it. Right. So adding to the front is really easy. You create a new node, you initialize it, you update two pointers. It's done. Um, for an array list. Shift everybody over, then put the new thing in the first line. Okay, so this one, not all the operations are easier. I'm going to warn you, there's no panacea here. So array lists are going to be better at some things and worse that in others. And in this particular case, they're better. Um, okay. Good. Okay. I think. I always think I'm doing okay, and then I'm not. So let's, uh, let's let's keep moving. So now what I want to do is. In the lab, in the homework. You're going to do this in classes, but I think I want to code it up today a little bit without classes. So then we just get used to manipulating nodes and pointers and stuff. Um, so I'm going to show you I'm going to get you booted up on what the class looks like. So you're prepared for lab and then we're going to do some, some programing. Um, right. So, um, you know that what's going to happen is you go to a string linked list, there's going to be a constructor at least one and a destructor, um, you know, whatever. Same interface, same interface. Um, now what's different is the private section completely different because we're representing it in a different way. Right. So in this particular case, we have to say what a node is. Um, and we're going to put that. Now this is interesting because you probably haven't seen this before. We're putting a type definition in the private section. This means clients don't have access to nodes. This is good. Why is it good? Uh.

You don't need to know like what the node does. They just need the list. Like, they don't need to worry about, you know, the pointer or whatever. They just care that everything is.

Yeah. Telling them is just temptation. So even if you don't let them manipulate any of the pointers, the very fact that they know what the data structures look like, it's the just it just like invites them down this rabbit hole that you don't want them to go down. Um, but there's another thing that's interesting. It turns out that if you made this global, if you said there's a type called node, well, now the client can't have another type called node. But what if they're a physicist and they do they do simulations on on on waves. Wave interference patterns are described with a thing called nodes. They're going to want a data type called node. So there's sort of two issues. One that you, that you um, bring to the fore, which is they have no role to play in these nodes. They're storing values in the list. They're not storing nodes. They're storing values just like they didn't store array elements before. They stored just data elements. And you put them in an array. Right. Um, so it's none of their business. And just telling them about it is, is just going to create psychological trauma for them. So you don't say you don't tell them. It's going to create a little trauma for you. So this is kind of why I'm beating on it. Um, uh, and uh, but the other thing is it doesn't pollute the namespace. That is, it doesn't create. It doesn't. So normally if you name a global thing, they can't have another thing with that name. So they can't have another type called string linked list, which seems unlikely if you're the string linked list implementation. But note on the other hand very common in other disciplines, right? So we don't want to inject more things than we have to into the namespace. You always have to inject one because you have to access your stuff. So you always have to do that. Okay. Um, now um, we're going to keep it private for abstraction purposes. Um, and to keep the namespace, to keep that name free, we could do something crazy, like, say, uh, we're defining a new type called string linkedlist node underscore underscore 32147. You know, like you know, how tough does that when people's email addresses sometimes we could do something like that. But um, but this is better. You just just keep it private. And then and then the whole problem goes away.

So does that mean.

Like with the namespace, does that mean that like since we have, like for our assignment, like one of the methods is toString, does that mean the client can't have anything called toString?

Like yes. Now overloading is possible. So you can have multiple things called two string as long as the parameter type, number and types of parameters are different okay. So you can so overloading is still okay. But you can't overload a type. You can overload functions but you can't overload a type. And you've already seen that C plus plus does have a thing called namespace which is for problems like this. But I don't want to talk about it. And honestly, I don't have much experience with it. So if the client does have their own node class, would that interfere with this, or it wouldn't be private because it's private. So within our implementation, when we say no, it's going to mean stringing to this node. If we mean the other one now we have to do something special. Okay. But um, but it's going to do the right thing, which is fascinating. Um, okay. Now, um, if you do this, which you are required to do for the homework, so you're going to do it, um, there's a little sticking point and you guys have seen that you can, um, you know, you can refer to class members inside a function as long as the function is declared to be inside the class. Use the scope resolution operator for that the to the double code. So string linkedlist code and colon f. Now f can do string length listings right. Even private parts. Okay, here's the problem. Um. If you declare a function. That returns something that involves string linkedlist. Sorry, that involves a node. Okay. Technically, the C plus plus compiler reads top to bottom, left to right. So if you just wrote node here it say node okay. What's a node. What's a node. Well I don't know if this thing is inside any class or not. So do I have any freestanding nodes? Nope. Nope. Never heard of it. No such thing as a node. Have no idea what it means. So at this, at this point in the in it's in the in the compilers process, it doesn't know that the function is going to be inside the class. And it tries to resolve the name first. So you have to tell it. You have to say I would like a string linked list colon colon node. And if you call this function and dereference the result you'll get one of those. So I'm going to return the address of a link string linked to this code and colon. Is it annoying? Yes. Yes it is. Um is it terrible? No, not if you just keep string linkedlist, colon, colon or the palate somewhere and keep tasting it. Um, which I do for the functions anyway, so I kind of have one of those lying around. Um, and then and then so this function is called new node. It's going to be inside the class and it's going to take two arguments. And oh this is on the slides I got the slides. So out here C plus plus doesn't know what a node is. You have to tell it I mean the one inside the string Linkedlist class. But over here it does. No because it's already seen that this function is inside the string linked list class. You could write it there too, but you don't have to because now now the compiler has the context. Okay. So I just want to warn you about that because it's going to bite you in the lab in the homework. Um. So I think we'll do some programing question.

Uh, you certainly talked about, um, what does that mean theoretically within the header, which is within the class where you're defining it within the class. You don't have to write it out in full.

If it's inside the class definition, you don't. So in fact, if you look at the definition we had before, you'll see that it's not here. Um, and oh, and if I declared the function here, I could just say node star new node. So I thought that it was here, but it's not. Okay. So in my imagination, new node is declared here and you don't have to use the string linked list colon colon y because it's inside the class definition. So now that so now the context is apparent. Yeah it's a good question. Very good question. Okay. Um. All right. So I have a plan which I wrote down and hopefully brought with me, um, in just a minute. Not this plan. This plan. Okay. Um. All right. So I just want to get some practice with nodes and stuff. And so let's, uh, let's have some fun with it. Um, hold on just a minute. I need to sanitize my screen. Okay. List of Tas that work for me. That's probably not a good thing to leave up. Supervisor. But, um. Okay, so I will now share my screen. Uh, let's see what happens. So that's sort of what we like. What we did last time. Um, can you guys see that? Okay. Great. It's not necessary. It's all right. Doesn't matter, does it? I'm curious now. Yeah. See this one? I can go up and down. Why can't I do that? Um. All right, so what we're going to do is we're going to write a program that does that does something with linked lists, and we've got a song list mode, because I'm going to I'm going to do a playlist and I'm a big Nat King Cole fan, so we'll do so we will all talk about Nat King Cole songs. It's not because I'm in the front of the room. I get to pick the artist. Okay, so that's the plan and main return zero. So if I do, um. Oh, sorry, I didn't. Okay, sorry. Miles and runs without obvious error. And it returns zero, we expect. Okay. Um, I don't think anybody is surprised because we haven't done anything. All right. Um, so let's do this. Let's make inside main. Oh, so the code is here on the left. Um, the terminal is lower right, and the upper right is going to be sort of a memory diagram, which we're just going to do for the first couple of examples. Um, I did it in Ascii art. That way I don't have to draw. Okay. So, um, so what are we going to do? Let's, uh, let's make a song list node. Um. And we'll make a pointer to a song list. And now. So now we have a new song list. Right? So now we can initialize it. We can say song. One arrow name gets. Four. And. you know, if you don't know the song, then that's okay. I will delight in hearing it inside my head. Um, and then there's a did I call it next? Next. Okay, so we've just created that. Still compiles. Of course, we didn't print anything out, so. But at least it doesn't crash. Right. So we've sort of figured that out. Um, and so now what we think we have is a diagram that looks like this. Okay. So on the stack we've got main's activation record. We've got a variable called song one. It has the address of a thing on the heap. That thing is a using box and pointer diagrams is a list node. It's got a string in the beginning. And we know that in fact that if we drew this out more carefully. We know that the string is an array list, so in fact there's an object there that has a capacity and a current size and a and the address of an array of char and the array of char is somewhere else on the heap. Right. So but we'll do it sort of in style because we don't care about the internal structure of strings. Um, it works enough like this that we're okay, but the diagram is glossing over a bunch of them. I just want to put that on the cover, because now you guys know how it works. So that's really easy. Okay, so what do I want to do next I think I want a second song. Um. Oh no, I think I want to print this one. Yeah, yeah. That's it. Um, so let's print it. We will send it to. Yeah. By the way, um, this means print in C plus. Plus or it means send to or receive from, depending on whose point of view. So see how it will receive from where we received Song one zero NE. And then, um. There we go.

There we are. Right.

Now, I want to add a second. All right, so let's do this. You can do this. Copy and paste is evil. Did I tell you that copy and paste is evil? And we want a different song, and I think. That's a nice one. Um. Okay. And then we should. And then we should be able to print that one. Then we get down and the memory diagram now looks like this. Okay. So that we've got two things. Each one has a null pointer. Now we don't really have a list yet. We just have these two nodes. But let's put them together shall we. So let's do that. Let's um. Is that the order I want to do it in? I think. I think so, um. Yes. So once we made, um, song list two, we can say song one, arrow next gets song two. Right? We. Okay. And so now we could do this two. But we can also get at it another way. We can go through song one and say, and the thing after that is another note and the name in there. Let's print that and let's see if we got it right. All right, all right. So we're seeing how they compose. Um, should we do a third one? What was the third song I picked? Anybody remember? If you remember then you can. You can steal my laptop. You can. Um, okay. Because I think I changed it this way. All right, well, let's forward the way you look at me. So, um. Okay, so now we can do song list mode. Song three gets new song list mode. Um, so the arrow name. L o v e. And now I'm doing it a bit clumsily, but we'll streamline this in just a second. Um, well, we could say that song three is next is song two or something, but I kind of want to put this at the end. So what we'll do is we'll say that it's the null pointer. And then what we can do now is we can say song two arrow next. Yes. So three. And then we can. We can go to the first. No. Go to the follow the next pointer which gets us to the second node. Follow that next pointer which gets us to the third node and then ask for the name of that. So we can do that. And if if I screw up please tell me. Um. Okay. Everybody all right? Okay, so now, before we start to get too involved, you can see where, like, copy and paste in these blocks of code. That seems silly, right? Kind of what we need is a constructor, but I'm not going to do it. The constructor, I'll do it the old fashioned way. Um, and so what I'll do is I will say I'll write a function. That if you dereference the result gets you a list node. Or it could be known as the null pointer. Um, I'll call it new node. And it takes a string, which is the name, and it takes, uh, the address of a song of this node or a thing. You could dereference it one and that'll be the next thing. And then, and then we can just copy those things, we can say, um, song list. Uh, there's all to get. to new song list node. And then consult their name. Gets name. Result. Arrow. Next. Guest. Next. So we're just passing along the stuff and then we return the result. People. And the contract goes up here. Okay I'm going to I'm going to short change this. But that's a placeholder for a nice contract which we should we would write right now if we weren't on the clock. Okay. So now I haven't called the function yet, but it still worth compiling because it turns out I screwed up. Um, anybody know what I messed up? Well, it's expecting me to return the address of the node. The variable holds a node itself. I don't want to return the address of a node that's stored inside the activation record, because that would then get destroyed on return. However, I have I did create the thing with the right, um, value. So I allocated it on the heat, but I stored it in a variable that doesn't hold a pointer value. Uh oh. Vicious. All right, so I haven't. So despite having not even called it, I haven't heard anything yet. Right. But now we can take each of these things and we can say.

Oh, no, that was too bad. back.

I thought I was being so slick. Okay, two uncoordinated rats. So we should be able to do that, right? Okay. In fact, we should be able to do this. My cursor will stay on one line, and we can. Oh, wait. This one means another argument. All right. This should give us the same list. Did I screw up? I don't know. Um, let's find out. I really don't know. One of the reasons I do live coding is so that I screw up without the plan. But I do get the same list. All right. Cool. So we've just followed a programing pattern where you've seen a pattern emerge multiple times and you're always like, keep doing this. Why don't I write a function to do this for me? Right. And we don't really need it here. Maybe. Or maybe we do, but we could make, um, another we could overload this. And remember, you can overload constructors, right? We could do this and say, what happens if someone wants to make a new note, but they just give you a name? Well, then the next pointer should be null pointer. Then in that case. So I can make sort of it's a trivial function. It's easy to write. Oh, wait, I want to go back here. But this. Now I have to get the number of friends right. So you can see how we are. So we took a pattern. We embedded that in the function. It turned out there were a couple different cases. We generalize the function by overloading it for for a separate case. And then we modulus. We used the more complicated case to implement the the what we might call a degenerate case or a simpler case. This is really degenerate. Um okay. How's everybody doing? Now, I haven't been following my script, so, uh. Uh, okay, I did all that. Oh, wait, did I ever show. Oh, I never showed you this. Oh, it's too bad I missed it. Okay, rewind back in time for just a minute. There we go. So that was the that was the list we had before. After we made the second node and then wired it in. All right. Uh, print overloaded song now and, uh, rewrite me. Okay. So now what I want to do. How much time do I have? Uh, shoot. I had five more minutes. Okay. Somebody, um, somebody go over to the clock and push the hand back. About five minutes. Uh, all right, here's what we'll do. Um, well, we'll just think about this for a minute. Which one do I want to do in this case? Um, I'd like to print the list. I can think of two ways to do this. Lovely and recursive. Now, the the the list is defined recursively. And the beauty of a recursive data structure is it's very often very easy to write code. That kind of mirrors the structure of the recursive data structure. So what I'd like to do is take, sadly, just one minute and work with somebody next to you. And if your birthday is before July 1st, you write the loopy version. And if your birthday is after July 1st, sorry if the person on this side of the couple is. So it's their birthday. So if the person on this side of the of the pair is born before July 1st. So up through June 30th, um, you write loopy and if it's July 1st through December 31st, you write recursive. You have one minute coming. Your.

Oh. Yeah. Oh. Yeah. Oh! Yeah. Oh! Yeah. Well, I mean. Uh. Oh, yeah.

You guys must be relaxing.

All right.

I'm sorry. I budgeted five minutes. I often do my timing before I do figure out what announcements I want to make. And that's usually a bad idea, because then the announcements turn to take time. Okay. Um, uh, let's start with the recursive one. So who did the recursive one? Show of hands. Okay, there should be more, I think, but. All right, all right, all right. Um, uh, someone from this side of the room. Because this side has been quiet today. How about, uh, can you give me a little guidance? Get me started on it? Um, no. Behind you. Oh, yes.

For the recursive.

One. Yes, please.

Um, we're just, uh, so for printing recursively, we had, um, for each element, uh, you would so print the current element and then you would call print recursively again on the next node.

Okay. And the current element would be this. Yeah. And then print. Recursively. So this is the this is the heart of the matter. Now there's a little bit of a trick here because we're missing one thing. What are we missing. Base case. So when we're going to talk more about recursion, but generally you have a base case where you don't need to do recursion. Um, doesn't mean you don't do anything. You might have to call other function, but no recursion. And then you have the recursive or general case or cases. So this is the recursive case. This is only true if the list isn't empty right? So we have to decide what to do with the empty list. Um.

Okay.

If not, sorry. And of course, I haven't defined it's empty, so let's just do that.

Okay.

So first is the null pointer. That means the list is empty. If the list is not empty, you print the components. If it is empty, you don't do anything because there's nothing to print. Oh, and I wanted them one per line. Um.

Okay.

So this is beautiful, right? Um, let's go down to main, and we will, uh. We'll get rid of all this stuff, and we'll print.

Recursive.

Starting song one.

Oh, let's see how this goes.

Oh, no.

Oh, no. Uh, what did I mess up? You just wrote a set of songs. Oh, yeah, I did.

You're right. It's song. This man. Thank you, thank you, thank you. And it's not called rest. It's called next because I was saying the rest of the list. And so then I wrote rest, which I do sometimes call it. So that makes sense. And that's okay because we haven't written that function yet. I don't know okay. So it works. All right. Um, we have just, uh, one minute to do the loopy one. I kind of wanted to do the destructor, actually, because that's sort of critical. Here's what I'll do. Um, I believe you can probably do the loopy one, so let me just talk through it, because there is a time. There's the idea. The order matters a lot. You can't go through and delete the first node and then get the next thing out, because once you delete something, you're not allowed to access it anymore. So there are two solutions to this. One is that you keep the pointer for the first one, then you delete that. Then you, um. You take the pointer out of the next field. Then you delete the node, then you recursively delete. That's one way to do it. Another way is to delete the rest first. And then when you return on the recursion to delete the the node whose address you get. So those are two ways you can delete on the way down. Being very careful to extract the data from the node before using delete, or you do it on the way up, which is easier to think about I think. Okay. Um, okay. 20s remaining. Are there any.

Questions? All right. Have a great day, everybody. What? Are you going. For?

Because then it gives you, like a right.

And then you can make it like. Oh, I forgot the exception. I don't even know how I do it.

It depends on how familiar. I think it's the thing. I think about everyone. But it's really.

New, I often do. Oh, well, you have another shift. Yeah I do. Yes. I'd really like to not go for a few weeks just to, like, feel the power that I have. Yeah. But we actually. Have a quick. One second. Whenever you're ready. Uh.

I'm kind of ready if I don't have to think too hard. You don't have to.

Talk with the auto grader every time you submit.

It. Do you get new tests like the tests that we can see? Are they new each time, or are they the same list of tests that we can see?

I don't want to make a promise about that. All right. Um, for two reasons. One, I don't want to give away too much because I want you to think about correctness and that sort of thing. But the other is I don't remember.

Sure.

Sure, because I just submitted it once.

I don't want to lie. Okay.

Sounds good.

Yeah. I would have to guess I. Yeah. So, uh, I don't know.

Okay. No problem. Thank you. I just figured I'd ask. Thank you.

No problem. You're welcome.

Uh.

Bad news, a separate display. Yeah, the.

I must now.

Go to my meeting in 12 minutes. I can do that. In here. Next.

Physiology.

Physiology. I think I asked that last time, but since I have no memory, let's make it a semester tradition. I'll just ask you every Monday and Wednesday. Physiology. That's fun. Yeah. I sat in on a physiology class for one that I didn't have time, but I regret that I didn't have time because I was really enjoying it while I was sitting in it.

I have to I have to like bio.

Which you.

Do. You do. But for me it's more interesting than cell bio because yeah, that's just.

Me.

My wife would think Cell Bio is the way to go.

Thank you. Thank you. Oh.

Okay. Okay.

All right. It's all yours.

UNKNOWN
Last week. But. This time?

Yeah.

I can tell by yourself.