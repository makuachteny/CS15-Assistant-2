 So I just heard you're doing graphs and discrete excellent time because we're going to talk about grass. So if you take a nap for these guys okay. Um. All right. Uh, so I hope everybody's doing well, I hope. Garth is cruising along and you're way ahead. So then you get a beautiful Thanksgiving break and you don't have to worry about it. But, um, if you, you know, if that's not true, then I'm sorry to hear it, but I hope it'll be okay in the end. Um. All right. Uh, so, um, I think this is our last data structure of the semester. Is it appropriate to be sentimental yet? I think we do that after Thanksgiving, when it's the when we panic because there are only two weeks left when we get back. Uh, happens to me every fall, I think. Oh, gosh, Thanksgiving halfway through the fall. And then you come back two weeks. Uh, that's the way it works. Good afternoon. Serious stuff. So today we're going to start our, our our last data structure. And it's, uh, it's a fun one. Um, today we're going to talk about two things. And then, uh oh, I forgot to put the third one. So we're going to talk about what a graph is. And if you're in 61 you kind of know but not everybody's in 61. So we'll talk about that. And then we'll talk about how we might represent graphs in our programs. And that's something I'm going to guess they don't spend much time on in 61. Um, and so we'll get up through we'll get up through that today. So we'll know why we want graphs, what they're good for, how we can store them in programs. And then after the break, we'll talk about how we can do traversals in graphs, which is kind of fun. Uh, right. So what's a graph? But, um, if you're, you know, a typical college student and someone says the word graph, you might think of this, um, this is not at all what we need, so I shouldn't have put it up. Maybe a big red line. It's not those things, right? That's not what we're talking about in CSS. A graph is the most general link structure, and we've seen several link structures already, right. We've seen linked lists which is the simplest link structure. Then we saw trees which are kind of generalization on lists. Right. So lists have this property that there's a there's a fixed order and there's sort of a distinguished front um of the list. And then they go element by element. Trees are a little more general because now instead of having just one next node, you can have any number of next nodes. But there's still kind of a distinguished root which takes the place of front. And so we're going to generalize that even further. Uh, to make a graph. So um, a graph is, like I said, the most general link structure. Um, here's the definition. It's a set of nodes and a the set of edges or arcs or connections or arrows between those nodes. That's kind of the whole definition, right? So it's as general as possible. Is there a distinguished first element? Uh, no. Is there given an element. Is there a distinguished next. Um, also, no, um, trees can't in a tree in a list. You're not supposed to point it yourself. Well, we have circular this, but in general, um, in in standard link data structures, we tend not to have cycles, um, circular lists accepted. And trees are what's known as a directed acyclic graph. That's the the subspecies of graph that represents trees. Um, but in a graph there are no rules. Any nodes point to any other. So a graph has a set of vertices which when we're writing programs, we think of his notes. And if you're a mathematician, you might call them, for instance, it doesn't matter. Um, it's the it's the, the things that, uh, these parts connect to. Um, and then we have a set of edges that connects the vertices, and you'll hear various names for those two arcs, um, edges, arrows, all of those. Um, and there are no rules about where the arrows can connect. So for example this is a graph. This is a graph. And so is this is this one graph. This could be one graph. There's no rule that says that a vertex or a node has to connect to any other node. So you can have that. That's fine. You can have a graph that that has the empty set of edges. And of course you can have an empty graph that has no vertices. Or it is it's hard to have edges if you don't have vertices, because edges, by definition go between vertices. Um, here's a here's a node that points to itself that's allowed. Um, one thing that the diagram doesn't show is you can even have multiple arrows between nodes. So, you know, there could be like 16 arrows going from this one to this one. No rules. Right?

It's hard to have edges if you don't have vertices. So that implies there's a way to do it. Is that like a special.

No. You can't um, you can't have a non-empty set of edges if the set of vertices is empty. Because because an edge by definition includes a pair of vertices, as we'll see. So I didn't mean so if I, if I, um, if I implied such a thing. Um, I'm happy to clarify. I did not mean to imply an assertion. So there's no particular structure, no roots, no children. None of this stuff. Um. Cycles. Sure you want to point it yourself? Go right ahead. Or do you want to get a bunch of nodes all to form a group that all pointed each other also? Cool. Um, you can even have vertices that are alone and out in the wilderness all by themselves. Also okay, to have directions, where can they point to both objects? A perfect question that I think is that the next slide, you're just about um, so we're going to so I'll just, uh, I'll tell you in advance, um, a graph where the arcs have a direction where we usually draw arrows is called a directed graph. Um, if the, um, a graph that, um, where there's not a particular ordering on the two nodes on an edge is called, um, an undirected graph, and you can think of an undirected graph as an edge between nodes, really representing two directed edges, 1 in 1 direction and one of the opposite. So when we get to representation, we can talk about that. That's an excellent question. And both of these types of graphs are useful. Um, and graphs are super useful. Or if you're taking 40in the spring. Okay. So I won't tell you which assignment. I'll tell you there's an assignment. And I was talking to the professor who originally wrote it. And so I'm just going to put this in your mind and you can see if it helps you. Um, I said, oh, I really love this assignment. It's a lot of fun. He laughed, and he said, do you know why I put that assignment in? I said, why? He said, I wanted to know if students could recognize a graph problem, if the problem didn't have the words node and vertex and arc in it. So there's a graph problem. It doesn't use any graph knowledge somewhere in the course. Um, but these come up a lot. And again an interview questions graph. Graph algorithms are very common, um, because they're useful for just crazy analysis. Um, have you guys ever used something like Google Maps or Apple Maps? Well, that's a graph, isn't it? Right? A one way street is a directed edge from one intersection to another. Right. So finding finding your way through a map is the same as a particular kind of graph traversal, where you start at one node, the one you're closest to, and you find your way to some other one. Right. That's a graph. And in fact they run graph algorithms. And we'll study some examples of those. Um, you can map social relationships. So Facebook friends right. You could have something like that. Uh of course the web the web is a graph. That's what it is, right? Hypertext is a graph where you have where the nodes are bits of content and the arcs are links, and we call them links. Right. So you can have different web pages that have links to each other. Right. The web is a, um. The web is a graph. You can have a computer that's not connected to the web. Okay. How do you get to that computer from anywhere else? You mean it isn't connected? But that doesn't mean it doesn't exist. It does exist. Um. The internet broadly construed, which is different from the web, the internet is, is a bunch of underlying technologies. The internet has tons of actual connections. And they they go through satellites, which are not shown here, but they're undersea cables that, uh, that go from one continent to the next with fiber optic cables. There's, oh my gosh, all kinds of, Crazy. Um, a friend of mine. Um, and he was a professor at another institution, and now he left to enter the corporate world. Um, but he took leave at one point, and I replaced him when he was on leave. And, uh, what was he doing? He was working with Google, and they were trying to figure out where to put data centers. And of course, they're thinking about how far away or all the customers from the data centers. How long does it take customers in these different places to reach the data centers, but also things like how much do data centers cost? How many trained people live there? Cooling turns out to be a big one, right? So it's really convenient to put data centers in the Arctic because then it makes cooling them easy, but then they're not very convenient for people to get to. Right. So he had this huge, complicated problem, part of which was a graph problem that he had to solve. Um, so when we're talking about edges, um, the edges can have direction or not. And if you're thinking about roadways, you can have a one way street or a two way street. If you have a two way street, then it's a it's an undirected edge. And or equivalently to opposite by direct directed edges. Um, but you can also label things by distance um, or by cost. So if you're scheduling a flight, uh, from Boston to Chicago, there might be a direct flight. There might not be, but you can bet that the costs are different, right? And so that's a graph problem where we so we have vertices we have edges. The edges can be either directed or not directed. And the edges can have information associated with them. Um and there's sort of two categories of information. One are what we call weights. We say weights um and the weights can be distanced. Time. Money. Usually when you say weight. There's a numerical component here or they can just be labels. You can think of the name of the road, right? For example, that would be a label on one of these arcs. Believe it or not, compilers used for apps all the time. They convert your program into, among many other things, um, a graph that represents blocks of code and the ability to transition from one block to another. And so compilers actually do optimizations where if there's information, uh, at one point and you can get to another block of code, if it can prove that there's information preserved across like a function call, it can do optimizations. This it's called flow analysis. Data flow analysis. Right. Represented as a graph. Uh, compilers associate registers with your With your program. There's a there's a thing called register coloring algorithms, which is sort of in this, uh, in this general area of computing. Um, so we've already seen that, uh, a graph can be directed or undirected. Uh, yeah. So I guess we've already talked about it, so we don't have to say more about it. Um, okay. So here's a directed graph. And that's, you know, if you have a web page and page A links to page B, there's no reciprocal relationship where B has to go back to A and you'll think, well, I just hit the back button. That's different from an arc in the graph. That's your browser remembering where you've been before. If I give you the two URLs separately, separate browsers, separate computers, separate history, and one has a link, you can click on the link and the other doesn't. There's no way to get back to the other page. Okay. So um, so the web is a collection of direct endings, but not all graphs. Um, have direct links. Sometimes they're undirected. All the links you can get back, if you go out through the door, you can come back through the door again. Not always, but sometimes in some applications that's true. So in addition to these two main defining things, the vertices and the edges, um, it turns out it's often useful to label edges. And you can put a weight on an edge. And that's something like, you know, how many miles we've already seen that example. Um, but you can also have an unweighted graph where you just have the edges. And another way to think of an unweighted graph is where all the weights are one or something, but they're all. There's no obvious if I've got two arcs. There's no obvious reason to choose one over the other except for the destination. And I mentioned labels, and you can think of those as street names or stuff like that. Okay. So that's kind of it. That's the definition of a graph. It's a it's a collection of vertices also called nodes and edges also called arcs and links. Um, and the edges may optionally be labeled with a numerical quantity, usually called a weight or some other arbitrary thing that we would then just call a label. And I think I've got this. I think that's the whole definition. Uh, now here is something cool. When we talk about graphs, we draw those pictures. Now, obviously you can't draw these pictures in the computer's memory, but, um, two graphs are defined by the things I just gave you. So somehow we have to represent the collection of vertices, the collection of edges, and the weights on the edges or the labels on the edges. But the way we write them on the screen doesn't matter. These are the same graph for equipment. They have the same set of nodes. They have the same edges. So if you've taken topology if there if there if there topologically equal then we'll say they're equal. That is you put them on the page in a way that works best for you to think about them. But the way you put them on the page isn't tied up in their identity. That makes sense. Are you are you looking at that, trying to figure out if there's a mistake and they're not really the same? Um, that's a good thing to do. And if you find one, please let me know. Uh, the intention is they're the same. Okay. So usually when we define graphs, we do so mathematically and we use concepts like sets. Uh, so um, and mathematicians, of course, as we know, are not computer scientists or software engineers. So they're very fond of one letter variable names and subscripts and all kinds of stuff like that. So they graph usually a graph that doesn't otherwise have a convenient name. It's called capital G. If you want to say, you know, I have a graph G, it's always just like prime numbers are always called p. Okay. So graphs are always called g. And what is a graph. A graph is a pair of two things. Two ones two sets. The vertex set. Traditionally B is a collection of vertices. And you can give these things names if you if you like. If it matters right. It could be um powder house square, teal square. Right. You can give them names. Um, but often when we're talking about the mathematically you just give them numbers and we say, okay, well there's a said and we'll, we'll just pick an arbitrary order and call this one vertex 123, four, five arbitrary ways of talking about it. So you have a set of vertices called whatever you like, but we can usually it's important that we can usually think of being able to enumerate them. So we'll often call them lowercase v one, lowercase v two. So v is is set little v is the is the vertex that particular vertex. And in the simplest case a collection of edges is a set capital E of pairs of vertices. And usually we think of the one on the left as being the from vertex. If it's directed and the one on the right is being the two vertex. If it's undirected, then the order doesn't matter, and we can talk about that when we choose our representations. Um, one thing I've left out of this is, uh, are the weights. And if we have weights, then we can turn this into a triple, um, vertex from vertex to weight, uh, from two. write. So you can you can do this. Turn them into triples. Yes. Should be a subset of that. Be a subset of what? Uh uh, no. The right hand expression doesn't mean all pairs of vertices. It's so I guess. Sure, he is a subset of it. If you think this is the power set, then the set of all pairs of vertices, then yes, he is a collection of this. Yeah. Okay. So I guess yes. But we usually say that the edge set equals a collection of things of that form. And it's a finite set. It's not and it's not. It doesn't include every pair of vertex of vertices. It's a subset. Um, usually it's a pretty sparse subset by the way. All right. So again if the if the graph is directed then we usually think that the source of the arc is on the left and the pointy end that the thing it points to is on the right, the vertex at points. If the graph is undirected, we sort of have two choices. One is we can just whenever we see xy, we just assume you can also go y to x. But we might explicitly in the edge set. But um, anytime anybody says I can get from X to Y, your implementation can also put a directed edge from y to x. It just works. So those are but that's how we're going to cover our bases. But those are the definitions. Everybody got it. So now here's an interesting thing. Um I used to have another game. Um, have any of you studied gaming? Do you know what a game tree is? Okay, so, um, one of you has, um, well, you can think of games as a, uh, often there's a concept of a game tree. You can also think of a game as a, as a kind of a graph where the transitions, the arcs are, represent kind of moves or actions within the game. So here's a, uh, here's sort of a practice question. Um, suppose I gave you a game and you have to win by two. So I guess volleyball is like this. Uh, um, tennis, I guess, is like this, right? You know, advantage. If it's tennis, you have to be quite average. Uh, okay. So in the end, one of the players can always win. So those are two different vertices because each vertex is going to represent the state of the game somehow. And so player one winning. Player two winning. Those are states of the game that at the end of the game we would like to see um the two players could be tied right currently tied, or player one could have an advantage or player two. So there's a, uh. Um, maybe I'll just pause for 15 seconds and have you think about it the way. So whenever you represent things with a graph, you're going to draw circles and lines for arrows. Right now, um, if you assume that, um, moves in the game are not undoable, um, then you'll have directed arcs, right? So you would just put a circle for each of these things, right? Player one wins. Player two wins. That's those are two vertices. There's a tie. That's a vertex. Um, player is a one point advantage. That's a vertex. So from this vertex how do I get to um where what other nodes can I get to from this? Advantage. Me. I'm up by one. Okay. And you're all playing against me. Okay, so we're in this game together, but I've got the advantage. What things could happen in the game? Yes. When you go to tie and or player one wins. Yeah. So if I score the next point we go to, we go to player one wins. If I'm won anyway, go to whatever player I represent wins. But if you guys score the point, then we go to tie, right. And you can actually draw it like this. So um, if we're tie and I score, then I have an advantage. And then if I score again, I win. Um, but if I have an advantage and player two scores, we're back to a tie. Uh, if we're tied and you guys score, then you have the advantage. And then if you score again, then you win. And if I score, then I win. Sorry. We're tied. Sorry, I was cheating. Could you call this a finite state machine? Um, maybe. Yeah. So, um, uh, when you take CS 170 or compilers, you'll learn about something or S4, you'll learn about something called finite state machines. Um, if you take it in S4, you'll call them finite state machines. If you do it in 170 or compilers, you'll call them finite automata. Every state. Yes. Yes. Okay. So, um, it's very common if you have a. Great. So I hope you can see that once you, you have this graph. And if you take for granted that you can represent it in the computer and manipulate it algorithmically. Um, then you can you can do things like you can say given two vertices A and B, find a path from A to B. This is another way of saying, given this state of playing a game. Is there a way to get from this state to I win or you win? Right. So you so game playing AIS. This is this is their bread and butter, right? The world is in this state and I don't want them to win. Ideally I win but but if I can't win at least they shouldn't either right. That's kind of a guiding gaming principle. And that's basically a search through this graph. Can I get can one get from this game state to the game state where the other person wins? But of course, another example of this is can I get from my house to Cousins Park? And the answer is it depends on the time of day. Uh, no, I can, um, now, if I can find a path, I might find the shortest Since. Uh, if the graph is weighted, I might want to find what we call the lowest cost value. The cost with minimal weight. If you're booking flights, then it may literally be the lowest cost. You want the lowest airfare. Um, but it could be other things. It could be carbon footprint. It could be fuel use, which is a proxy for carbon footprint. It could be any number of things. Um, it could be time. So, um, when you're a student, you just always go to the cheapest one and you say 24 hour layover in in Random City from, you know, 3 a.m. until whatever. Sure. I'll do it. I'll save $20 that way. But when you get older and you have kids, you say, you know what it's worth? $20 not to. Not to have your child crying bitterly for for seven hours in some places. Right? Um, so your trade offs change over time, but you can answer them all with refs. That's the cool. Well, you can represent you can answer all of many of these with graphs. Uh, okay. So um, hopefully now you know what a graph is. And I hope I've convinced you that you love them. You need them, and you can't live without them. In fact, you can't live without them, right? Right. I sometimes do this. Um, we drive with the GPS, like, on all the time. And sometimes, like, one of my kids will say, oh, take me to so-and-so's house. I'll say, okay, I'll turn the GPS off. And the number of times I get completely lost is shocking. I've driven this route 30 times, but I need to. But I haven't committed it to memory. Right? Um, if you know, in London, the London cabbies have the knowledge. Do you know this capital T capital K they. Um, I've been to London back when they had the knowledge. It was very impressive. Very impressive. Um. Okay. So we can either talk about brain scans of people who have detailed knowledge of London, or we can talk about how to represent graphs. And I'm going to go with the second one. Those MRIs are pretty tricky. Pretty interesting. All right. So, um, it's not hard to imagine how we would represent a vertex set, right? I don't think that's complicated. The edges are sort of the critical bit. Um. And so we're going to look at two different approaches to representing graphs, differing essentially, uh, and how they represent the edges because the the vertices are not too hard. You've got lots of options. You know, how to score a bunch of things and things are not complicated. You can have a list, you can have a set. Of vertices or It's the it's the edges that are sort of interesting. And we'll see that it has a big impact on the time and space requirements of the graph and your various algorithms. Um, okay. So suppose we have, uh, you know, it's Google Earth, and so we have cities on Earth, and each city will have a latitude and longitude. Um, and I kind of already gave away the store. Uh, one way to keep track of the vertices is you just have a vector or a list or a set you put them in. So, um, it can be convenient to iterate over them. And you might want to search them. Right. Because somebody might want to say, can I get from Boston to San Francisco? Right. So, um, but but you've got a lot of options to understand. Well, for example, you could make a vector that's not you. Um, Now notice, though, that we're representing the collection of vertices. There's not a distinguished first element in the list. There's not a distinguished root of the tree. I mean, there's a first element in the list. There's a root of a tree. But for a graph there's no particular thing. Um, finite automata do have a distinguished start state. So you have to define that automaton as a graph plus some other stuff. For those of you who have taken S4 and care about this. Um, okay, so how are we going to represent edges? Uh, all right. So we often use the word adjacency here because if one vertex is connected to another vertex we sometimes say we'll say they're adjacent. We'll sometimes actually use the word neighbor. How many neighbors does this node have. That is how many nodes can you get to from one arc? Can you get two via one arc from this vertex? Right. That would be the, uh, the the set of neighbors of that vertex. Um, okay. So we're going to we need to store information about adjacency. How are the um vertices related by the edges. Um, so if it's directed then, you know, we have to we have to keep track of that direction information. If it's weighted then we have to have weights. And I can think of a lot of ways to do this. You can what. We'll see. We'll see. One is um, and if they're weighted or labeled we have to store that. Okay. Um. All right. So, um, there are still a lot of design choices, but they're kind of two broad categories of choice about how you represent edges. One is you use an adjacency matrix, which is the name suggests is a matrix to, to the array, um, or you use an adjacent or you use adjacency lists. Um, and so let's, uh, let's look at each one. So in an adjacency matrix, uh, you make a, uh, order v by order v 2d array matrix. The vertical bars there, if you're not familiar with set theory, means, uh, size of often pronounced order. Order of V is the number of things in capital V, and so capital V is is the collection of vertices. So order v is the number of vertices in the graph. Um, since every vertex could potentially be the root of an arc, that's one dimension, but it could also be the target of an arc. That's another dimension in the in the in the 2D way. So we're going to do is we're going to make, um, we're going to make this 2D array. And we'll have to pick either the column is the from and the row is the two, or the row is the front and the column is the two. You just have to be consistent. Whatever you whatever you pick. Um, and so then we can say, um, the entry at subscript ij represents an edge or lack of edge from vertex ai to vertex j. Remember, this is why I said it's useful for us to have sort of a numbering on the vertices. And you just pick an arbitrary one. You don't come with numbers, right? So you just take all your cities and put them in a list and you say, well, wherever they are in the list, that's there. Those are the reasons. Okay. So we're just going to use the indices of the of this 2D table to represent, um, to, to represent a connection. So if vertex three is connected to vertex seven then in three seven there'll be information that says there's an edge here. And if all we care about is whether there's an edge. When boolean values suffice is the true means and false means, not an edge. I already said this. Um. Yeah. So I said that, you know, you can put them in a list and then use their position in the list. This is problematic. We can start to remove things. And so what I'm going to do is acknowledge its a problem and then ignore it afterwards. So we're not going to deal with it. Um, there are other things we can do and hash tables turn out to be sort of. I've used hash tables for a lot of graph things. Um, but okay, so that's on the table. Let's just understand what we're talking about first before we get into the things that make it. Um, in this diagram I'm going to use rows to mean the from the source vertex, the origin of the arrow and the um, and the destination, the sink, um, will be the columns. And for right now we just have. So this is an unweighted graph. There's either an edge or there isn't unlabeled unweighted. And so for this graph, which I think came from a former final exam, if I'm not mistaken, it's hard to tell that, um, a lot of graphs on the final exams looked like that, but then the arrows have a way of moving around, so it's hard to remember. Um, okay, so we just have a 2D table, and if we just assume that the the rows are the from the index. So this means vertex arrows starting at vertex two we'll go here. And if there's an arrow from 2 to 1 then this would be true. If there's an arrow from two to itself this would be we get the idea. So if we're looking at this graph um, how would we solve it. Well how would you write it. Well let's start with vertex one. So from one you can get to two and three. So two and three are true. And four, two, three and four true. All the rest are false because there's not an arc for one to the others. Everybody okay. So from two, where can you get two from vertex two. Who are the neighbors of two? Four and five. Uh, it looks like four and five. So in in row two, columns four and five should be true, and all the others should be false. And then row three. Where can you get two from three. So just six. Right. And then you get the idea you can fill out the table. So um, we go to like the notes that we want to the direct address and we just call it. That's the only one I could do. Um, the neighbors, the neighbors of a given node or a given vertex are the nodes you can reach in one step from that vertex following the arcs. So if they're directed arcs, only the outbound arrows. So if they're arrows coming in and that may you I may be your neighbor, but you may not be my neighbor in that sense. Right. Because if you could be my neighbor, if I've got an arc to you, but if you don't reciprocate, then then you understand. Does that make sense? If they're undirected, then it doesn't matter. If there's an arc between the two, then there's an arc. Okay. Is this is this lost track?

Because I'm noticing there's no way to get back to any node previously visited. But there are like because since it's directed, they're all pointing eventually towards things. But.

Uh, you may be right. So, um. Yeah, I think you may be right. This may be a second.

Okay, so that would be considered a cyclic, even the like, if you look at it, you know, there's like shape or something. Yeah.

The the layout on the screen does not matter about any of these properties. Hopefully you pick a layout that's helpful for thinking about whatever you care about. Um, this one is interesting because for six, once you're there, by the way, I'm convinced there's an intersection in downtown Boston that's like that. There's all these one way streets coming in and no streets going there. And I think just every night they just bulldoze all the cars and and. I know it must be. I've never been, obviously, because I'm, I'm not underwater. But that's this is why I, I believe it's there. It's like Brigadoon. Not like it's. Anyway, um, you can see. So since there's nowhere to get anywhere from six. All right. Um, okay. So, um, if we have labeled or weighted edges, then what we need to do is we can put the labels or the weight in the table. Yes. Um.

Just synonymous or. Yes. So.

Okay. Yeah. So arcs and edges mean the same thing. And sometimes we say links and there's a bunch of names, but they all mean the same thing. So, um, an arc and edge say, uh. Uh, so we can store label information if there are labels and we can store weight information if there are weights. Um, if you do that, you have to be careful, because if there's not an arc from one node to another, what are you going to put there? It has to be the same data type as whatever else you do. Because in C plus plus, all the types in the table have to be the same, right? You can't. If they're integers, they all have to be integers. If they're floating point numbers, they have to be floating point numbers. are strings. They all have to be strings, right? So for example, if we have a label graph, maybe we could say the empty string means there's not actually an arc from A to B or no. But what if the empty string is a valid label and I can't use that? It's something else. Um, you might actually put the weights in a separate thing. You could imagine having a hash table that maps pairs of. And I've done this actually pairs of vertices to weights.

So if you have something like a.

Cost or something where the cost of a get, you know, could be any integer, like it could be positive or zero or negative, and there's not one integer where you can be like, okay, it's never going to be this integer like.

That. What would you do? So you said you say they're of type int. And it turns out that any value of type int could in fact be a valid weight. What do you do.

For an audience? Maybe a character.

Um, they have two in C plus. Plus they also be the same type. So they're all ins. And the char actually is a small int. So they're a little you could have a parallel boolean matrix. Right. So you could have the original matrix that just says true or false if there's an edge or not. And then a separate thing for the weights you could do that. Yeah. Okay. Is there a reason not to use zero. Because zero might be a legitimate weight. But if you have zero as a legitimate way, I guess depending on what your graph is representing, as long as zero is preventing things from being, say, transported along that edge. Um, so so you have to make a choice that's application specific. And if if zero legitimately means there's effectively not an edge, then you can use it. But if it doesn't mean that, then you have to do something else. But you can do this. Something else we did with hash tables, right? When we wanted to know if a slot in the array was in use or not. We just put a struct in there with a boolean field that said I'm used. And then and if and if I'm in use was false, we agreed that we wouldn't look at the rest of it. So this is you have to program. Um, this is a property of sensibles. Very important. Um, it usually comes up in 11. Um, whether explicitly or not, it definitely comes up in, you know, 15. We've seen it with hash tables and it comes up in in 40 as well. There are there are times when, when do I get to the end of the list? Well, it has to be something that can't be a legitimate value in the list, right? And if you don't have such a thing, then you have to add a make a struct with another thing and you have to do something.

UNKNOWN
There is no way. Or it hasn't happened.

Potentially, yes. And I can think of, uh. Uh, well, so there's the obvious one where you have to do the index computation twice. That's usually not very significant, though. Um, the other problem has to do with cache friendliness. So it's probably cache friendlier to put them in one place. But then there are other higher order issues having to do with relative sizes and how they pack. And so, um, the whenever you, um, asking about performance is really important because in the real world, performance matters. Um, on the other hand, there's often not a clean answer. You mostly have to you make you make your best guess, you implement it, you time it, and if it doesn't work, you fix it. That's kind of how it goes. Um, so great question. Um, if we assume that we had numeric weights that were non non-negative, then we could use minus one to mean there's there's not an arc. And then the table would look like this. I just want you to notice something. What's the most common value in this matrix. We get a sense minus one right. And in the previous one the most common one was false. Right? Most graphs are relatively sparse. A complete graph would have all these squared arcs, right. There'd be at least one arc from. It could be worse than v squared because you can have like 16 arcs from each vertex to every other vertex. But usually we just think, okay, if there's one arc from each vertex to every other vertex, then there are v squared edges. Um, and of course in an order V by order V table. Then there are in this case 49. There are v squared slots. Right. Okay. Um, but mostly it's sparse. So that's sort of an interesting. Um, let's think about undirected graph for a minute because, uh, it's interesting if we use just so there are no way. So we just use true and false. What do we know about the matrix that's going to come out of this? Mathematicians, data science people I study machine learning. It's kind of going to be like mirrored at a diagonal like the matrix. Yeah. Right. So like the upper right and the lower left are going to be sort of mirrors of each other. Yes, that's exactly right. Because if there's a if there's an arc from A to B, then there's an arc part for me today. Right. Um, so we say in that case that the matrix is symmetric and it will be symmetric across the diagonal that you just mentioned. Um, and so you could in fact save half the space by representing it as a triangular matrix. The thing to keep in mind if you do that though, then you don't want to segfault because you access the elements you don't have. So we have to be really talking about how you represent a triangular matrix, but you have to be careful about that. Um, but one way to do this is to have a canonical order of vertices. So if somebody gives you is there an arc from vertex two to vertex nine, sorry, vertex nine to vertex two, you just you just do the lower numbered one first. Right. That would be one way to to pull this off is then you don't have to look in the, in the other part of the triangle. You just look in the part that maps. Lower numbered vertex to higher numbers, or higher or equal other places. Um, I don't know if it's obvious to you that this is, uh, this is symmetrical, but it is. Um, and because you can say 50% of the space there are implementations will do that because 49 is not very many slots, but 49 million is. And so if you could cut your space in half, um, that can sometimes matter. How would you.

Cut your space in half? Because you're, you know, it's a 2D array. So it, you know, you declare it as like seven by seven, you can't be like, well, the first one's won the second one.

Yeah. You'd have to use a different. You couldn't just use a straightforward 2D array. You'd have to pick up something else. Yeah. It's because you're right. You can't just, uh, you can't just go into memory. I saw part of it. Part of the thing. You're absolutely right. Okay. Um. What do you think? Pretty fast. Right? All you got to do is calculate the indices if you know the vertex numbers. So I'm assuming we're not searching for the vertex numbers. If someone just says from from 2 to 349. But given the two indices you can calculate where memories of things and you know, it's it's just multiplications and additions. It's not a of constant value. So it's it's fast. It's fast because just like looking things up I mean 2D arrays require more multiplications than additions but still pretty fast like indexing arrays as fast. So we like that. That's good. Um. But the space complexity may be a little less keen. Assuming we're allowing us to complete the order of the square. Yeah. So in this one, you have to store information for every pair of nodes. Even if that information is, there's nothing here. Right. So all v squared possibilities are here. If you did have an efficient triangular matrix representation it's still v squared over two which is still v squared. It's a little bit more squared over two. But we don't want to do that. Um okay. So um this can be problematic. So um v squared can be a lot of space. Now if you actually have pi connectivity in the graph, it may there may be no other choice if it's really true that there are arcs between most pairs of nodes. Then it's kind of going to be v squared, whatever you do, because you have to store information for each arc that exists. But as I tried to mention before, most graphs are not very, uh, are not very dense. And if you think about a map, right, um, there's no way to get, you know, from Powerhouse Square to I'm trying to think of a place downtown. So like Logan Airport in one step. Most nodes in the graph are not connected. They don't have an arc, right? You just have small local connections. And in a case like that, you're wasting a lot of space. And it's something like a map of the Boston metropolitan area. I forget even the world. That can mean a lot. Um. If you want to do something like, uh. Okay. A lot of graph algorithms will say for every edge in the graph. Well, if you want for every edge in the graph, you've got to look at all these squared things. So just enumerating the edges is a v squared option. Even if there's a tiny number of edges relative to v squared. And so that hurt us. Um. So it's bad for sparse graphs. And sparse graphs are normal. Fully connected graphs are actually more rare than in my experience. Right. There's not there's not a deep sea cable that connects everybody's home to every other home. And there's a relatively small number of deep sea cables compared to all of the computers that might be connected by these things. So, um, sparse graphs are actually the norm. Um, sparse means that there is significantly less than than order v squared adjacent. Um, on the plus side and this is particularly important now um, on the plus side you can, you can, you can often do searches of a graph using matrix manipulation. So you take linear algebra. And then it turns out that a lot of the algorithms that we that we want to do can be recast as matrix problems on the adjacency matrix. And this turns out to be really good because you can use GPUs to solve this. And the modern AI revolution has made matrix operations and um, a very well supported feature of hardware, even ordinary laptops. Right. I've got an M1 Mac. So that one, it's got all sorts of AI stuff. And when they say AI, they really mean linear algebra. That's kind of what they mean. Um, so and so this is a famous algorithm for finding shortest paths that just says, oh, well, we're going to do these. These matrix multiplications and we're going to do blah blah, blah, blah, blah, blah, blah, blah. Now we know the shortest path and, um, um, you're brilliant, they're insightful and they're well supported on modern hardware at the cost of space. Um, so it's not a clean trade. It's not a trade off. Unless, of course, the space doesn't even fit in your memory. Then it's a clean trade off. You have to pick something else. What? Something else would we pick? Well, we pick an adjacency list. Um, and an adjacency list is what it sounds like for each vertex, you store a list of its neighbors. For example, from one, we can get to two, three, and four. From two we can get to four and five. And so on. Four six. Six. I think nobody ever returns from six. Now, the advantage of this over the adjacency matrix is you only have to store information for edges that exist, not for edges that don't exist. And if a matrix is very sparse huge huge advantage. Um. It's very common in graph representations to have vertices represented by a node struct. And instead of having a separate data structure for the way I just showed on the previous slide, um, it's pretty common that, um, you know, you would have, um, v dot neighbors would be a list of the nodes that this node is connected to. And so that's a very common. And that's convenient if you're searching a graph because you look at a node and you say, oh, you're not the thing I'm looking for. But let's see, where are your neighbors? And you've got one over here, one over here. And I said, okay, I'll remember you, and I'll go and search over here now. And uh oh, you're you're not the thing I'm looking for either. But what are your neighbors? Right. So that approach is, um, very widely used because a lot of search algorithms, it makes a lot of search algorithms easy to run. Oh, last slide where it doesn't have any edges with it. Uh, so how would that be represented? Well, it'd just be represented with a pointer or, well, an empty list, however you represent empty lists. Okay. Um, yeah. Once again, the reason the null pointer works for lists is if you believe a, a list is represented by the address of a node. You know the null pointer can't be the address of a node, because the definition of null pointer is not the address of any actual value. But that's its official definition. So um, so if you're using null pointers to represent emptiness, then yes, absolutely. But if it's a vector you're not using linked lists then it would be the an empty vector. Does that make sense. So use however you represent emptiness for your list structure. That's what you use.

UNKNOWN
So that's good.

Uh, right. So we can store the, um, you got. So you guys have been programing for a while. You can sort of imagine all kinds of things here. If you've got weighted edges, you can have a hash table that maps edge number two, um, weight or label information, or you can store in your adjacency list. Each edge is represented by a struct that has a label or weight or, you know, um, you know, a price, um, an equipment. So is it a, is it a Boeing 777 or, you know, whatever is there. You can put any, any small matter of anything you want to keep track of related to the edge. You can make a struct and put all that stuff. Um, okay. So space complexity, we like this because there's edge information proportional to the number of edges. So there's a order E right the size of E, but there's a little bit more because we have to have sort of a list, but a list head or a vector or something for each vector. That's right. I'm thinking of putting it in a vector for each vertex. Um, so this turns out to be. The plus size of the plus size. Or if you like, there's a spine that size of V. And then for each V there's um zero or more edges. And if you sum up all of the neighbors of all of the vertices, you get order e things because we're only scoring stuff when they're. Making sense. And again, if you have a sparse graph which is very common, um, this is a much more space efficient route. Of course, it's not amenable to all of the modern AI hardware, um, because you can't really use linear algebra. So if, if that would give you an advantage, that's something you want to consider? Um. How long does it take to iterate over all the edges? For each little e in between. Uh, like.

A need that you can just go through the lens, or that's if you have them. If it's different, if you have one unit separate. If you have the edges in their own thing, you can just go to that one.

Um, you're thinking of it, right? The thing is that to get to all the edges, we have to go through all the vertices. They're they're stored in the vertices, or they're stored in a separate data structure that has an entry per vertex. So any way you look at it, you've got to do order of v peaks for edges. And then um, for each one you have order of number of neighbors. But you know, that order of number of neighbors for vertex one plus a number of neighbors for vertex two plus blah, blah, blah, blah.

Blah, blah, blah.

Blah blah. Do some order. Eat again. So space. Big win. Um, and actually the time for iterating over edges. Now if you have if your application doesn't iterate over edges, this may not sway you very much. But if it does, and if you have another question.

It's just couldn't you to get it to order you? Couldn't you make the list of edges like an edge contains like a from an to two or something. So then it's just one less, you know, all the edges, you know? And if you look at an edge, it'll say.

You could have sort of another data member in your graph. That's your edge list. I guess you could do that. Um, and then it would be order e if you had such a data structure. That's true. Excellent. I like that you're thinking of these cool representation hacks. That's good. Um. Okay, so what do we think? Um, wouldn't it be, like order number of neighbors of, um. Vertice? Yes. And, um. And what's the worst case number of neighbors that will be? Because you already, you already know one one side of the of the arc, right? So, yeah. Um, but yeah, you got it exactly right. It's proportional to the number of neighbors. You could you can hopefully in constant time, get to the, uh, if somebody gives you vertex of ten, you can get to vertex ten. And we hope so. There's a if there's a vector involved and then that energy is lost. Um, but once you get there you have this list of neighbors. And so then it's, as you said, it's order number of neighbors. Um, and in the worst case, that that node is connected to every other in the graph. And so, um, there can be order v and again, it can be worse if you can have multiple arcs between, we're going to generally assume that there are either 0 or 1 arcs between the pair of nodes, um, in a given direction. Um. So, um, we could store things in a binary search tree based on vertex number. And so then if you know that you want to get to vertex 399, you go through the neighbors. And so you could do that, um, you could use a hash table. Because I've done that a lot in Python. In Python it's really easy to use that table for like, everything. Um, and then the default, you constant or constant is done. Um, how am I doing? Actually, I'm running ahead a little bit. Did I talk quickly? Was I one of those things where I was checking it twice the speed? Um, okay. Well, one A and B sort of rely crucially on on v squared. What's v squared. 10,000 times 10,000. Yeah. So that's 100 million. So so so V squared is 100 million. Well, 20,000. That's like nothing to the sea. That's a very sparse man. But you can see why, um, you know, don't rely on your intuition calculation. Right. Because somebody says 20,000 edges. 20,000. My God, that's a lot of edges. Yeah, but there are 100 million possible edges. So now 20,000 doesn't seem so big. Um, now 50,000. That's that's halfway connected. 50 million. Sorry. 50. Thank you. 50 million. Well, now half of the 100 million are done, right? So, um, in the first one, uh, an adjacency matrix would be a huge waste of network, right? So that would just be huge. But in the second one, not so bad. So. Uh. I sort of. What is this? Um. Well, actually, this one I kind of want to do. this. This is good practice. Um, and it's the sort of thing I could ask on an exam. I can give you one representation of a graph and ask you to come up with a different. Right, so I could show you the adjacency matrix and then you draw the picture. And this one we started with the picture and said yeah I do everything else. And so here's everything else based on what we have so far. Okay. That's actually all I got today. So just pause quickly. Any any questions. We do have lab tomorrow because Thanksgiving holiday doesn't start until Wednesday. And the and the topic is hash tables very relevant to Earth. So go to lab and then have a wonderful Thanksgiving. I'll see you next week. Travel safely. Or if you're not traveling to stay here today. Oh. Yeah. I. Quit. Oh. This is a really great question. Um. Your memory is a great. Place to put whatever. You're thinking. About. I. Have I done? Something. That's not what I want to. Know. So I've already got this back in global memory. They're all in the assembly. They're just within the runtime program.

They're different usage.

Strategies. And the distinction is like when when are the data allocated to global is allocated. Hey, let. Me say that I want to. Look at that one. I can't see it. Why not. Because on block entry we were allocated in our block entry. And that's where we can start using these. And when they're on the heap, they call that indefinite extent. Basically we have no it's when when the program says to allocate the allocated and when it says to free. Okay. So all of that is within the computer's memory. And it's just different ways of using of using the knowledge. Yeah. According to hash tables do I have control for certain I can use a vector.

Does it concoct something different or is there like.

I'm I know I'm I think creativity is encouraged, but those are the obvious answers. Yeah. Okay.

UNKNOWN
I'm just thinking, like, reflexes is a little weird.

It's true. And, um, whether that's significant overhead depends very much on the application. Right. So if you're storing huge amounts of data, I will say I want to underline something that's in the spec, which is that the largest data set we give you can definitely all be stored in memory one time Probably two, but definitely not like six. So. So you need to you need to think carefully about how often you store stuff. Yeah. Okay. Um, and and you should also. When we first came to the time that we didn't give a lot of context. So there may be more available now in the spec. I'm struggling to remember if this comes up. Um, if you're thinking of using pointers for things rather than things and solves this, remember how that was in strings? Okay, because they're all array lists, which means they can expand and shrink. And that is implications for the stability of pointers. Okay. Okay. So that's a that's a hint. Oh is it okay. I couldn't remember if that was in the scope, but it really should be because the first time we gave this assignment.

Oh, yeah.

Oh, yeah.

Um, I just have a question that I think one of the teachers mentioned last week that there's a zoom component for traveling to the facility.

Yes there is. I wish you'd ask that before everybody that. Sorry, I forgot about it, but you're absolutely right. Oh, did you know because, um, I think we we announced on Piazza, but it wouldn't hurt.

To post it. Yeah. Okay.

Because a lot of people will be interested later tonight. Okay. Yeah. Yeah. You two. Have got to get. Oh, this is good. I won't be late for my meeting for once.

UNKNOWN
And since it's with the camera.

All right.

What's going on?