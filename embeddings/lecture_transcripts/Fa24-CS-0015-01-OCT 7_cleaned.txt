All right. We have three things to do today. Um, and they're sort of. One of them is merged in the slide deck. So we're going to do a little bit of project two. Um, prep. Um, it's, uh, um, it's fun. It's it's a lot of fun. Um, so we're going to do some project two prep in particular. We're going to talk about something called RPN. Reverse Polish notation. How many of you have heard of that? Does anybody heard of that? Okay, so a couple of people heard, um, the rest of you will have heard of it in a few minutes. Um, so we're going to do that, and then we're going to have a little bit of an aside on something called finite maps, which are terribly useful. And then we're going to start with binary trees. I think I mentioned last time, um, we were going to do trees. And so we do general trees, then binary trees, then binary search tree. There's going to be a whole sort of tree section of the course coming up. So we're going to continue that. So three things. Um project two prep um finite maps, binary trees I almost said binary search trees, but not yet. That's next. That's coming up. Uh okay. So um, if you haven't had a chance to look at it yet and, uh, it just came out today. So I imagine most of you haven't looked at it yet. Project two is going to be an RPN calculator. This is an example from the late 60s. Um, this thing could do basic calculations and cost $5,000. In 1968 I looked yesterday, I think it was $47,000 today. This little calculator thing, just to give you a sense of, you know, this is much, much cheaper and much, much, much, much, much, much more powerful. This is more powerful than supercomputers of the day. And here, this thing, um, but it was still pretty cool machine. Anyway, um, okay, so we're going to talk about RPN, which is short for reverse Polish notation and get you bootstrapped a little bit about for project two. Um, be sure to review the material on stacks, because stacks feature prominently in the assignment, as we'll see today. Um, and, um, maybe we'll talk a bit about parenthesis expressions today too. We'll get oh, I'm not going to talk about exceptions I meant to remove. I can remove that. Um, you've already seen stuff on exceptions. Oh, no, it just says to review it. Yeah, you can review it. Stuff on exceptions. I'm not going to do that today. Okay. So, um, you guys are familiar with things like this? What does that mean? Or how would we evaluate it? Yeah. So there's this thing called Pemdas. You may have heard of, uh, parentheses and parentheses. Exponentiation, multiplication, Division. Um, addition. Subtraction. Right. So basic order of operations then. Um, if you just looked at this and you didn't know about Pemdas, you'd say, well, this is do I just evaluate left to right And the trend is the fact that we have a whole mnemonic for it suggests no. Um, so we could put parentheses in. Now the first one, um, the multiplication would have to happen first. Right. So the three times four and then 12 divided by two six and then six times nine. And then we can do the others. So that would be the Pemdas version. Um, if we parentheses it and um, this is kind of okay. So we could do something like that. Right. And then you would do them, you know, this things first and then that one and then that one, and then you multiply and then you give the subtraction. And even with Pemdas, I guess it says, um, addition and subtraction. But that's not actually the rule, is it? Is it. I don't think so. Right. And in C plus plus it's not the rule either. So if I have a minus b plus C, does the addition happen first or the subtraction happen first? Subtraction. So multiplication and division are what we say at the same level of priority right. So they just happen left to right in the order they're written. And you do all the times and divisions. And then addition and subtraction have the same level of precedence. That was the word I was searching for have the same precedence. And so they're just done left to right as well. Okay. So you guys have seen you've already told me about Pemdas and you could say there's ambiguity, but we just say left to right in these two in these two cases because they're given the same level of precedence. Okay. The notation that you're used to using is called infix. So you say a times b and you put the time symbol between a and B right. Um, that's called infix notation. And there's nothing magical. It's not a property of the universe. It's an arbitrary choice that somebody made that we say A plus B, right. It's just an arbitrary choice. Um, we say that an operator that requires two operands is a binary operator. So, you know, a so the plus operates on A and B a plus B takes two things. Binary operator. There are unary operators. There's a unary minus which just takes the you know. So minus sign x is you just flip the sign of x right. So that would be. So minus can be both a binary and a unary operator in C plus plus we're going to ignore that issue today. We're just going to deal with binary operators today. And we'll put it aside and say well we can deal with unary some other way. Mumble mumble mumble hand-waving, pay no attention. Um, but the interesting thing about infix is that if you if you have infix, you have to introduce parentheses and or something like Pemdas. You you it leads you inevitably there. And that's sort of an interesting note. Um, and so are there other choices and would those other choices be better in some way? Um, now if, if, if the some way that they would need to be better is that you would find them more intuitive than. Of course, no, because you've been doing infix since. Right. Since you're about three months old and they started using calculus. Um, so so you're used to that one. But the other ones are not worse because you're not used to them. Okay. So we don't accept that answer. Uh, and if you've got three things and you have to put them in some order on a piece of paper, there's sort of three logical orders you might pick. Right. You put the you put the sign, sorry. You put the operator between the operands. You put the operator first, you say, I'd like to, plus some things and then you put the operands after. This is what the Lisp programing language does. This um, you can do what's called postfix. So that's prefix because the operator prefixes the operands. This is called postfix because the operator postfix comes after um host after it comes after the operators. This is used in certain programing languages. There's one called uh postscript which famously runs on a printer. So a lot of a lot of your printers that you use actually speak this language. You don't actually load a bitmap on it and have it print it. You load a program that the thing runs, and when it runs, it causes the pages to print. Really powerful idea. Um, okay. So what's interesting is these can be ambiguity free. If you know that the operators are binary. Right? So then, um, actually there's still ambiguity. So you don't need any special rules. You don't need parentheses, you don't need anything and question. Wouldn't there be.

I mean maybe not for plus but like for divide there would be ambiguity.

Yes. Perfect question. Um, yes. So uh, so sometimes the order of the operands matters and we are going to have to address that. So you're right we haven't solved that problem. Um, but we'll come to it. Okay. Um, so a Polish math logician. Um, let's see, Yanukovich is my best attempt. Um, and forgive me for anyone who speaks Polish, um, invented, you know, sort of invented this one or popularized it or investigated it very carefully. And because a lot of the people outside of Poland wanted a simpler name, they just called it Polish notation. Yeah. That Polish logician. That that notation. This one is reverse Polish notation. And so that's the so this is what you're going to do in your in your calculator. So pop quiz.

UNKNOWN
What do we think.

I hear a 44 and then yeah it is 44 I agree. Can you. Okay. So I'm so I have two votes for 44. Um how many people say 44. Okay. Fair number. How many say not 44. You've seen a lot of abstentions, and I'm seeing some disagreement. Um, and of course, the way your calculator will work is it will take a poll of everyone in the room, and that will. No, that's not how we're going to reduce. So the way it works is you go operand operand, operand operator operator works on the last two operands. So five six plus five six plus is 11. Okay. So then so now the. So now you have 411 times two times works on the previous things four and 1144. Okay. So I think I said all this. But let me just see. Uh yeah. So a key thing is that when you. So the operator applies to the last whenever. So you just go left to right. And when you get to an operator, it applies to the last two things. But the result of working on that operator now becomes the last thing. Is this sounding kind of sticky already? The most recent two things will be operated on. Oh, how do we keep track of a bunch of things with easy access to the most recent ones? Okay. Sounds sticky to me. Okay. Um, and and then you take. So you're going to you're going to go pop pop, operate, push pop pop operate, push pop pop operate. Okay, well, now I can just skip the whole slide. That's kind of the answer. Um, okay, so if you think of 11 is replacing five and six now, four and 11 are the last two things on the stack that that aren't an operator. And, you know, here's a more complicated one. You have to be able to do this because you have to know whether your project is correct or not, which is hard to do if you don't know the answer yourself. Now let's work through it. Five two star. The star applies to five and two, right? So that becomes ten. So we have ten, three plus 13, 13, 13, 13, seven plus one one. Okay, so I've given away the store. It's an it's a stack. Um, okay, so here's the algorithm, and I'll just put the whole thing. Um, you just read things one at a time. If it's not an operator, you push it on the stack. If it is an operator, pop, pop, operate, push. Um, when there's no more input, then the thing on the top of the stack is your answer.

An additional bit of ambiguity I'm seeing in this. I mean, obviously it seems like they've picked, but like it isn't it ambiguous whether the like you start so like five and six or the last two? So isn't it ambiguous whether you start with the plus or, you know, the first operation or the last?

Uh, so, uh, no, the way we're going to work is you're going to proceed left to right, and you don't push operators on the stack in this version that we have now. You push operands on the stack. So when you get to an operator now, it applies to whatever the current top two elements of the stack. Um, so that's an important question. And you'll see that your project is much more flexible than this. But we'll get you started. Um, so let's let's look at an example and maybe just carry out the algorithm. So, uh, push a six, push a five, push it two, push a three. You push anything. That's not enough. Okay, now we get to enough. So what do we do now? Pop. Pop. And then we perform the operation. Three plus two is five. And push that on the stack. Everybody okay? And so now we just keep going. So what's that that gets you know it's not an operator, it's an operand, so it gets pushed. What's that? It's an operator. So we do the same thing again. We do pop. Pop. Um, we calculate the result eight times five is 40. Um, push that on the stack. And you keep going like this. So now, um, we pop 40 and five, they get grayed out. Um, and what are we doing? We're pressing them, so we should get 45. And then 45 replaces those two elements on the static. And now we push a 345 and three is 48. And then there's a times. And you may not have this in your head. So 288. That's two to the fourth times three. And that's of course two times three. So two to the fifth times three squared is another way to think that that's helpful Okay. Um. All right, so I haven't carried it out. We have to. We have to finish ending. We have to finish reading the input. And when we do, the thing left on the stack is 288. There's more than one thing. I don't know what that means. We can maybe talk about that later. Okay. So everybody all right with the basic operation, this is how you do calculations and life is cool. Uh. No question about the order for, for. So, um, plus and minus are commutative. We say right. Doesn't matter what order you, you know, which ones first and which ones second. Doesn't matter. Right. That's what commutative means. You mean plus and multiply. What did I say? Plus and minus. Yeah, that would be wrong. Yeah. Plus the multiplier. Thank you, thank you. Um, yeah. So, uh, plus and times are commutative. Thank you. And, uh, but the other ones are the order matters, and we have to decide which is the numerator and which is the denominator, which is the what are the two names. So there's their add ins. And then. I don't know the subterfuge. No that's not something. Anyway, the um the two things that you subtract have an order. Um, and so here's what we do. Whatever system you're using picks an order. And the order is specified as either, you know, the earlier thing on the stack is the first one or the top is the first one. And I've seen that work both ways. Actually, um, the one that you're going to do, uh, is going to use this the, the convention that the deeper item on the stack is the first operator. Or another way to think about it is if you want to divide things, you push the numerator first, then you push the denominator and then you, and then you say slash and then it pops denominator pop numerator numerator divided by denominator and pushes that. And same thing for subtract. The one on the left of the minus sign is going to be. The deeper or the deeper one is the one that was pushed first. So for example for six push two. Okay, now the fun part. We pop two things. We pop the first, we pop the second one. And now they're numbered this way because the deeper one is sort of operand. One is kind of the the numbering is starting to show. So now the result is the second thing we pop, which was the first thing whoever called us pushed. Right. So you see this is just a fact of life with stacks is that, you know, the person putting them on season one order. The person taking them off sees them in the reverse order. All right. So. So then we do the deeper thing divided by the shallower thing. And we get three. Okay. And so the answer is three. And that gets pushed down this way. Okay. So here's an exercise. Maybe I'll just pause for about 10s. Push three. Push for push two slash. What does the numerator. Force the numbers. This becomes four divided by two. So we push two. So now we have 325 times. Um two times five is ten. Um. And then now I've already forgotten the Already forgotten. Just as the answer. So okay, so let's see if I can draw this. This would be really useful. So if we have three we have two and we have 325 times okay. So we have three we have ten then we have 13 okay. So now we have 13 on the stack. Then we're going to push nine and two. Multiply those we get 18. So now we have what did we say ten and 18 1313 and 15 and 18 and then three slash. So 18 divided by three is six. And if I did that right the answer should be set. You're welcome to check. Okay. Um now once people learn this, they find it's unfamiliar. And then they think that will unfamiliar definitely means worse. And, um, And like I said, it doesn't necessarily it could be better in some ways, worse in some ways. Um. This turns out to be really useful. And in fact, many early calculators did this specifically because they didn't want to have to deal with parentheses and having calculators remember things. It was much easier to just have a stack based execution model. And Hewlett-Packard has, uh, um, notoriously has famously, uh, done really well with this. They have a whole series of RPN calculators that they, that they launched, including including this one here. Um, so 45,300 almost. It was 45,299 31 or something. When I looked at f yesterday. Um, it doesn't matter. The point is you could buy a car or two for the price of this thing. Um, if you if you log into the servers, there's a program called DC which stands for desk calculator. And you can and it works this way. You can use it. There's another one called VC which stands for the calculator. I don't remember what the V stands for. Um, but you'll use DC, and we modeled, uh, many of our instructions on DC. When we design the assignment. Okay. So it's a real thing. People have used it at industrial scale. Um, you know, when I was in high school, in an undergrad, many people had RPN calculators that they carried. It was just it was normal. Um, and so now you're going to get to do it. Um, okay. I don't want to talk about this next thing. This is a jiffy. You guys know what jiffy stands for, right? I got this from a friend of mine. Just for fun, exercise. The.

Uh, question about, like, binary operators in a postfix. Would it be, like, if if it runs into a binary operator, it'll will do the same thing except only like the first.

You mean a unary?

Unary? Sorry.

Yes. Right. So unary operators just pop the top thing on the stack and apply their. Okay. And then you need a way to distinguish. So part of the problem is in math they use this minus sign to mean both unary and binary. So I think DC uses tilde for okay. So they just pick another one and say okay the unary minus is not. Is negation and it's spelled tilde or something. They just pick is it underscore. Oh okay. I thought it was. Could you not just like put the minus right before the character and then just send in the input as a negative. Well, so, um. You could, you could change your parsing algorithm so that you change the number. The issue is that minus has to be able to work on the results of computations. Right. So you have to be able to do like, you know, star slash minus and and now you have to know which one that is. Um so for for integer constants you could absolutely do that. But for more general computations you need you still need a way to distinguish. Okay. And uh, um, there's a fun stack based thing that was developed by Edgar Dijkstra. And we'll see later in the term in a completely different context. Um, and you can use a stack to take expressions that are infix with parentheses and then produce an RPN version of the same expression. There's an automatic way to convert between the two.

UNKNOWN
It's pretty neat. Um.

All right. So how is this relevant to you? Well, this is a part this is a this is a part of what you're going to do for the project. Uh, you're going to have more than just numerical stuff. So you're going to have booleans and logical operations, you're going to be able to store an expression. So you'll be able to take like, you know, minus slash three, four times plus, and you'll be able to take that whole thing and push that on the stack and then pull it off and execute it later. It's like a function. Right. So you're going to get that. You're going to have conditional statements where you you push a test and then and so now you can use those function like things and you can say push the push the then part of an if push the part I'm blanking on which order we do it in, push the test that has come in some order that the spec says. And then you if the test is true, then you execute you. You pop the two off, you throw away the one you're not using, and then you execute the one depending on whether the test was true or false. So you'll get conditionals. Do you see where this is going. And there's an instruction for continue reading the instructions, but from that file. So that's really like a function. So this is cool. Um, for those of you who care, this makes your RPN calculator Turing complete. So you're implementing a Turing complete language. We could now implement this. We can now implement a. You could compile C plus plus for this. Well we'd have to add some stuff but strings and you know um take 170. So Turing complete means basically as powerful as any other computer in theory. In theory. Right. It might take the age of the universe to, to to compute something the other computer could do instantly. But that would be that's merely pragmatics. Um, so that's pretty cool. All right. So that's project two. I hope I've gotten you excited about it, or at least knowledgeable enough to get started. Uh, because it's, uh. well, it's fun. It's a lot of fun. I particularly like the final thing. That was my big demand when we first created the project. I was we were brainstorming it with TFS and I said, oh, we need a file coming out. So that was sort of my big no. We have to have that because now we need to recreate it. All right. Um, okay. Um, so that's RPN. And now we're going to continue our trees, and we're going to look very specifically at binary trees and specifically specifically at traversals of the binary tree. Um, a, a traversal. Just so in tree, remember we had all that vocabulary. Hopefully. So some more terms. If you have a computation that looks at all the elements of a tree, that's called a traversal of the tree, because you have to go through the tree and you you go, you go through all of it somehow that's called a traversal. And when you're doing a traversal and you look at a particular node or data element, that's called a visit of visitation. You visit each node in the tree. And so we're going to talk about binary trees. And they're traversals today because they're particularly salient for a lot of cool data structures. Um so remember trees either empty or not empty. If it's not empty then there's a distinguished root node. Um, and each node may have more. And there are subtrees zero or more subtrees. And usually there's data stored in the node two uh, key. Every node has exactly one parent except for the root of the whole tree, which has no pairs. So you can't have two parents. You can't and you can't have cycles and.

UNKNOWN
Things like that. Okay.

So today we're going to look at binary trees because they're particularly important. And they're going to give us some um we'll see them in very useful data structures called binary search trees, widely used in practice, self-balancing binary search trees, which are the things that are really used in practice, and then heaps all of those things are going to be based on this concept. So really important to understand binary trees. Um, the good news is they're not hard to understand. It's like a linked list, but there's a instead of a single tail, there's like a fork, a fork in the road. And the order matters. So who's the the the left subtree and right subtree. Um, if we took the tree and we reversed these, we would say that's a different tree now. At least in principle. Right. If the application were arithmetic operations. So if this were you know B plus C or sorry D minus c, then of course you can see the order absolutely matters. Right. So so we're going to have two children. We'll call them left and right or child one child 2 or 2 or something like that. So that's what a binary tree is then. So just clue you in a bit on where we're going. I just want to talk about finite maps for just a couple for just a minute or two. Um, a finite map is something that maps from keys to values, so they go by a huge variety of names in the industry. They're called key value stores. Sometimes, um, C plus plus calls them maps. Um, JavaScript calls them objects. Python calls them dictionaries. They have all these different names. Um. The thing that unites them, though, is that you want to store data in this data structure, but so you want to do several things you want to store stuff in, and then you want to be able to remove them. But the key operation is you want to search it. You want to find out is this thing in the, in the, um, in the data structure, and if so, what other data is associated with it. So that's the key. And the value. The key is the thing you search on. So, for example, um, insists there's definitely a way to look you up by your student ID, right? So they have a finite map that maps from a student ID to all the information insists about that student, including your current schedule, your advisor, and you know where they send the bill. That's a really big one for some members of our university. Um, right. So there's all that information about you. And the key in that case would just be your student ID, and the value would be all the stuff of that. Um, the value could include the key. So when we get back to the value, your ID might be a member that's stored there, or it might not. Depends on the application. Um, if you've ever reserved a flight, you know, you get a confirmation number and then, you know, you call up and you go, oh, I've got an issue, blah, blah, blah, blah, blah. They go, what's your confirmation number? What are they going to do? They're going to use a finite map that maps your confirmation number to your itinerary and billing information, and they're going to change your flights or, you know, give you credit or frequent flier miles or whatever, right? You're in a hospital. You've got the thing on your on your wrist these days. They put it on your wrist and so they wheel you around and they just poop, poop, poop, you know. And that's good because then they replace the correct knee, for example. In cases like that, they also with a big marker they put like an X on the on the leg. They should leave alone with you stuff like that. My my dance partner is an orthopedic surgeon. So, um, and I did have knee surgery at one point. I didn't have it replaced, but they definitely came in and said, we're doing the right knee today. Yes. And then look at the chart. It's like, am I going to get it right or not? You know, and then they put a big X and it's, you know, arrows and everything. This one doc do this one. Um, because you know, you hate to go through that for the wrong reasons okay. So key value pairs this ability to look things up based on a key and get additional information about the phone book. You look up people's phone numbers and addresses based on their needs. They're everywhere once you start to think about it. Anytime you want to look up information about X based on small, relatively smaller amount of information Y you have, you've got to find that key value pairs. They're called finite because um, in math, um, a total mapping would have to map everything in the domain. So like if you've got a phone book, all strings would have to logically have an entry. And so you're only going to have some keys that have values in the, in the thing. And then other keys just don't have values at all. They're not there. So that's why it's finite. There's a finite, uh, collection of key elements whose, whose associated values are stored. Um, we've already gone through it. A dictionary maps words to their meanings. Contact list. Takes a name and gives you phone number, address, hospital records. Is that crazy wristband thing? Um, uh, Fedex uses a routing number. You get this all the time, right? Track your order, and it gives you the order number, and you click on it, and it goes to Fedex or UPS and looks up the order in a finite map, which is stored in a database that maps keys to values. And then they get, oh, okay, well, we've received the label and we've shipped it, and now it's currently in Boston. And it'll get to you Thursday or something. Right. So you see these things all the time. And the key operations are you want to be able to add a new key. I thought I just skipped to the end of this. Um, you want to be able to remove a key. You want to be able to look up a key. You want to know, you know. Is it here? So contains. That's a good one, I guess. Look up sort of a certain you know, if you can look it up, then it's there. Um, and you want to be able to change the value associated potentially. Like you might move and then if you move, someone will update you in their address book. They'll take your value and they'll replace. They'll replace the old value with the new ones with your new address. Okay. Um, right. And so you want to know how many things are in the address book, or how many patients you have currently in the hospital or what have you? Um, maybe you wanted to find iterators that all that stuff. Okay. Um, so why, um, why binary trees are associated with this? Well, we're going to see several data structures that implement a finite map and binary trees, in particular balanced binary search trees, which we're going to get to, um, can be used. And there are two ways to do this. One is that you just store two things in each node, the key and the value. That's one way to do it. Another way is you store a struct that has the key and the value in it. Another way is you store the value and then you store some function that takes a value and tells you what the key for the value is. There's a gazillion variations on this thing, but the most straightforward one is if we want to map to keys to values, we just store a key to value in every node. If someone wants to know if a key is here, we go through the tree till we find the node with that key in it, and then we tell them what the modulus. Right. So this is the most this is probably the most straightforward way to to think about it. Now sometimes we'll think about keys and values. For now. Um we're mostly just going to get comfortable with binary trees. And so for our examples now we'll just store one element in each in each node. Or maybe we store elements just in the leaves. I sometimes do that for example on exams. Hint, hint. Um, I'll sometimes just say, you know, write a function and all the data are in the leaves, but you have to traverse the tree. Blah blah blah. Some rules and combine the elements. Um, okay, so a quick review. What's the height of the tree on the left? Okay, I've seen two people voting with their fingers. That's nice. Three people. Okay, a few more. You can say it out loud. Two, because the height of the tree is the length of the longest path from root to a leaf. And remember, we counted the length of a path. We counted the number of hops, not the number of nodes. So from A to B that's one hop B to D that's two hops. All of them are the same. So okay how about on the right. How about that one. Right. Because it's the longest path. So we say the height of the tree on the right is three. Um. Okay. Um, so let me let me ask you a question. Um. If I have any nodes in a tree. Is there some limit to how tall the tree can be?

Yeah. Minus one and minus one.

Right. Because that's a linked list. And if you have n nodes, there are n minus one hops from the first node to the to the last. Right. Exactly. Exactly. Um, okay. If we know the maximum, what do you think the minimum is? And this is a little bit interesting. Um. So let's see, that has, uh, that has seven nodes and this is one, two, three, four, five, six. So both of these have seven nodes, but one of them is shorter, right? Can it get any smaller than the one on the left? Why not? Yes. So yeah, we said it was a binary tree so we could make it shorter if, for example, we made everybody a child. Okay. And then the tree is of height one. But. But binary tree forbids it. We can. So the best we can do is is branch twice for each node.

UNKNOWN
Yeah. That's interesting. Let's think about this.

Um, so one way to think about it is, uh, if you want to make sure that a tree is of minimum height, um, and we're going to put aside all the issues about where you put things, just we've got nodes and we just want to fill it up and minimize ly. Um, you can sort of try to fill up each level of the tree. So if I were like building a tree, you start with the root and then level one you do. Level two gets to be interesting. So you do the two children of the node on the left of the root, and then you do the two children on the node on the right before you add any more. Before you go any deeper. Okay. Uh. So we'll just sort of think think about it a little bit. So if we number the levels, if we say level zero is the level containing the root, um, then level zero can always only have one node. That's the maximum. Right. Because level zero is the first one. So it has to be the root is either the tree is empty or there's one node there. Right. Um, the next level down can only have two nodes. Right. Because you're just one level down from the root. The root can only have two children, so the next level can only have two. Now each of those two children can have two children. so the next level can have four and the next level can have. Eight 1632. Right. So it's two to the power of level. Right. Two to the zero is one. That's how many nodes there are at levels two to the one is two. That's how many nodes there are at level one. Two to the two is four. That's how many nodes there are at level two. And so in general level N you've got two to the n nodes. So this brings us back to the call tree example I mentioned last time. If you want to reach people very efficiently, you can sort of put them in a tree and fill up the brain. You don't want to make them all into a linked list because then you haven't really saved anything, right? You may as well call all the people if the first one calls only the second, the second calls it. But if each person can call three, you have a bounded amount of work that each person has to do, But in a certain number of call steps you can reach exponentially many people. And this gives us a hint about why we kind of like trees. They really help us deal with scaling issues in practical systems. Okay, so a full binary tree. So full means as full as possible. So all the levels are full. Maybe the last one is not full, but actually which one are we going to talk about here for a second. Um, okay. No full just if everything's filled up. So, um, everybody either has two children or zero children and we filled up the levels. Have we, as we've said before. Right. So all the levels are full and then we run out. So what's interesting is, you know, how many nodes the whole tree has, right. So four level tree has 16, uh, nodes. So now the question is how many nodes are above those nodes. Interesting. Here. The number of nodes, if you have a m is the level. If you have M levels, then it's two to the M minus one. Right. So you get. So uh two to the third is eight. And a three level tree will have. Seven. The last one will have two to the three, two to the three minus one. So they'll have four. And then above that will be two. And then that will be one. So if you add up all the powers of two up through the last level, then what you get is 2 to 2 to the m. Minus one is the total number of nodes. Committed. But but do some examples. Right. So um, a one level tree has one node in it. So sorry. Yeah. So, um, how do we do it. So I keep forgetting about the minus one. Oh. It has height minus m minus one. So that's the cool thing. So it has height of zero right. So then it's two to the zero which is one. Doesn't that go wrong. I think it must be I'm calculating it wrong. It's obviously true that a one level tree is one node in a two level tree has three. Which is two to the two minus one because you've got a node, and then you have two children. And then a three level tree has that. And then you've got 2 to 2. So you've got four. Look at that. Right. And so you've got four plus two is six plus one is seven. So two to the three minus one. The big news is down here at the bottom, which is that the height is order log the number of nodes. This is very cool. That means you can get to any node in the tree if it's full in a logarithmic number of hops, and then the plus one and minus one don't matter anymore because they're all order, you know, plus 1 or -1. There's still all order log in. And in this case it'll be log base two. So that's the big thing we can store exponentially. We can reach exponentially many data items in a in a relatively log number of hops. So that's pretty cool. And this means if you want to search for something in a finite map, if the tree is full, you can expect to find it or know that it's not there in a logarithmic number of steps. So this is why we start to use one application of binary trees is for finite maps. Well, trees in general, but binary trees get used to one. Okay. All right. So that's kind of why we love binary trees or why we might be interested in them, but we love them for so many more reasons. We can represent any kind of hierarchical relationship with binary trees. And you know, as a computer scientist we love arithmetic expressions. Now we're not going to convert these to RPN. Let's go back to regular infix notation. Um, and we can sort of say, well how would we represent this as a tree. Well we could say, well we'll put all the data in the leaves and then the sorry. Yeah. All the data in the leaves. So the data are either numbers or variables. And then the operations will be internal nodes. We could represent it like that. So if I'm in addition then my children are the things I'm adding together.

UNKNOWN
So that's the idea.

So we could represent a plus three this way. So variables and data are in these operators are in internal nodes. Um so you should know what the leaves and internal nodes are. And we can build a tree like this. Your compiler builds a tree like this not just for arithmetic expressions. It has a when when it compiles an if statement. It's got a tree node that has that says I'm an if node. And I've got a test I've got a then and I've got an else. And the else might be empty because you didn't write else right. But the compiler actually builds a tree like this. It's called a parse tree. So if you take compilers you'll, you'll, you'll actually do this with expressions. Um, now what's cool is you can see we didn't represent the trends, but the the trends are represented, um, by the structure of the trees. Right. So we know that this times isn't three times two because in order to get the thing to the left of the star, you have to already add the increase. So we've sort of baked in the trends in the structure of the tree. If the trends were different, then we would have a differently structured tree. So that's pretty cool. Uh, okay. So here's an interesting one. So a times a times what. Plus four three. And then all of that minus B. I think you're going to love me. Four plus three, eight times that and then that. Minus be. I don't get it. Yes. Can you explain it? Can you turn it into a into a question? Um, okay, so here's what's happening. We're taking variables and numbers and we're storing those in the leaves. And then what we're doing is if you're an operator, you have to have operands. And the operands are either leaves or subtrees. So for example this minus is going to subtract B from something. What's something. What's to the left of the minus. All of that stuff is to the left of the minus by conventional ordering and the parentheses and everything. So we're going to subtract B from all of that stuff. So that means the left side of the minus is a tree that calculates all that. Okay. So what is all that. Well that is actually the product of two things. It's a times something a times. But the thing to the right of the times isn't just a simple number, it's actually a sub. So anytime you have a complicated expression, it becomes a subtree rather than just a node. Does that clarify? Yeah, yeah. Okay. So this says a times four plus three. And then all of that minus B. That makes sense. Yeah. Okay. By the way please feel free to ask questions like that because I've been through it a few times. So I might go fast. And then it's perfectly appropriate to slow to say, wait a minute, wait a minute. That makes no sense. Um, okay. Um, so here's a practice problem that's sort of fun. Suppose you were going to print, um. Suppose I gave you the root of one of these expression trees, and I said, print it out. But now, since you're going to print it on linear paper, you have to actually get the order of operations, right. See, the thing is, if if instead of writing symbols on paper in a linear sequence, we could have like a two dimensional thing and make a tree out of it, we wouldn't need prints. Of course we use RPN. We wouldn't need friends either. Um, so that's kind of so really what the prints are. It's a way of dealing with the fact that linear text doesn't model hierarchical structure. And so we use prints to say, no, this thing is all a sub unit of that. But our trees model that directly. So anyway right. If you were going to write such a function how would you do it. And hint the first time you do it, you know what you do. Parentheses everywhere. Just extra friends don't count against you. Just parentheses. Everything. Okay. Here's. Here's parentheses. Everything. How would we do this? What do you think? Recursion asked me to do. You knew I was going to. I was going to love recursion. Yeah. Yeah. Yeah, yeah. Um. And you had a hand up. Uh.

Yeah. I think I didn't, like, completely fake myself out so much.

Okay. Um, well, let's let's do it like this. What's the base case? What's a base case? Yes. No. How do you know there's no children? Could be a base case. Yeah. In that case, what do we do? Um, we put parentheses.

Around it and then just.

Okay, so if if a node has no children we call that a leaf. So you could say is leaf root print parent root arrow data right parental left friend right data right print. Okay. That's one case we could do. Um, can it be like the root, the variable or a number? Well, the, um, you, you can have a tree that just has the root int. Now you we seem to have forgotten the empty tree, but the empty tree is the easiest one. Come on. You got to you got to celebrate your accomplishments handling. Right. So what do we do for the empty tree? Okay. Yeah. Oh, I like it. Right? If the tree is empty, don't do anything. Right. Okay. If the tree is empty, don't print it. Okay. So now we know that it's a non leaf node and it's uh, and it's non-empty okay. So what. How would we handle that case. Okay. You type a left person and then you do something maybe, and then the right print. Call the.

Function again. Let's run and call the function again for the right right.

Okay. So we're going to. So we want to visit all the nodes. So we want to if only we had a way to to print a subexpression fully parentheses. Then we could fully we could print fully parentheses versions of the left and the right subtrees.

Call the same function again.

Yeah. So we just so then what happens is if you're here you say you know what. Open a parenthesis. Print my left child. Now print me I'm an operator. Now print my right child. Now print a right parenthesis. There you go. Invisible. So this is sort of a kind of a C plus plus. But but, uh. Um. Oh, and you'll notice that the leaf isn't called out, but that's because, um, a leaf is a is something that has two null, two empty subtrees. So then what would happen is if it's a leaf, you print everything out in the non-existent left subtree. So nothing prints. And then you can print the data. And then you you would print the non-existent right tree. So it turns out that um, the other case is I mean, it's a case you should absolutely get right and think about. But you can have you can have all of this. You can this code will handle all of them. So that's pretty cool. And so if we were to run it on this code, we would get, you know, because when we get to a it has the these two things don't print anything. So we print left for n a right print. Right. everybody see that. So that's how we get the listing. And then the star printed left Perrin. Well, the star printed left print and then the plus printed left brown and then the a printed left brown, a right brown, and then plus left brown. Three right brown. And then the plus printed the close friends. So that was all. All of this happened when we did the recursion starting at the plus. Okay. So then the star did the left and then it did all the plus stuff. Then it does the star. Then it does all the stuff to the right of the star, which is this.

UNKNOWN
Sort of fun.

Um, now coming back. So it's nice that this doesn't have the leaf case, but the leaf cases are always ridiculous with parentheses. So one way to remove extra ones is to have your case, but not print the parentheses in the lead case. Then it starts to look a lot neater. Right. So for for an empty tree, print nothing. If it's a leaf, just print the value. Don't print the parentheses. And I won't show you the code. But. Else if node is a leaf. Same thing, except you leave out the parentheses. But yeah.

Noticing that also like the parentheses on the way outside are always going to be unnecessary because it's so is there a way to tell if you're in like the first column.

Oh yeah. Well you can do you know, some of you guys know this abbreviation, small matter of programing usually said in a snide way that suggests it's actually really hard. Um, no, but so could we eliminate the outer ones? Yes. You could, you could sort of. special case the route. An easy way to do that would be to call a function that does the route and then calls another function. Right. That would be another way to do that. Um, yeah. So absolutely, absolutely. Okay. Um, we've just seen an example of what I said at the beginning. So a traversal, any mountain climbers here. You know, mountain climbers, who's going to put up all the pumpkins on the tops of the buildings? Somebody has to do that. Um, they call it a traverse when you when you climb across, like the face of the mountain or something, they call it traverse. So I kind of imagine a tree traversal as being like a rock climber climbing all over, you know, they go down to the next node and then they climb back up the climb. So I always imagine it like that. Um, if anyone would like to do a project where they animate a climber doing it, that would be awesome. It's not that way. Uh, okay, so we've just seen one kind of traversal where what we did was if we had a non-empty node, we sort of had an order of operations, right? We looked at everything to the left, and then we did something for this node. And then we looked at everything to the right. Now in this particular case it's kind of a void function. We're just printing. But we can also return values as we'll see maybe in a few minutes. But I just want to focus on the visitation order now because there are four standard orders that you should know. What you just saw was something called an in-order traversal. So a tree is either empty or it's non-empty. And if it's a binary tree, then it has two children, either of which or both of which can be empty or not. Right. So it's trees either empty or non empty. It's not empty. Then there's node and maybe there's a data value and two children two subtrees. Um, if you visit left subtree, then visit the element in this node. Then visit the right subtree. That's called an in-order traversal like infix operation, right? So not surprisingly, these two things go together. We were looking at infix arithmetic operations with infix binary operators. To print them out. We did an infix traversal. There are sort of three. There are four traversals we want to talk about. But one is odd. Is is very different from the others. The first three are all very similar. So the idea is for an in-order traversal, you for all of them, you handle the empty tree, whatever empty tree ness means for this problem. Um, for in order you visit left you visit data element, you visit sorry you visit left you visit data element. you visit, right? Um. For preorder. What this means is you visit data element and then you visit left, and then you visit right. And this corresponds to like a prefix notation. Right. Pre. Before I processed this node, before I process the subsidiary um post order is the other way around. So you do that you process this node only after you have processed the child nodes. And so it'll be, you know, left right visit. Right. So these are these are three standard traversal orders. And they're all basically just rearrangements of the code. You can go from one to the other by just moving a couple lines, by moving a few lines around, whatever the handle the empty one is, you just you cut all of those lines and you paste them into the right place. If you paste it at the beginning, it's preorder. If you paste them between the left and right visits, it's in order. And if you post paste it after it's post order. Pretty cool. All three collectively are called depth first traversal. I don't think so. Um, do you have a question?

Yeah. Wouldn't I mean, wouldn't there be more? You'd have to iterate, like if you're printing something like, because if you printed the left node like parentheses a times three and then you print this uh printed like parentheses B minus two and then you print it times, that's different. So you have to.

Well that's a post order traversal.

But but that's it's not. You just change a few lines to get to do the same thing. Like it does something slightly different.

I'm not sure I quite follow, but I don't mean this as a programing guide in the sense that you never have to understand the code, you just paste stuff around. So you do have to make. So I'm not sure I understand the case you're concerned about, but um, I'll take I'll take it as I'll stipulate that it's legitimate and interesting and and cool. In which case, um, you still have to debug and test your code. Um, so I will stipulate. Um, okay. So, um, one of the nice things about traversals is they are great fodder for exam questions, right? List the nodes in the visitation order for a, um, an in-order traversal. So if we just think about printing, you can do that. But it's strictly speaking it's a visitation order. So, um, which which node will be executed first if it's an in-order. Which would be the de okay.

We'd go left. But, uh.

Yeah. So the interesting thing about inorder is it tends to go like all the way to the left first. right. So that's kind of what it does. Um, and then we're going to do in order. So we go, well, I want to do a but I have to do left first. Okay. Well now I have to do B, but I have to do it's left first. I want to do D but I have to do it's left first. But that's really easy because there's nothing there. And then I do D and then I do D's right. Which also is easy. Having done that. Now I've completed the visitation of B's left subtree. Now I can do b. So I'm going to get d b and then e am I right. Okay. And then having done all of that now we've done A's left subtree. So now we can visit A. And then we have to visit the right subtree of a. And what's the first one there that's going to get this. F because we can't just directly do C we have to we have to visit the whole tree of C which means we have to visit its left child first. Left child first. So this is the first thing to get visited. But it's invisible so we don't count it. So then f and then this one. And now we've done C's left subtree. So now we can do C and then. So if I got that right. D e f c g. And of course another way to ask the exam question is to give you a tree and then give you this and ask which which traversal it was. So these are nice because they're easy to ask. They're easy to grade. But they actually test whether you understand the traversal. So love questions like this. That's a hint. You may see some questions okay. Oh wait no I should have. Ah why did I hit the spacebar okay. Um can we go back in time. Uh, so preorder traversal. Well if it's preorder, then the root is always going to start if it's a non-empty tree because that's a preorder. And then when we visit its left, we do that node first. That's a B and then D before it's children. And then we've already done B and it's left child. So now we do the right child E and so on. So we've already done a. So now we're going to do C. And then C's left child contains F and then well yeah. So f and then it's two children C C and F are now dancing. Okay I will not hit the spacebar this time. How do we feel about the poster. What's the last thing that's going to print okay. Right. Because post order the the the first tree you look at that node is going to be done last okay. So that's one one way to think about it. Actually that's not a bad way to think about it. Now you can see what's going to print last over here. So you could do it backwards. What's the first thing it prints.

The B.

C handle empty tree. So we visit the left subtree. So then we visit the left subtree right. Um so then we visit the left subtree. Then we visit the right subtree. And then we visit this. So it looks like D is going to be first. And we still can't do B because we have to do its right subtree. So it's going to be db. And then we still get to A. Because remember we said that it's going to be last but we have to do its right subtree. So then this one we have to do its left subtree. So then this is going to be FGC. And then a. And if that were too quickly that's okay. That means a great opportunity for practice which can come right. Oh question. Yeah.

Yeah. Uh for in order would also be possible to do right subtree then current and then left.

I'm sorry can you say that again.

For in order. Could you do like that backwards. So like with give it the right and then the current and then the left.

That would still be considered an in-order traversal. If we say in order by default we do left first. Okay. Because if the right were always first you would just make the mirror of the tree. Yeah, but there may be some operations that treat the the right one first. And in that case. So we would still call it an in-order traversal, because the visitation of this node's data comes between the other two. But the application might dictate a different order okay. So fair enough. Fair enough. Okay. Um, and then uh, so we've got these I think I want to leave these as exercises, if you like. So, um. I want to get to this because I think I want to talk about the last traversal, and then I want to get that in, and we have. Well, we have seven minutes. Okay. Um. All three of these are called depth first traversals. I mentioned this earlier. The idea is that notice that each one sort of goes all the way to a leaf before it goes to. So, you know, you'll go all the way to a leaf before you hit the other side. So you kind of go as deep as possible, and then you come back, and then you go as deep as possible, and then you come back, and then you go as deep as possible. So all three of these are what we would call depth first. You go deep before you before you go. Why don't you drill all the way down? Um, the minute you say that, that suggests another kind of traversal, which is not like. Oh. Then, um, okay, so a couple a couple extra nodes. Um, very often on exams, a very common error is we say, you know, something like sum up all the elements of the tree, and then we get code that has no return statements in it, because they just have on their reference sheet that, you know, preorder means this and then they just write it down as if there were no return value. But you kind of have to, you know, be aware of that. Sometimes you might want to add up all the elements of the tree or an expression tree. You might want to evaluate it right. So you pass along a thing that says what the values of all the variables are. That's called an environment. When you take 105 and then what you do is if a node is a number, then that's the value if a node. So leaf nodes have a value, it's either a number or it's the value of the variable in your environment. But then a plus is the sum of the two subtrees. And you would return that. And a slash would be the the quotient of the two subtrees. So you would return. So um, don't forget that you, you know, this is the order of visitation. It's not the complete calculation. There may be more that you have to do. Um, oh, here's a good question. This is really useful when you write a recursive destructor for a tree. And you had to pick one of these three. Which one would you pick? But the postal one poster. Who said that? Yes.

Um, you don't want to delete the current node. You want to delete it last so you don't lose data.

Right. Because once you delete it, if I say delete P and then do something with p zero. That's an error already. Because once you do delete p you can't use that anymore. So post order. So generally speaking um recycling is always a post order operation. Okay. Now I want to be sure to get to the, um, to this last traversal because it's cool. And this is one that if you're a human and you're looking at paper, this makes perfect sense, right? A human if I said, what are the nodes on the tree? A human might say a b, c d e f g. They just go top to bottom, left or right or right to left, but they go sort of level by level, and this is called a level order traversal. It's also called breadth first because you're going to go why. Before you go deep you're going to go A and then b c and now we go another level down. So you go wide as wide as possible on each level before you go to the next level. But this is different from the other ones we've been looking here. Oh here's another example. I'll pause, read them off in level order. 1742 4210 to 2932 right. Okay. So level order traversal, it's important to understand that not all trees are completely filled up all the time. In fact, that's a kind of that's a really cruel assumption to make because, you know, remember all trees, all completely full. Trees of three levels have seven nodes in it, so you can only have expressions with seven symbols, right? That's not very. That's not very flexible. Um, so trees have to be allowed to not always exhibit the completely full structure. Um, now of course, anything you can do with recursion, you can do without recursion, you do iteratively. Anything you can do iteratively, you can do with recursion. So there's no absolute thing. But it's hard to do this recursively. The other ones were all like trivial to do recursive. It's about as easy as recursion gets, right? Um, but the this this is really tricky. Can you see why? Why do you think. Why is it hard? Because, you know, I love to write recursion, so I would really love to do it recursively, but I wouldn't in fact. Well, because.

You're going to start you're going to like you're going to print a and then you're going to go down to B, but then you have to go back up to A and then back down to C. see.

Yeah, there's no obvious way when you're processing this node to get to this one or this one or this one, right, that it doesn't have that, that nice thing where you kind of all the information you need is kind of right here. Right. So. Um, so because it jumps between subtrees, it's a little bit of a pain. Um, so how would we do it? And this is kind of where I want to get to today. Um, because this is where we start to do more sophisticated algorithms a little bit. And we use an auxiliary data structure. Which data structure we've looked at so far would be a good fit for this. And remember, what I want to do is, um, after I do a, I sort of want to be able to look at B and C sort of in that order, and then I want to be able to do DFT in that order. Can you think of a data structure that might look like a Q would be perfect, right. Because now we don't have to visit each node, we just have to schedule it. And so we use it. We can use an auxiliary data structure. You could do the other ones with the loop. Your auxiliary data structure would be a stack right. So it's pretty cool if you. Okay. First understand this. So we're going to have a queue which is not very helpfully called queue. In my code that I wrote this morning, I wrote to do. But um, maybe I'll, I'll share that later. So queue. So you enqueue the route because you say, okay, the first thing we got to do is the route. And then what you're going to do is you're just going to keep going until your queue is empty. So basically the queue is like the orders in a restaurant. And when the last order is done, you get to go home and you start with the first order. It's an unusual restaurant. You close as soon as there's the law and you get it and you get caught up. So while the queue isn't empty, um, look at get grab the first element off the queue. Um, Then what are you going to do? Is if it's a null pointer, you're not going to do anything. But if it's if if it's if it isn't a null pointer, you'll visit whatever that node is, right? Whatever visitation means for that, then what you're going to do is for that node, you're going to schedule its left and right children. So you put them at the end of the list. So after we finish the first level, we'll get to these. After we get this level done we'll get we'll get to these. So you enqueue those um and then if front doesn't actually pop the element off, you have to remove it from the queue. And then you just keep going. So what happens is you get, you know, you visit a node, you put its children on the queue, but in the end you'll get you'll get to a null pointer, do nothing, and that'll just pop off the key. So then you pop another thing off the queue if that's a null pointer, and eventually you'll get a whole bunch of null pointers and you'll pop them all off, and then you'll indeed you'll be done. So there's a little bit of a thing. So we visit a queue bc Week we visit the Hewitt stepchildren D and. Then we visit C Hewitt's children F and G. Then we visit D and now we start getting all pointers because we've got leaves. So now we just kind of work through the Q and then we get through all the null pointers. We're done. Okay. So um so I want to stop there. Are there any questions before we go. So we've got four traversals three depth. First one breadth first. The three depth first are naturally recursive. We would say very easy to write recursively. The breadth first uses this cool auxiliary data structure. Please study it because it's a great example for things we're going to do later. Uh quick question. Yeah.

So the traversal.

We have to do the reverse where you give us like your first order, bring it.

Out. And then we construct a treat for for breadth first.

Just for the traversal questions.

For traversal questions, I could ask you to do any one.

Of those.

Three and I.

Might say printed, or.

I might say there's a some or better yet, a difference, because then the order matters.

And like you give us like the preorder and post order, for example, like if it's already printed out.

I can ask you to eat anyway, I could give you a listing and ask you what the.