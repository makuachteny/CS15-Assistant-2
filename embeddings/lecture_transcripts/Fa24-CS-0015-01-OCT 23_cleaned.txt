Hi, everyone. So, um. We have, uh, um, we have a little bit of flexibility today, so I'm.

Going to talk about templates, um, which is on the schedule. Um, there was something else I want on the schedule. Is it? But I'll have to debug that later. Uh. Uh, AVL trees are something we just finished, and I just want to pause and see if there are any questions about AVL trees. We know why we want them. I hope we've set that up pretty well. Right. Binary search trees sadly can be order n um for searching and updating and um, but but binary search trees have the potential for long time access. Uh, if only they're balanced. So we needed a way to automatically. We needed a way to maintain balance. And so there are several approaches to this. The AVL approach is to constrain the tree so that with the additional invariant in addition to the BST invariant, that the the left and right subtrees never differ in height by more than one.

Yeah. Like in the process of like balancing it out. Is it it more like time like not efficient compared to if you just have like a regular binary search tree.

Um, so yes and no. We have to think about about things if you, um, if you, if you take a given tree and you insert a thing into it, the AVL has overhead compared to the binary search tree because it's it potentially may have to rebalance. And the binary search tree one. Um, but you pay the price later. So if you don't rebalance with the binary search tree, that individual operation may be faster, but if you do thousands and thousands of insertions, you run the risk of now all of your things are order in instead of log in, and the order end will completely swamp any benefit you get by not doing the local changes.

So say, for a long run.

Uh, yeah. So whenever we're talking about complexity, um, we're always thinking about the long run. We're always thinking about, you know, as the number of operations increases towards infinity, you know, which of these things when which of these things wins? Um, now, when you've got log versus linear, it's pretty big difference. Um, and the constant factors for AVL are not large. So there are 3 to 4 times 3 to 6 assignments, assignment statements a couple of conditionals. So maybe you're talking like less than 20 machine operations to do it, which is pretty insignificant. Um, so I mean, it's a good question and you should always be asking that question and think about, okay, we're doing extra work. Is it worth it? And if it doesn't change the if it might be worth it, even if it doesn't change the asymptotic behavior because, um, you know, when we're doing asymptotic analysis we say oh constant factors don't matter. But if I told you booking an airline flight was going to take ten times as long, you would go to another place, wouldn't you? Well, ten to constant factor. What's your problem? Right. The problem is that constant factors sometimes matter. Um, but nonetheless, particularly as applications get large, uh, they, they get swamped by, um, by asymptotic behavior. So, um, well, we're going to talk about sorting, but I'll just let you in on a little secret. Um, a lot of the most sophisticated sorting algorithms, when the number of elements gets down to like 20, they do an n squared sorting, because the overhead of doing that sort tends to be very small. And of course, if it's below 2020 is a constant. So it doesn't actually change their asymptotic runtime. But to your point, the the the absolute time to sort 20 elements using one of the simple sorts can actually be less than using one of the more complicated ones. So the complicated ones when when n gets large, they use it. When n is large, the smaller ones win. When n is small, they use those when n is small. So they do. They use a hybrid algorithm. They choose their algorithm based on the size of the data. So this is, um, a common phenomenon. That's a really good question. Um, I'm just going to caffeinate while I'm over here. Not me. The computer. I've already caffeinated myself. Caffeinated. Okay. Any other questions about AVL trees? Yes.

Um, how does the removal vary from insertion?

Um, only in the first part where you. So you still do um, we to do insertion we did naive insert and remove. You do naive remove okay so and but then after that point it goes up the tree and does exactly the same. Okay. So um, so that's a good question. And also very fair because sometimes removal isn't quite so easy. Um, so that's that's fair. Uh, be sure you understand the rotations and then you practice them. Um. We'll talk more about uh, about that later. But so AVL tree is good. Everybody's like great. Oh wait wait a minute. You had the lab right. And the lab was. No, I mean I'm asking for a quality judgment. So sort of I'm getting a few okays. I'm getting a few ups. Um, I'm not seeing any down, so I guess that's that's my positive spin on it. Okay. Um.

Uh.

So I think.

With all of that.

Said, then we will move on. And if this runs short, we can start Huffman coding, because I think that might be a little bit longer. We'll see. Um, okay. So today is uh, going to start as a kind of big idea. We're going to talk about something called universal polymorphism. Uh, how many of you heard, um, it goes by many names. It's also called generic polymorphism. So if you've heard of Java generics, it's that, um, same idea. Uh, it's I say so parametric. Um, universal generic. It goes by all of these names. So, um, what? So do you know what polymorphism means or what is morphing?

Okay. Well, I mean.

Like, turn it into something else.

Well, so, um, more. Right. So morph can mean that used as a verb, uh, and as a, as a noun. And etymologically it means shape. So that's why if you watch like Deep Space Nine, the shape shifter shifters, right? The, um. Okay, they morph from one form to another. Right? So morph means shape, so polymorphic poly means many, so polymorphic means many shapes. And in programing languages, the shape we're talking about usually has to do with data types. So that means. So a polymorphic thing supports multiple data types. That's what polymorphism means. Now C plus plus has several mechanisms for different kinds of polymorphism. The one for universal and parametric or generic polymorphism is called templates. Um so polymorphic programs. Um so it allows you to write one program, but it can work on many different types of data. That's what polymorphism means. There are kind of two flavors. Um, and this is more 105 topics. So this will be the only slide on it really. Um, there are two flavors of polymorphism. You have to know them because you have to program in the language and the mechanisms you use for the different. So if you're going to program these things, you need to know, um, ad hoc polymorphism means that it supports many types, but it doesn't support like all possible types. It means somebody made a list and said, we're going to support these types. And so it works on kind of a, a collection of types. And uh, examples of that ad hoc might sound bad, but it's not bad. It's undeniably useful. Um, I love ad hoc polymorphism. We use it all the time. Um, classic example from CSS 11. You learned that you could use the plus operator, and it worked on floating point data, and it worked on integer data, and it worked on integer data of different sizes. You'll learn in 40 that all of those things are completely different to the machine code level. The computer runs different instructions for adding floating point numbers and integers. So the plus operator. So there's a floating point plus and there's an integer plus. And they are not the same operation but you use the same symbol. So you can think of the plus operation operations as supporting multiple types, but it doesn't support all possible types. It supports, um, the built in ones. Uh, and C plus. Plus has another mechanism called operator overloading that lets you add new types to it. So we've seen this already right. You can say what is the what is the assignment operator do on my do for my type? Um, if you don't say then C plus plus will, you know, do the crazy thing. So you want to say if it matters, but you can override anything. You can override the subscript operator. So now your thing is subscript even it may not be an array may not even contain an array. But if you like square brackets in your syntax you can say operator square brackets over. Right. Um, you can uh, well, um, you haven't seen an example yet, but if somebody prints using the the less less operator. Right. So you know how to print and you can send the C out here and you can send to Into an OS stream or an OS stream, right? Um, if you have a new type, you can say if somebody attempts to print this with the stream insertion operator, what do you do? You do operator less, less. And you define that function and off you go. Right. So um, so those are so ad hoc polymorphism shows up through operator, um, overloading in C plus plus. And it shows up in a way that you may not have seen in C plus plus called inheritance, which you'll, you'll, you'll see some of that in 40, which is kind of a weird place to do it. But you'll anyway, you'll you'll see some of it there. If you programed in Java, you've definitely seen it. If you programed in Python, you might have seen it. Um, but that's another case where, you know, if you have a, um, a superclass and it has subclasses, then you can apply sort of the superclass operations to any of the subclasses. But there's only a fixed number, right? You can't apply it to any class in the universe, just the ones that are in the class hierarchy. If that if you didn't understand the inheritance stuff, don't worry, we're not going to use it. Uh, universal polymorphism. And maybe I should put universal in quotes. I think Mallard prefers the term parametric. And this may be why. Um, but the the ideal of universal polymorphism is no. Any time you write the code one time works for any type at all, which is pretty interesting. Uh, so you've seen it already with the STL, right? Because you can put anything in an STL vector. Anything. You can put an int, you can put an STL vector in an STL vector, you can put an STL vector of STL vectors in an STL vector. You can put sets in there. You could you could put anything, a little bit of wiggling um, into into an STL vector. And not surprisingly, templates are the mechanism for universal polymorphism and the STL is the standard template library. So all the templates in there are something that is deemed universal, universally polymorphic. And the reason I'm wiggling is you have to be a little bit careful because for example, if you try to put, um, objects into an ordered map in the STL, which is a balanced binary search tree, then the elements have to be comparable because it has to know are you less than you? So if I want to put rubber duckies in there, then I have to say, how do you how do you less than on a rubber ducky. So it's universal in the sense that you give me a type that satisfies a few reasonable constraints. I should be able to assign it. I should be able to compare it with equals. Equals, and I should be able to compare it with less than. And if you and if you say those things, then you can put it in a in the STL binary search tree. And again C plus plus I generally when I first learned C plus plus I hated it. But I always love the operator overloading. I just thought that was like that was super cool. And it's very flexible.

So operator overloading.

Implies that there's something that C plus plus will do with that by default. So isn't couldn't you say like there's something that plus will do if you just make up your own type. It just may not be what you wanted.

Well, so that's that's not an unreasonable assumption. But it so what happens is if you try to plus two things. So suppose I try to plus an integer and a rubber duck. Then the way C plus does plus plus does this is it says, well those two things I know how to plus and if it is it does that um the way it determines it is it looks at the left. So if the left one is an integer then it says, do I know how two plus integers? Then it looks to see do I know how to change the other thing into an integer if it's not already? So it goes through this laborious process, but the process can run out. And so if you have a class for which plus is not overridden, and then you try to add rubber ducky one to rubber ducky two, it will say, okay, this is a rubber ducky thing. Um, how do I plus rubber duckies? Well, I don't know, not built in. Let's look at the class. Do they have an operator overload for plus? No, you'll get a compiler message. I don't know how to. Plus rubber. That's right. Uh, the message will be. Why is it more complicated than the override then?

Because you're not overriding it. You're creating it. Uh, well.

So, um, uh, a fair linguistic point, which I encourage you to take up with the committee. Okay, so I'm just the messenger here. I didn't pick the terms, but I think the idea is that there is already a plus operator that has a lot of built in support in the sense that it'll look left and right, and you can say what it means for your class. But you're right. You're not overriding a default in the case of copy constructors and copy move constructors and assignment and assignment move operators. You're overriding a default. But not. But the others don't have defaults. So it's a fair point. Fair point. Um, okay, so I already gave away the show templates are for this, and you've already seen operator overloading and you've done it yourself, so you know all of that. So what we're going to do today is we're going to understand where the desire for universal polymorphism comes from. The truth is you have it whether you've noticed it or not. So I'm just going to point out that you want this really bad and, um, and then we'll and then we'll talk about the, the STL little bit. But you know, the STL is there and it's great and it's wonderful, but it's not everything. You might want to define your own things. Uh, and so we're going to talk about how you make your own, how you can make universally polymorphic functions and classes. And then of course, with anything, you know, um, every sort is, um, it's a double edged sword. Every, every C plus plus shaped sword has a has two two edges. And so there's some complications that are a little annoying. And I'll give you some recommendations on how to use it effectively. Um okay. So first don't reinvent the wheel. This is a, uh, something of a slogan in computing. You'll also hear it called the dry principle. Dry. Don't repeat yourself. This is a link to the Wikipedia page on the basic idea. Is this as a good programmer who values your time more than the computers, if you find that you've written the same thing 2 or 3 times, you should think, can't I just write this once and then just keep reusing it over and over and over again? In fact, we even have a name for this. It's called What functions. But so I think I heard someone say, um, is it abstraction? Modularity, divide? It's modularity. Right? We make our solutions more modular by taking something we need to use and making it more reusable. Right. Um. So any time you've written the same code more than once, you should sort of go. And now you don't always have time to fix it. And that's okay. And normal. I've had things that I haven't fixed for decades because, you know, well, it's a is it worth the effort to put the effort into something else. And that's awfully important. So but nonetheless, it's a it's a good general principle. Um, and so you've used it already. So when you say vector. Now the thing is that vector is not a type. It's not a type, it's not a class vector isn't a class vector is a class template. That is, it's it's a mold or a blueprint for any number of vector classes at any number of types. And you have to say when you use it, you can't just say, I want a vector. You have to say, I want a vector of ints, I want a vector of floats, I want a vector of ducks, I want a vector, a vector of ints, I want a vector of sets. I want a vector of playing cards. It has to be a vector of something. And by the way, this is when you get to a 40. This would be huge in your design documents. Whenever you say you have a pointer pointer to what right. If you if you just say, oh, I've got an array of pointers, you will get the feedback. What do they point to? Right. So you need to say the type and you need to okay. So pointer types are like that. You can't have a pointer. That's not a thing. You can have a pointer to an end. You can have a pointer to a function. You can have a pointer to a float. You can have a pointer to a duck. But you can't just have a pointer. Same with arrays. Um, all of that stuff is old and clunky and built in, but the vectors are sort of smooth and organized. And so the way it works is you, you say what, what template you want to use, and then you say at what type you would like to specialize or instantiate the template. And then it says, oh, okay, well it's a vector of ints. And now there was a pending question.

So.

I thought I saw something.

Right? Okay.

And there's a gazelle. Oh, yes. I don't think maybe I should just take that out of the slide. When I first started teaching about templates, there were different versions of the compiler that would. If you didn't put a space here, it would think you meant the greater, greater operator. And so it would get confused. And so you just put a space in and then um. I think since 2011 at least, that hasn't been a problem. But, uh, it left such an emotional scar on me that I left. Okay. Um, okay. So, um, that's really all I want to say about the STL, because you already know the drill. You didn't have to write the STL. It's there. All you have to know is how to instantiate or specialize one of the templates, and then you can use it. And in fact, the STL doesn't just have class templates in it, it has function templates in it. Um, it's got there's all sorts of interesting things. So how do you define your own? It's so easy. It's unbelievable. On the right, before you define a thing, either a function or a class, you can write the line that says template template less than type name. You write tightening type and a m and then you give a name for the type name and then the right angle bracket. Now it's a template. That's it. Now of course that has implications further down. But the only thing that the thing that starts the template process is use right this line. Um, the keyword type name. So this is a keyword. The angle brackets are required. The name of the type parameter, like the name of the type parameter. You get to pick this, you can pick one of two things. You can say type name or you can say class. Um, I usually like type name because if somebody can can instantiate me for ints, that's not a class a class we'll kind of won't eat. Um, but you do you. It's, um. The compiler doesn't care. Uses either one. Okay, so, um, let's just go back, um, to like the third week, the, the second week of comp 11 and see why you would want this. I would trust that you would not write this sort of code. Would you please, please say no.

Right.

Right. Oh, I'm going.

To write a function that can print arrays of length ten. Oh, that's a great. Oh no. But this array has 20in at all. What am I going to do? I know I'll write another function that prints arrays of 20.

Um.

Interesting historical note the Pascal programing language kind of had this problem. Um, if you study history of programing languages we can talk about that. And I would have to I programing Pascal so it would come back to me. But I'd have to look closely. Um okay. so what's the only difference here? Right. The only difference is 1025. So what would you do?

Make a new function that just prints and has another parameter and it looks the size right.

So two things you're going to need one function that can be used in either places. You're going to generalize the function. Right to generalize makes it more applicable and hopefully more modular. And in the process of generalizing it you're going to need a little bit more information. And so typically when you generalize a function you wind up adding parameters. Right. Because that's normal. And then when you once you've added 20 parameters now you overload it and default a lot okay. So you would you would I'm not going to say you would. You did. In fact at some point write a function that looks a lot like that. Actually, I've written many programs that look.

Like I thought I'd.

Caffeinated you. What's your problem? Um, okay. So you would add an additional parameter. So the things in in black are all the same. Why isn't the red showing up up there? So the nine, the ten and the ten. Those are in red up at the top on my if not here. Oh is it the previous slide. No okay. Yeah it was the previous slide okay. Um all right. So you would add that extra parameter. Right. And then just kind of plug in that parameter to make the other things work out. Okay. You've all been through this process. And so what I'm pointing out is that you already have this desire for more generally usable functions. And you satiated that desire by adding parameters and then making them more useful, and then calling them over and over again, which makes you happy. All right. Um, okay. So why am I showing you a silly example like that? Well, because it's not really different from this situation. And yet we accept it from, you know, we're halfway through comp 15 and probably many of you have accepted that you have to write a separate print function for any type of thing you want to print. But, but, but look, it's the same code, right? Only the only the red parts are different, right? Everything else is the same. Copy paste. Replace string int with string and does. Right. It's done. So, um, does this bother you? If it didn't before, I want it to bother you.

Right. You should be bothered by this.

Why do I have to write the same down function over and over and over again? I guess it has a certain sort of meditative joy to just do it over and over, but at some point it gets old. And so what we're going to do is we're going to do the same thing. Now, here's the problem. Functions can't take types as parameters. This is true except in very unusual languages. Um, the programing language is notable among these. But the Pebble programing language had a type checker that might not terminate as a result of this design. So C Plus plus would like type checking to terminate however awful the error messages might be. But at least it finishes right at some point. And so for reasons you can think about, if you take well, you probably won't get it in 105. But if you took more advanced PL courses, you would learn about why this is true. Um, so you have to trust me now. You just you just can't say you can't have a new type of types called type. And then you write a type T, you can't do that. Um, in in C plus plus. And so what we do instead is we have a new abstraction mechanism. So the function is a way to abstract a body of code over zero or more parameters. Right. That's what a function is in one sense. It's an abstraction mechanism. Here's an algorithm. I'd like you to package it up so I can reuse it. Maybe give it a name and it may take parameters, but it kind of abstracts away the details of that code. So now you can call the function without knowing. Is it a while loop? Is it a for loop? You're not supposed to care. I call the function. So, um, so we have another mechanism that abstracts a block of code over a type. And I showed you the syntax before. So here it is again. Um, I picked elem type, but the other stuff is all the official C plus plus syntax. Um, you can have multiple types here, but this one just has one. Yes.

We used the.

Template when we were doing, uh, that function like, uh, open or Die where it was like we wanted it to look at both things. Well, I.

Wrote that, but if you used it too, I'm very happy to hear it. Yeah. Uh, yeah. So the open or die function I showed you was polymorphic using templates.

That's cool. I didn't even know as I use this. Yeah.

Um, so. Very. Yeah, but it's nice, isn't it? Right. Because you would write the same code and replace, you know, instead of you'd have. Hi stream. Um, I have stream o f stream o stream. It would be silly. You'd have to write six different versions of it when you can just write one.

As an alternative to.

That, could you, um, accepts any parameter of type?

iOS type what? iOS. What do you mean iOS?

Um.

It's the base class of 0000.

Right, I keep forgetting. Yeah, but it shows up a lot of error messages, doesn't it? Yes, yes. So, um, so you do have access to that class and you can if you can create an instance of it, um, you could pass it around. I don't think you can actually create an instance of an iOS, though. I think what you have to do, STD, iOS, it's the I think it's an abstract base class, which means that you can't create one sort of natively. You have to create one of the subclasses of it. Right? I think, um, but I don't. So the subclassing is interesting and really fascinating in C plus. Plus I don't want to talk about it today. So here you go. You just write that at the top. And now of course, you're not completely done, because whatever the type is that you were writing twice before, you replace it with that parameter. So template is just a way to take a type one or more type zero or more type.

So is type name and some type both like variable names. No way.

No template and type name or keywords like for or void.

Or.

While or something like that.

Type is what we can rename.

Yeah. So elem type is like a parameter. Like I get into a built in thing and void is a built in thing, but I get to pick length. I can name I can name this length, I can name it. Oh no this is a huge array. I could name it, you know frog, I can just always name it X, which is please don't do that. But but C plus plus doesn't care what the name of a parameter is. Likewise, C plus plus doesn't care what the name of the type is. It just cares that you use it. What's going to happen is when you you can already tell when you instantiate the template, the template and you say, you know, vector of blah, where you say this function at string, it's just going to replace elem type with string. Okay. It's kind of like a macro, but but safer than that.

So how would you initialize it. Like how would you actually because now it just type name elem type. How would you actually get it to nil.

Okay. So um oh I do want to point out this won't work for any type elem type. What is the one thing in this function that depends on a property of the type? Right. I can declare that I can index. So it has to be um I can index the array. Right. So that doesn't depend on the contents of the array. That just depends on its arenas. You have to.

Be able to insert it into a stream.

Yeah I have to be able to insert it into the standard output stream, right. So it has to be printable basically.

Okay. Um, all right.

So let's, uh, let's see how we use it. To answer your question. Um, in general, the rule is that you can't write. This is not a function. We didn't define a function. We defined a function template, which is a recipe for manufacturing functions for a given type. Right. It's a recipe. You replace Ellen type with string. Now you have a way to print strings. You replace it with int. You can print interface. You replace it with zombie. You can replace zombie always assuming that zombie is okay. Um, so the way you instantiated is the same way you saw with vectors. You write the angle brackets. So you can think of the angle brackets here as being the kind of analogous to function call. Right. The the way you give parameters to a function is you wrap them in round braces, aka parentheses after the function. Right. Um, and so templates, instead of putting the the type arguments in parentheses, you put them in angle brackets. So you do.

That.

So print array. So print array what it is. Well sometimes say the print array function. But the truth is print array in this context is a function template. It's not a function but but print array of int is a function. That's the print array template with int put in for elem type and print array of string. Likewise is is the function template instantiated for a string, which means you just put string everywhere it said element, and then it can compile that and it names it internally. You know the compiler is a magnificent beast. Now here's the cool thing. Um, C plus plus if you don't instantiate. So if you use a thing that it knows as a template and you don't provide any parameters. It'll look at the way you use it. Try to figure out what the parameters ought to be. And it's actually for, for for most, you know, for like 80% of the cases it mostly doesn't. And so that's pretty cool. So you in this example you can actually do this and it'll figure out yeah it's a template. But they're passing an int array. And they expect an elm type array. I'm guessing elm type is int and similarly for string. Um so the nice thing. So you'll often um it can be a little misleading because sometimes you'll see, you know, you'll see the function like that. And it's not obvious if you're new to the code that it's a template, because how can you tell. Right. You can see it used in different ways, but that could be done by overloading or it can be done with templates you don't know until you look at the implementation. But okay, so the horrible error messages come.

Out all right.

So those are function templates. And it comes from the same motivation you had to reuse functions in in a letter. Right. I've written this function twice. It's only different in the size of the array. Add an argument done right. Um now we have I've written this function ten times. It only differs in the type of the array element done right a template. And now all of those cases are subsumed. But of course vector is not a function template, it's a class template. So if if a function you can think of as a as a template for building functions, right. It's a blueprint for functions. There's this Elm type anywhere you see Elm type. It's like a whole plug in everything. There can be multiple shapes of holes. So you can have multiple type wrappers. Um, you can do the same thing with classes. So, um, how does it work? Well. Um, okay. Well so motivation. Um, I don't know that I give you. So you wrote integer array lists. And what other kinds of array did you write? Yeah. Char array list. What's the difference in the code between char radius and endurance? It's the word char int right. Um. If you.

Yeah. All right. Wouldn't there be you know like there's concatenate for, you know, car ArrayList which wouldn't make as much sense for an int. And that's true.

That's true. We had some specialized operations for for because we were basically doing strings.

Yeah. Yeah.

Wouldn't there be some differences like that in terms of.

Um, could be, but you would probably not put a Concatenate operator if you were making a generic version. So like the so vector is an array list. Um, so we were more doing string I guess, because string is also um, and in fact stream is parameterized by the locale. So you can do things with other character sets. That turns out there are languages besides English to write. Uh, and so you can do that though the default one is Ascii text for strings. The default one in our locale. Anyway, the point here is that if you were writing a generic ArrayList. So thank you for pointing that out. Um, the difference would just be the type of the data. Um, so.

Uh.

Unless we have operations that sort of further specialize it, the generic form of an array list doesn't really care what the elements are, right? The point is, it's a container for your data, and it promises amortized constant time access for update and read of any element in the data set. And you'll see why it's amortized constant time access in 160. Um, and it lets you add new elements at will and it grows to a company. Right. Those are the crucial things of have a radius. There's nothing integer or straight. There's nothing that depends on the contents of the of the list. And linked list is exactly the same. And of course, you guys already know that there's an STL linked list called list. Right? You know that. Okay. Um, okay. So let's look at a simple example. And so this is okay. Forgive me. This is an incredibly simple example, but it allows me to have two entire class definitions on the slide of points. But um, but hopefully you can see the principle, um, this is just a class that represents two instances of a thing. Is this useless? Um, well, it's useful for showing an example, but after that it's probably useless. There is no a, uh, at least one of you has discovered this. I saw it in your submissions, um, that there's an STL pair right now. The pair, the two can be different, which makes it a lot more useful. So I used SDL. There's a lot going on. I've used it a bunch more than once. Yeah, okay. I've used it more than once. Okay, so we have two classes that just represent two things. So I can store two dogs or two. Is it a dog yet? Two dogs or two ints. And how do I get them back? There's a first one and a second one. And so I can I can store two things in it, and I can get the first one and I can get the second. Um, I should have made the.

Ah.

So, um, it would be too big. So I should have made the default constructor empty, but I should have taken it away so it doesn't make sense to have an empty two of them to write. How do I have an empty two of duck with no ducks in it? It's got to have two. It doesn't. It's not meaningful. So this would only has. So imagine it doesn't have a default constructor. You can you can implement this I've done this in C plus. Plus you make the default constructor private and then clients can't. Can't use it. Oh, so is everybody clear what they do? Okay. And hopefully, by this time you've seen that the only differences are in red. Okay. So, um, you won't be surprised to learn that this is how.

We do it.

Template type name. And I'm using lm type again. I should have mixed it up just so you get the idea. You can name it whatever you like. It's a type parameter. Parameter names you get to pick. You just put that ahead of your class definition. Um, and then anywhere you had the place, anywhere you had the element type, you replace it with. This. You can't do this automatically with like if you haven't introduced some of the ints in, there are elements, but some of them are intrinsic, like the size is an int. It's not the size of a dog. List isn't a type dog. The dog is of type in. So. Right. So you say, where are the appropriate. Where? You mean where Ellen type should go. And now I have a template like a cookie cutter molds, a blueprint for making classes. Now, I haven't defined a class yet. I've defined a class template.

Thank you.

Um.

All right.

So, um, this looks very simple, but I haven't finished the story yet. And, um, if we're going to implement this, of course, you'll notice I don't have implementations for first and second. And normally you would put this in the dot h file and then you would put the the rest in a cpp file. Right. Everybody okay. That's normal behavior. All right. So um we have to define the functions. And so it's going to get a little more complicated. And there kind of two ways we can do this. Uh so the first thing is you have to notice that if the class is a template, then the function has to be a template, because the. If the class can work for any element type, then the functions in the class have to work for the corresponding element type, right? So if you have a. If you have a class template, all of the functions have to also be function templates. Does that make sense? Okay. Uh so we have two places we can define the function. We could put it in here which we've generally not done because we want to separate that out and put it in a CPP. Ha. But we could put it in here, put the whole definition in and then it would already be part of the same template in C plus. Plus would make function templates out of all of the functions we defined in the class. So if we if we put an open curly brace here and then define first and a closed curly brace C plus plus would give us a template function called to of applied to Ellen type colon colon first applied to anything, right? It would give us that thing. Uh, or we can do it separately. And I'm going to do it separately, because the syntax is much more complicated. And if you see it, it might be useful to have seen an example first. And if you want to do it you definitely want to see an example first. Okay. Are we ready for example. Um oh wait. So I want to say this. Yeah. So you know, before that, when you say that a function is inside a class, you have to do class colon. Colon. But two of isn't a class two of is a template. The class is two of two of something. Right. It has to be two of something. So that's going to be part of the syntax to the left of the colon colon. And without further ado I will show you an example. Okay. So um, you can sort of it looks messy. It looks ugly. A lot of C plus plus is like that. But you just make a to do list. For each function I have to define a function. It's a template. It's a class template. Each of the functions have to be a function. Okay, here we go. Start with the first one. Um, well, if it's a function template, I have to put the template in front of it. That's what makes it a template, right? Um, do you have to name it the same thing as the. Do you have to name Ellen, type the same? No, because we don't care about the name, but developers will get confused if you change it, so I would be consistent. Um, so now we want to write a function that's a constructor which. So constructors have the name of the class. Um, but what class is it in? Well, to have this in the class it's a template. So but if this is a template that takes elem type, then this function is inside a class that is two of whatever that element type is. And then we have colon colon and then two. Of course the name of the thing is actually two of not to have angle brackets. So um. The rest of it is the same thing you would have written before you knew about templates. So I'm going to assume that that's good. Um, if you have a function called first that returns something, you can return it the you know that type because you have a name for it now template type. And um, so inside the template, as always you can refer to the type parameter anytime you have a thing of whatever the type is that you're abstracting over. Um, then first is again, it's inside the two of whatever that element type is. Class colon. Colon. Okay. So that's that. Um, second is the same. And so just to label those, um, all of those things are template functions. So we put the template in front. That's not complicated. Um, a little bit more complicated is whenever we designate the thing that the, the class the function is inside, we have to instantiate the template at some time. And what type is it? Oh my gosh, we don't know. But luckily we have a parameter. We have a type parameter for that. And then the third step is we can use the type parameter anywhere we want to refer to whatever that thing.

Yeah I see you had a boolean in the last template two of with the function that retrieve that boolean needs to be a function, template or function.

So all of the functions that live in the class have to be a function template. They might not always be very interesting templates, but they do have to be a function template I think.

I don't recall.

Trying this, so it's interesting. Um, but you definitely have to do the before the colon. Colon. You definitely have. So that's the problem. You can't write two of them before the Coca-Cola because you'll get a message that I don't know what it'll say, but it'll mean that thing's not a class. It's a class template you need to instantiate client. I tell you that I got a remarkably specific template error from client, um, which baffled me. It told me exactly what to do, and if I did what it said, it worked fine. But why it told me to do that is a matter of some mystery. And I consulted. I consulted Richard and Megan and Noah and no, I did not. And Marty, I think. Anyway, I talked to him and we were all like, well, why does it say that? So the message was clear on what you should do, but not so clear on what it means, which we'll revisit this topic in a minute. Okay. So we defined functions. We used we defined function templates. We used function templates. We've defined class templates. Let's use them well. You use them exactly the way you use the STL because those are templates. In fact they are defined with template. You can read them right. It's right. The stuff is there and sometimes you read it whether you like it or not, because you get like 6000 lines of error messages that have the iOS thing right in the string locale.

And oh my God.

It's got all that stuff. So you get a glimpse into the standard template library when you get those messages. Um, okay. So the way you do it is just like you would have a vector events. Well, now we have two of, we can have a two of this, and we could have a vector of ducks. And you can have a two of ducks there.

I'm thinking about.

Fibonacci. Um. And favorite nums. Now here's the interesting thing is favorite nums. Oh no. Favorite non stop first. So first is actually a function template. But C plus plus in this context will figure out that it's a that it's a type two of int because he kind of wrote it up there. Right. So it'll figure out that this is the first function template instantiated at int, because you sort of gave the score away further up, right? So it figures it out. Um, and you can do you can take the uh, you can find out the second favorite doc and then you can do things with it. And um, if for some reason the compiler can't figure it out, you can always specify the parameter. So in many cases it's optional. Sometimes it's not optional. And the way I tell is I write the code. And then if the compiler complains I put it in. It's sort of like, all right. It's so cool because you've been doing this all along.

Um, yeah.

All right. Um, so here are a few notes. About ten minutes. Um, just to, um, you can write class instead of tightening. And it's important for you to know that because you will see examples where people write that right. If you go on the web, you'll see, you know, people will write class in there. It's not a different kind of C plus plus C plus plus allows you to um, there can be multiple type parameters. Didn't I have an example of that somewhere? I feel like I put that in the slides. Um, anyway, just like you can have multiple function parameters, you could have zero, but then why is it a template if there are no template parameters? Um, so you can say um, Ellen type typename. Ellen type. Um. Oh I know type name key type type name. Value type. Right. So STL maps will do that. It'll be templated over two type parameters. The type of the key and the type of the value. So that's very common. You Sam here's what's even is you can have non type parameters. And this is. This is nuts. And this gets into the territory of metaprogramming, which is fun and interesting and not really on topic, but because it's allowed. I'll just tell you, I'll just point. I'm just pointing out it's about how how you might find it useful. I'm going to leave it here. Um, and of course, if C plus plus can't figure it out, then you can always trust me. Now there is some bad news because, uh, um, there's no free lunch. Um, okay, so the news that's worse to me is if you do this, you pretty much have to put all the code in the in the h file, which we have been beating into your head that you should never do in 11 and 15 and 40. And here we go. It's got to be in there. It has to be in there because you can't compile a template until you know what the type is. For example, how much space should be set aside for each of the parameters and the template function. If you don't know what the type is, how is the compiler to figure it out? It doesn't know, so the compiler cannot compile a template unless it knows what all the types are. So you can't. Um, there's a weird trick where you can tell the compiler you can put like at the bottom of the file. Um, go ahead and pre-compiled versions for this thing with the parameter into the parameter string. And you can do that. But then it's back to ad hoc polymorphism again. So if you want it to be generally useful in the way that they are, you have to put everything in the header file. This drives me batty, but there you go.

Uh, this is why in calculator, when we were given that data file, we just had the data file and not like a data cpp file.

Um, it's.

Not related to templates. No, that's because I wanted students to. I wanted students to realize that they can program against the interface without looking at the code. And in fact, you do it all the time. But somehow, when it's when it's not built in, the students make it somehow weird and different. But it's not really different. It's normal. So I just wanted to give students that experience of which is true in industry, right? I mean, if you're using a Microsoft DLL, you don't get the source code for it. Microsoft considers that their intellectual properties, they give you documentation, and then you call the functions according to the documentation.

So if this.

Is it's like if you have to do this because, um, when you have the like class templates, like what? Why do we normally put the h and the cpp files as separate things. If we could just put them all in one file to begin with?

Okay. So so this is a fair question. So why did you beat us in the heads until we put them into separate files only to tell us we can in this case put them together. Key thing in this case put them together. If you if you pound include what we put into a cpp file. Generally you won't be able to link because you can't put the definitions in multiple files and then link them together. It's not allowed. So that's one reason. The other reason is we want to separate interface from implementation. So there's sort of an intellectual reason. Um, give clients access to the interface stuff, plus other things the compiler needs but nothing else, and then hide the rest from them. And some. For some of us, it's sort of a case of kind of mathematical purity and loveliness. And sometimes it's a financial decision. We don't want to show people what's in there. Right. So you put it in another file. Um, and that is the normal way for things that aren't templates. So the C plus plus standard library has a lot of pre-compiled stuff. And and that's not in the file. Those are in CPP files that get built when you do the install. So uh, I feel like there was another one. But anyway, um.

Another reason is that you only need to have separate header files and CPV files. You only have to compile the cpp file once, whereas the header file every time you include a header in something else, it has to read through the entire header. So separating it saves work.

Yes. So don't include is basically paste. Copy from this file. Paste here. That's what pounding means. And that means that it would have to be recompiled from scratch every single time. And so if you have a system that has like 10,000 files in it, and every file, you know, potentially has, you know, 100 of includes in it, then you wind up recompiling the same thing hundreds of times. Right. Um, so excellent point, excellent point. Um, and then linking can go a lot faster if you only recompile the things that need to be recompiled. Um, you often see the extension HPP which gets used for this. It's a header. I think Tempdb is probably short for template. Template.

No, um.

It's just it's ancient. Keep glommed together. Um, so you don't compile separately anymore. So, um. But that doesn't mean you shouldn't know how to compile separately. You should, unless you're using templates. This is an exception. The other reason to avoid using templates is the error messages are awful. Awful because you don't get a message about the template. What you get a message is this line in the middle of a 500 line template class has attempted to less less something, but I don't know how to less less it and oh my God. And so you get these messages that have tons of code that you've never seen before and had nothing to do with and wasn't part of your design. The whole point was to not worry about it. And here it is in your face. Um, so the error message is stink. And you've seen this already, right? You've seen these error messages as a result of the I o templates in the string templates. You've seen these messages, right? Has anybody written only programs that work? Uh, I haven't. Okay. Um, so the error message is really stink, and they stink so badly that I recommend, even if you want to do templates, that you go about it like this.

I should get rid of typedef.

Actually, because that's, uh, that's what we would do in 40. But in 11 you would do this. Um, so one way to make your code, if you intend later to do it as a template, here's what you do. First, write a mono morphic version. Mono morphic means one shape one time. So if you want to write a new ArrayList or hash table, um, make an assumption. Just say okay, the keys are strings and the values are structs that have whatever, but don't write string and struct whatever everywhere in the code, because you're going to have to change all that when you make it a template. So just think up a name for each one of them. But put this just say using Elm type. Is it? Using key type is string. Using value. Type is struct containing name and id number and whatever it is. Okay. Um, so and you should prefer this for my Mac uses something that's even older than, uh, C plus plus 11. I was compiling something a couple days ago on my Mac, and it wasn't compiling, and it gave me the message. Well, that's a C plus plus 11 extension. And I said it's 2024. That was an extension in 11. Come on, Mac, get with the program. Um, and then I said, okay, I told it to use C plus plus 14 or something. Okay. Um, so do that and that'll make the transition easier. And the reason you want to do that is when you're debugging. So you're not going to it's not going to be correct at first. You're going to have to debug. It's going to have errors. Do you want the template style errors or not? I vote not, so what you do is you make a morphic version. You prepare the name everywhere, right? Um, using the using statement up there. Uh, then you, uh, then you debug it. Once it works, then what you do is you put template type name, and then whatever you put in the using statement, you delete the using statement. And now everything is a template. And it worked right. All you got to do is add the template lines. And now it's a template. And just do that after it works. Um, and it's been tested. And then when you've done that then you can put everything in the dot h file. That's not too hard. Um, and you should document, uh, these things. It's a good idea to document them as you go. So right when you've written a function, you know, you've printed something or you've assigned it to an element of an array. So you need the assignment operator, you need the less less operator. It's a good idea to add that to the documentation. So, for example, if you look up, uh, ordered maps and the STL template, the documentation will tell you that these things need to be compared with equals. Equals and less than or less than or equal to. Anyway it says it says I need to compare it with these two functions. Give me a thing that can be compared with those functions. Right. So you just and it's easy to do it as you go. And it's hard to do it later because then you have to look over thousands of lines to find everything that might be dependent on the type.

Um, is this something.

That's enforceable or do you normally, just like, write a comment at the top of like template that would say.

That, um.

Interesting. You should say that. So it's not enforced. And so it just goes in the English documentation. However you're going to contradict me. Please do.

What's funny.

I was going with that actually. So thank you. Yeah. Um, so that's why I said it was interesting question. So, um, as of.

Uh.

Mostly, no, it's not checked. But there is a new there's a proposal. I don't think it made it into the 20 standard, but maybe it did. Did it did. Okay. I knew it was on the table, and I was thinking it was coming later. Um, but there's a way to have preconditions and post conditions that are checked by the compiler, and there's a way to write in the bunch that say, this thing needs a this, this thing needs a plus operator. This. They need a less less operator. So, so um, newer C plus plus is supporting that and maybe already does. I haven't used it yet. I just I saw a discussion about it. Um, so that's pretty cool. That is fantastic. So thank you. Um.

All right.

It's really complicated to use as, like someone who's writing a template. So it's nice for, like, the nice error messages. And if you were actually developing a library, you'd want to use it. But for, like, simple purposes, it's kind of complicated.

Yeah, I think you can do a lot more. So it's like programing by contract version minor stuff. Um, so it has like, uh, pre and post conditions and invariants that.

Hasn't been implemented yet and is a separate oh that's.

Okay. So I've been seeing discussion about that. So that's kind of okay. So maybe I was mixing them up because I know the second one is being discussed.

That might make the.

First class 26 zero.

Okay. Fair enough. So anyway what you need to know about templates I think we've covered. Are there any questions about that?

Okay.

If that's the case then what I want to do is have a moment of silence and then we will, um, um, I want to talk a little bit about Huffman at first. Okay. Maybe 30s or so. Um, I didn't tell you that. Um, the reason for the moment of silence is sometimes I understand I'm not a psychologist, but I understand that, uh, one of the. When you sleep and your body sort of figures out what you should forget. And what you should remember is that things you should remember, things where there were lots of emotional baggage associated with it and stress, good or bad. And it remembers things, um, where you did something and then you had to take a break after. So I figure maybe if we just take a break, it'll we'll remember things better. Is there another question?

Just another comment on something from earlier. Uh, just the the example of things that like where you would use an integer or you use a value in a template, arrays are kind of like that.

Oh, you mean for the length. Yeah. Yes. That's true. That's a classic example of something called dependent types, which I did a lot of research on. Um, so, uh, uh, yes. So that's a that can in fact, people have written templates for stuff like that. So. Good. All right. Um, so for Project Zap, you're going to need to learn about Huffman code. Um, and so we're going to talk about that today. And I think I'm just going to get you started sort of on where it goes and maybe set up the problem and then we'll stop there. Um, so, um, Huffman coding is a particular algorithm for encoding stuff, but what's the motivation. And the motivation is compression. And you guys have heard about compression. I think it's really important. The idea is that, you know, I've got this big gigabyte gigabyte thing that I want to send you. If I could squeeze it down and make it 500MB, that's still big, but it's a lot smaller than, than a gigabyte. Um, so we're going to do is we're going to reduce the amount of space that it requires to store or something. We can also transfer it more readily because when you're sending bits over a wire, you know, the more bits, the longer it takes. It's just it's simple. Um, so the idea is that if we have a mammoth thing, we can compress it, send the compressed form, and then the folks at the other end can decompress it. You do this all the time, right on. You know, so YouTube is streaming you videos and you know how it sort of will pick and it'll say, well, you know, 360, um, DPI resolution for you because because your device seems really slow to me. And I think you're a cell phone and so you won't notice the difference anyway. And so and so 360 dpi for you. Right? So, um, YouTube actually varies the compression during the event according to its sense of the network speed, which is sort of interesting. Um, and you guys know what bits are, right? Binary digit. Okay. So like I said, you use it all the time. You stream audio and video. Um, and if you're if you're a company, this statistic should make you very aware of your website performance. Thank you. Uh, if it takes longer than three seconds to load, people go somewhere else. But I'm showing the best cars. Three seconds. Man. Not worth it. Not worth it. Uh, right. And of course, we all use Skype and Zoom. Um, I'm not as tired of zoom as I was a while back, but still, you know, it's so, um. It's something that you should know about and use. Um, and there are two types of compression. Uh, one is called lossy, and one is called lossless.

Not surprising.

So it lossy means that you're actually going to give up information. So I've got this beautiful, beautiful gigabyte picture of a goat. I think whatever is going to come up in a minute. But you're on your phone. You can't. You don't want to gigabits. You don't want to dig a bit, you don't want to pay for it, and you won't be able to see the difference anyway on a phone. So we'll just say, you know what? I'll just send you every ten pixel.

Okay? Oh, it's a sheep. He sees a sheep, right.

I'll send you every 10th pixel or something like that. Right. That's that's lossy compression. If you get the compressed image, you cannot reconstruct the original. You don't have enough information. We're just going to agree that in lossy it's like this MP3's and JPEGs are like this. And I really hadn't realized how bad mp3's were. But gosh, many years ago now, I had some dance students who were getting married and I was working on their wedding dance with them, and they had a song, Frank Sinatra song. It's a great song, and they play it for me. I'm listening on the earbuds, oh, this is great. This is great. And so we're in the dance studio. We do some choreography. I say, well, let's put it on the sound system And the people who run the dance studio are like nuts for the audience. So they've got like, you know, $200,000 sound system. It's a big deal. I put it on. It sounded awful. Awful. It was. It was almost. It sounded. It just sounded like mud. You know, poor Frank was like, drowning in quicksand. And, um. And so, um, so when you're doing this, um, you have to be aware of who the audience is. And sometimes you have to be aware that the audience isn't a person. These days, if you're sending video images, um, now this is a bit Big Brother ish, but if you send video images from an intersection and you want to reconstruct facial data, there's a certain resolution that you just can't fall below, right? So the intended use is important. Um, I'm not going to watch you guys drive through intersections, so I'm not doing it, but but people do. Um, okay. So lossless compression is one we're going to try to shrink the data, but in a way that the client, the user or the client entity robot program, whatever it is, can reconstruct the original thing. Exactly. And you do this all the time, right? Do you ever use zip files? Well, you would be really mad if you zipped up, you know, all of your homework and the word documents were missing every third character when they came back out again, right. Lossy would not be acceptable in that case. Well, if we're not going to lose information, how do we shrink it? Well, we we we take advantage of the fact that often the encoding scheme is repetitious in a way. Mhm. And that's where Huffman coding it comes in. It's for particular applications in that space. So um what is encoding. Encoding is depicted and represented in some other way. Decoding means to take that other way and reconstruct something resembling the original output. So we're going to encode it. And of course, you guys have already heard that, you know, if you say abracadabra and you store those. If I stored this as an array of char, it would look like this, right? Everybody instantly recognizes this. He said with some sarcasm. That was sarcasm. I don't expect you to memorize that, but you know that it's encoded in bits. And it turns out this is actually what's in there, because I couldn't live with the fact that it wasn't. So how does it how does it do that? Well, if we're going to encode information and other people are going to share it with us, we need a standard. And one of the earliest ones, dating back to the 60s, is the American Standard Code for Information Interchange, ASC, II. It wasn't the only game in town. IBM use something called M civic, which stands for Dead Civic, I don't remember.

Um.

Binary, I don't know. Um, anyway, um, but Ascii became very popular and the American standard code. So this is where we sort of decided that. Yeah, yeah, maybe there are other languages we're not too sure. So, um, and it was very targeted at like, English language and typewriters and business applications of the day, plus some other network control stuff. That's for another day. Uh, the original Ascii code only had 127 characters in it. Bless you. So we don't really need eight bits per character, one byte per character. We could use seven. Um, if you store it in eight and eight bit units, then the the leftmost bit is always zero for the for the true. And then we've extended Ascii, you know, puts little dingbats up on your screen. Um, I don't know if I don't think they're still called dingbats. That's what they were called in the 1980s. Those little playing cards. Um, I.

Guess.

Anyway, so we still use Ascii today, but we did discover the existence of other languages. And so there are other encoding schemes. Um, typically like Unicode will take two bytes per character. Um, and there are tons more things. Right? If you guys haven't seen the poop emoji yet.

Then.

What are you doing here? All right. Now we've all seen this. Okay, so, um, how you encode it basically is. Well, you know, honestly, you type the glyph in your keyboard and there's an encoding that goes back to the computer and, you know, the shell or whatever can can take that encoding and convert it to Ascii. Right? So you just basically it's just a table lookup. You just look up your character in there. And if you want the whole table, here it is. Um, so this is just the, the seventh index, right. That's the whole thing. And so abracadabra. And it was a lowercase a right. So lowercase a was lowercase a. Uh there it is. It It's, uh, um, it's 97, but 01100001 and B is the same thing, except the last two bits are one zero instead of zero.

Thank you. Now, if, um.

If you encoded it, you know, as each character per byte, then you would have eight bits per byte. Their 11 characters is 88 bits. If we said, okay, we're going to compress it by removing that bit that we know is zero, we would have 77 bits. One because we have seven bits per character.

Um.

Okay. I'll get through. Decode it. Yeah. Oh, this will be good. So I'll get through here and then we'll we'll stop here. Um, okay. And so we've encoded it. If we want to decode it, then we have to know that the person who sent it was leaving out that bit, and they were sending us a series of seven bit chunks representing Ascii characters. Right? And then we could just count off seven bits, look it up in the table. We have to share the table. Right? Because otherwise how do I know. But Ascii is widely shared. That's standard code you know. So we all agree that that's it. So you just take it. You break it up into seven bits. You'll learn how to do that in com 40. We won't do that necessarily. Here. Um and then you can map it back to abracadabra. Okay. So we've got uh we want to we want to store and send data. We want to shrink it because we don't want to pay for space or time. Um, we can we can reduce the amount of stuff, the amount of data by forgetting things lossy or by being being smart about how we take advantage of repetitions in the data. And we'll see a particular algorithm for that next time. Okay. Have a great weekend everybody. Thank you.

What? Are your thoughts? In the morning. When? The story begins. Yes. Yes. But I don't want to extend. It. No, no, no. But we don't get to be with the cool kids. No no, no. I'm. One of those on my first mission. It's my first mission. I don't know much about age, so I just used up and used up observations for. About 2.5. Seconds to send an instructor. And then I won't be able to do it to, like, later tonight.

And so you don't want it at 11 p.m.. But one of the things you want I'm happy to have them send also. And if I find time I can do it too. But you know, more people.

Better luck. You know, if you want, you can leave it on the side.

Of.

Nothing. Um, it's a matter of understanding.

Yeah. So.

Uh, when we come back.

We've got, like, four days, and then you come back again.

Like I used to know the summer.

I forget like, November.

5th, right?

So it's it's right up against Election day.

Yeah.

Right before. Um. Okay. So, uh. Yeah.

But, uh, I think.

So we're going to talk about the.

Midterm.

Generally, but honestly, I haven't thought much about it because it's going.

To sort of have a, you know, what.

Sort of calendar is this all the time. So. There'll be some programing probably on the this how much programing. It takes time.

So just a tiny.

Little lab function, maybe a lab function is sort of a good size amount of code to write. Some might ask you to program 2 or 3 things like that. Um, you know the concepts, the slides are good, but the slides, the labs and of course the knowledge and skills from the homework. So, you know, I can I can ask you sort of mechanical things like how do you copy files and how do you how do you compile and administer that stuff like that? Um, if there's anything like that, that'll probably be a few people. Not not a lot of points, but um, so just kind of but if you understand sort of what you've been doing, then that will inform some of the questions. And, um, I know the complexity stuff because that hasn't really shown up in the homework. So that's a good thing to be aware of.

It seems like it's not always like, you know, you there's like a really it's not.

I can't promise if you don't read the book you'll be fine. But so you've used that to however you think is appropriate for you. Um, I generally don't hunt through the book for questions. Yeah, but if it would help you to look at it, you should write. Do you know what I mean? It's. Yeah.

Yeah, yeah. So there's like the basic like to understand the big picture. Yeah. I want to bring that out.

Okay.

Yeah. So post the instructor message to Piazza because.

Somebody.

Spoke to you on Sunday. Please do.

Yes. Okay. Thank you. And let me know if you have any trouble. I mean, I just looked and saw a submission for, like, the check off, I think.

Yeah.

So as far as I can tell, things are coming in, but I don't know if you're doing it. You're doing okay.

Everyone. Okay.

Thank you. You're welcome. Hey, guys. What's up?

I'm going to unplug. But you. I think.

You're first. I have a silly question.

I was kind of under the.

Impression that not.

Just the fire engine that people use when they're writing H files for C plus. Plus.

I was referring.

To what could.

Be. It may be different.

Yes, I think so. I personally have used HP specifically when.

I'm doing temperatures, but.

As you say, I'm not I don't claim to be representative, but I'm also not alone because I got that. So I don't know how widespread.

Um, hey.

You know, the, uh, even the TPP, right? People have written the suffix c plus plus. A lot of people in the olden days used to write the capital C.

But, uh.

It could be. I don't know if I've seen that as a suffix. We used that in the in the relevant environment.

Yeah, but it doesn't even matter.

And you, could you, like, name your file like, like a file header and then just include it as a header file, even though it's not really a file. Um.

I'm not saying I don't know how.

How much modern tooling business, but the Unix, the Unix philosophy is that the file name doesn't matter, and the extension is strictly for humans. Yeah. And there are very few cases where Unix cares is one.

And.