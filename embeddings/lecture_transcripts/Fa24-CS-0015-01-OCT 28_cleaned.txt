Um, so a little bit of information about the midterm, which is one week from today. Um, I know everyone's looking forward to it for, uh, stuff about Huffman code. Um, I think I'll start with the midterm stuff, actually, because folks stress about it. So, uh, hopefully this helps reduce stress and not increase it. Um, so, um, you may have noticed that there's a midterm one week from today. What? Yes. Uh, no. Yes. Um, which is the 4th of November, the day before the election? Um, which we have off at Tufts and the official CSE 15 policy is that we encourage participation in the democratic process. So, uh, if you are an eligible voter, I encourage you to do to to do that. Uh, if not, then just have a big party. Um, you can have a party if you're a voter, too. That's also fine. I got my sticker the other day, I already voted. Um, okay. Uh, so there's a midterm, and it'll be wonderful and exciting. Uh, and, um, so the first question and an eminently reasonable one is what is coverage? So we always I just, you know, I look at the calendar and sort of draw lines. So it's everything up through and including the, the compression stuff we talked about last time. So I can ask about file compression. But the Huffman coding stuff with Huffman trees, which we did not talk about last time, but we will talk about today, is not going to be covered by the exam. So the exam goes up through last Wednesday. That's the that's the coverage. Um, okay. So um, what will it be like? Well, it'll be exciting, of course. Um, It's on paper. Um, it will be in class. You come here. Uh, or you should go to the section you're registered for. Okay, so I don't want, like, 100. I don't want this room to be empty at this time period. And then everybody shows up for the next section because we're not going to. It's not going to work. So don't do that. Um, if you're registered for the 130 section, take it at 130. If you're registered for the 430 section taken at 430. Um, and so go to the section you're registered for. That's up here somewhere. Yeah. Here it is at the bottom. Uh, so it'll be here regular time, regular place. No special place, no special time. Um, for the final, I might try to get a different place because I think the auditorium seating isn't so good for exams. Um, but for the midterm, it's a bit of a pain to find the available space, so we'll. It'll be here. Um, you'll have 75 minutes. Usual time. Um, it helps to come a couple minutes early because, uh, um, I will try to start the exam promptly at 130. And so coming late means you have less time to take it, because we will take it at the end of the class. And there's another class in here afterwards. Right. So it's not cool to have folks stay for the exam here in the next class. Um, so I have 75 minutes to do it. Um, you'll write it with this device here known as a hand, and you'll use things known as pencils and pens. Um, if you're unfamiliar with these devices, I encourage you to practice over the next week. Um, uh, closed book, closed notes. No electronic devices. You don't need a calculator. Um, any arithmetic. And remember, big O is like throw away constants and. Right. So, um, so what do you need a calculator for? For stuff like that. You know, I need a calculator to erase 35 from this expression. No, you don't just erase 35. It's not hard. Um. So you want me to calculate our electronic devices? Um. No. Friends. Uh, please don't wear earbuds and stuff like that. Um, don't come with, like, a satellite dish or, uh. Um, or. I was at a conference once and someone told a great joke because he had an open book exam, and the students were like, well, can we bring this or can we bring that? He said, anything you can carry in, you can bring and that'll be it. And so a student came in carrying a Ta with him. You can't do that. Uh. Yeah, I know, of course somebody would do that, but I wouldn't have thought of that. They let him take the exam with it, you know. I can't remember what he said. I was laughing too hard. I don't know what. I kind of missed the next couple of minutes, so I don't know what happened. Um. Fair enough. I think it was a joke. I don't think they intended to use it, but who knows, right? Um. All right. But in your case, closed. Closed notes to us. No electronic devices, um, no cell phones, all that stuff. Uh, you know, it's an exam you've taken. Actually, maybe you haven't. Uh, because, uh, unfortunately, during Covid, we lost a lot of things. However, there is one thing you can bring to refer to during the exam. Um, and that is you can take A18 and a half by 11 inch sheet of paper, and you can write anything you think that would be helpful on it to use as a reference. Basically, you know, I don't want the exam to be like a, um, if there's a thing you don't think you'll remember, write it down on the piece of paper and that'll help you remember it. Um, sometimes students write cool things there, you know, like, uh, you can do it. Go. Whatever. So that's also cool. Anything you think will be helpful on the exam, you can write on there. We will take it up. So please, you know, keep it clean because we may look at it, um, but otherwise we won't judge you. So write anything you like there. Um, if you would like to have it back, if you'd like to get it back. Putting your name on it might be useful. But I do look at them because, um, I often after the exam, I'll look and I'll say, well, what did students think they should study? And I just, I just I didn't read them all in detail, but I kind of skimmed through, uh, there was a question, I think. Yeah. Are we allowed to, like, write it on our iPad and print it out or, um, by hand? Well, so, yeah, so the the original. So here's a thing. Um, writing things by hand actually helps you remember them better. So there's a there's an interesting paradox of the human brain, which is that, um, if you if you think about something deeply and you condense it and you write it out by hand on a reference sheet, you don't need the reference sheet because now it'll be in your head. And so you're like fast. But if you don't do that, then you will need the reference sheet. So it's like if you make the reference sheet you don't need it. But if you don't make it, you do need it. So just make it. And then it's there as a security blanket. Or if you do forget something, you can look, I guess I don't mind. I do recommend that you write it by hand, um, and that you write it yourself. Um, we actually have a word for it. There's a word for when you take a body of information and you think about it, and you, you condense it and you reorganize it, and then you record it. There's a name for that. It's called studying. And so sometimes building the reference sheet, the build process is the most is often the most important part of the reference sheet. And then the sheet itself is just when I had these as an undergraduate, it's mostly a security blanket. It was occasional. Occasionally there was a time I would look something up on it, but mostly having made it, I didn't need it. So the answer to your question is, can you write it on an iPad because you really dislike writing on paper. Yes, but you can't refer to the iPad, so you have to print it out. Um, and consequently you can't you can't print someone else's notes because just like I can't learn to ride a bicycle for you, I can't study for you. So it should be your own notes. Your own notes, not somebody else's. Um. You can use both sides. Um, you'll turn it in. Okay. So any other questions about that? I think when again, when I was an undergraduate, I could write very small. And at that time I didn't need these. So I used to pack them full. But you don't have to. You do, you know, you do the things that will be useful to you. Um, this should really be sample topics because. So here's the thing. Students often say what are the topics? If you go on the calendar, they're listed there, right? I mean each topic is there. It's right there. So, um, I'm not claiming this as complete. I just sort of I did I looked at the calendar and stopped last Wednesday. So for example, data compression is here, but Huffman trees are not. Um, uh, yeah. So we looked at two different kinds of lists array lists and linked lists. You should know. You should know how to implement them. You should know but you should know use cases. Right. So, um, you know, advantages and disadvantages. You should know big old kinds of things. Um, you should know that, uh, um, inserting into the middle of a list is order n, but for very different reasons. For lists and linked lists, um, you should know that adding at the beginning of a linked list is constant time, but adding at the beginning of an array list, the way we implemented it is linear. So you should know stuff like that. Um, while I'm talking about Big-O complexity, um, we don't talk much about space, but I guess it could come up. Um, but so you should know about Big-O and complexity analysis. Yes, sir. Would you say that this.

Is an exhaustive.

I said it is not exhaustive. Yeah. Um, because I don't pretend that I, uh, I skimmed the thing, and so it may. I may have missed something.

You said Huffman trees are not on the exam.

Correct. Huffman trees are not on these. They're not up here anymore, are they? I took a list that somebody else had done, and I. And then I modified it. So that semester, they covered Huffman trees before the exam, and I did. Um, well, I did, but I'm going to stop before trees are today, so we will cover them before they're not on the exam. Huffman trees are not, um, QS and stacks. You should know all about them. Um, complexity again and see what I mean about it. So complexity is there twice. Um, recursion, of course, you should understand recursion. Um, I can ask you to write a recursive function or read it, understand one, or, you know, sketch out a memory diagram for one or something like that. Uh, you should know about binary search when it applies, when it doesn't, what it is. What's the basic algorithm? You should know that it is order to find an element using binary search in an array. Log n. Is it sorted? Yes. It needs to be sorted. And there's another requirement to two requirements sorted and. Oh okay. Three requirements comparable. Sorted variable. Yeah. Um well the third one is you need constant time access to a random element. Right. So you can't have binary search in a linked list or you I mean you can, but you don't get log n because how do you get to the middle of a linked list? You take order n over two steps. Right. So, uh, okay. So you should know about that. Um, you should know that there's a big three kind of what they're for, um, how they work. I'm not going to drill you hard on syntax and stuff like that, but you should know what they are and what they're for, what problems they solve. Um, and, you know, if I gave you a buggy program, you should be able to tell what the bug is. Um, trees love trees. Tons of stuff on trees. So all the vocabulary. Parent node. Child nodes. Sibling nodes. Ancestors, descendants. High depth leaf, internal node. Oh, God. You know, not all the all those terms. Um, I might ask you for a few of them, but the big thing is, I feel free in a question to just say, you know, write a function that examines all the leaves in a tree and does x. And I don't expect anyone to have a problem with. What do you mean by leaves of the tree? Right. That should be, um, right. So, um, I mean, I could ask a fill in the blank about it or something, but about vocabulary. But you should know it because as computer scientists, we use the vocabulary. So you need to be part of the family. Um, you should know about binary trees. You should know about general trees. Binary trees. Um, so you should know that there are no trees, but binary trees we spend a lot of time on. So you should be very familiar with those tree traversals in order. Post order, preorder level order. Right. You should know about those, um, binary search trees. You should know that they, uh, you know, they were the stepping stone to efficient o. Access to something else is not on here. You should know about key value pairs, right. Um, because that's kind of what our motivation is for a lot of these things. I've got keys, I've got values, and I want to be able to look up the key and find the value, or update the value, or ask if a key is in there or something. Um, so you should know that key value pairs binary search trees. Um, which if they're not balanced, our order, you know, most of the operations are ordered in, but some operations are always ordered. Right. Print all of the nodes in a tree. Well, that's order number of nodes in tree. It can't be best. You have to print every single one right. There's no get not print half the half the nodes in a in a tree if you have to print all the nodes. Right. So um, you should know about traversals. You should know about the complexity of those binary search trees. And of course, here's where we had our big, um, revelation, where we had a self-balancing tree. So you should know about labels and rotations and, uh, uh, if you're asked to stand up in the middle of the exam and do the dance, you should be able to do that. And I would do it. Um, but I won't ask you probably about removal. It's it's a little bit complicated, but it's not that complicated. But anyway, if you if, you know insertion, you're going to be doing um. I'm promising, because I have not yet written the exam. No one. I don't think anyone has ever gotten an advance copy of my exams because I have a secret. I don't finish them until, like, 5 a.m. on the day they give. So that's why I don't like it. But it seems to be the way it works. Um, there was a grad student taunting me about this very thing just the other day. Um, I said, oh, 15 has an exam. He said, when? Mondays. And so do you want me to drop by and visit you Sunday night? I said no, sorry. Um, okay, fine. I oh, again, generally. Generally, um, program building. And, um, I'm not going to ask you to write the rules and the makefile, but you should know how to build a program. You should know the difference between compilation and link y, because not knowing those things cost you an enormous amount of time. So you should know these things. Um, but not a big part of the exam. They'll be, uh, templates, universal, uh, polymorphism and templates. And, you know, we talked about ad hoc polymorphism. So just generally, you know, review the notes and be good on the topics. I know you haven't actually written programs where you've written the template. So the questions would probably be somewhat general. Maybe show you an example or something. Um okay. So questions about about topics. Um so types. Um, so the ultimate rule by the way, for uh, whenever you ask about exam coverage, um, I always think about a stop date and then my view is anything we talked about in lecture or in lab or in an assigned reading or in the assignments or anything, you can reasonably be assumed to have learned in the process of engaging in all those activities. So, like we didn't teach you how to use Clang plus plus. But come on, how many times have you you should know how to use clang clang plus, right? You should know how to use the CCT command because you've been doing it every single week, even though we didn't really. You learned it in 11, or if you didn't learn it 11, you learned it somehow because you're doing it every week. Um, so those kinds of things are fair game. Again, not a lot of time on it because the exam is only 75 minutes. I'm not going to want 20 minutes under the CP command. I'm not going to do something crazy like that. Um, but what types of questions? Well, um, there will be a program, so I just want to put that front and center. I promise you, uh, one or more programing problems, um, you will write in C plus plus, not JavaScript or Python or some other thing. Um. Uh, minor syntax errors. You know, don't stress about. Don't leave out all the semicolons. We want to know that you know C plus plus. But if you miss a semicolon, you know we will do our best. If you make it clear what you mean. And it's C plus plus and we can figure it out. Um, you know, we're not going to doc you for for every minor infraction, um, we care. We want to know that the logic is there. Um, usually there'll be some spec, you know, write a function that does x, write a function named f that does a tree traversal and computes some function of all the stuff in the tree. Right. Um, usually the scale of a of a function. I would ask on an exam, I can't ask you, you know, write an RPN calculator during the exam. That's that's not reasonable. So, um, a good place to look at functions that are about the right size to appear on an exam or the labs, the functions you're asked to write in labs are excellent examples of the size of the function that would appear in on an exam right there. They're all like, you know, 1 to 10, 12 lines long. They're about that complexity, you know. Um, so those are good examples. How can I practice writing code for an exam? Well, first of all, um, but I just type, well, you know, it's going to happen, so get out a piece of paper or a whiteboard or your iPad if you. But it you can't be freaked out when you change to paper, so you have to you should practice at some point. Um, and set yourself a what if problem. Look at it. Look at a lab. Quick question. If you didn't do it, hey bonus, you've got a great practice opportunity. If you didn't get to it in life, write. Write it now. Time yourself. So most of those should probably take. Um, depending on the question 6 to 12 minutes on an exam. so just get a bunch of people together. I'm a big fan of study groups, get 3 or 4 people together, but you use your study group well, right? A bad study group is where everybody watches one person study well. They just drink beverages of their choice. That's not a good study. A good study group is one where you get together, you review the material, you ask questions, answer questions. You can do example problems. And the way you do a programing problem is you all agree we're going to do this thing from the lab or we did this question in the lab. But what if they had asked us this other thing that's similar, but it wasn't in the lab right. Play what is propose a spec right. Get a function spec, then set a timer for whatever. If it's a you know, if it's a very short function, 5 or 6 minutes. If it's a longer function, maybe ten 12 minutes. Set a timer. Everybody works for the until the timer goes off, at which point, if you're not done, you keep working when you're done. If you took longer than the timer, that suggests that more practice on this topic might be useful doesn't mean you're a bad person. It doesn't mean you're evil. It just means a little more practice might get you in the right. It might get you up to speed. Um, but then you can compare answers. And this is why I like study groups. Because you'll make mistakes. I make mistakes all the time. But you won't make the same mistakes. So if I do it by myself, I might not even notice the mistakes. But if I study with someone else, they'll point out my mistake already. That's an advantage. But they will have made a different mistake, which I make mistakes. And now I have seen two wrong ways to answer the question. In the time it takes me to write one. So that's that's like a multiplier study. So I'm a big fan of using groups. And as long as you use them well, study groups can be really powerful. Um, okay. So what else? Um, and there'll be other things too. So, um, all the usual suspects, you know, fill in the blank, you know, I'll write the definition Of, you know, a blank is a node in a tree that has no children, no subtrees. That is a leaf for two points. There you go. Um, right. So, um, uh, modularity, uh, all this stuff so I can ask sort of fill in the blank stuff like that. Um, the other side of a fill in the blank is I give you a term or an idea or a concept, and you give me a definition or an application of it. That's a short answer. Um, there'll be multiple choice. Pick one of these things. They'll be check all that, apply all the usual. True, false. That's another one, you know. So all the usual suspects. Um, any questions about that? Okay. What else? Okay. I don't know if I would say full exactly, but there are practice questions in the slide. So that's a good place to start. Um many of these are good candidates for exam questions. Many of them came from exams. At least the ones I put in are often old exam questions. And that's where that's where I that's where I get them from when I put the exercise. Um, we we already released the practice questions, but they're certainly they're, they're on the calendar for today. They've been released since last week. Um, look at the homeworks and the labs. If there's anything you didn't understand, you know, get those questions answered. Um, all that stuff, you know, we're here to help. So, um. Um, so there'll be a review in lab tomorrow. So I encourage you to go. Uh, before lab, it might behoove you to write down some questions. We already surveyed you and and got, uh, recommended topics for the review. So we collected those that, um. Um, Kathy, one of our teaching fellows, shared the list with me. Looked like a great list. Um, and so I get it just a little bit on it. And, um, otherwise, though, it's very you driven. So don't just sit there and go, you know, drill a hole in your head and said, pour exam information in here. Um, come and ask questions. I wish I could do that. Well. Please don't drill a hole in here. But, uh, I wish that there were a thing, like, can you can I just do the download? You know, like, uh, like data and Star Trek? I'm downloading all of the information. That would just be awesome. All right. Um, so any other questions about the exam? Take a big breath. Ah. It's going to be good. It's going to be good. I hope. All right, so I have 15 minutes, which I can do. Um, all right. So we're going to continue with our topic of Huffman coding, which will be important for the next project, by the way. So it's not on the exam but it's neither is it ignorable. Um all right. So last time I'm going to breeze through the first part of this because the first few slides are kind of what we did last time. So I just want to remind you, um, so Huffman is a person and what what are these? Uh, uh, what is this technique all about? Well, it's about compression, and we need we want compression because we want data that's in, you know, a file of a certain size. And we want to make it take up less space, either to save disk space or because we want to transmit it to someone else. And we don't want to pay the huge fees on our cell phones, or we don't want to pay the time waiting for it to download. Right? So you're listening to Spotify and it's sending compressed audio to you, because if it's in full CD quality audio in an uncompressed way, you wouldn't be able to listen to the music. You'd have to wait for 5 or 6 minutes to download a song, and then you do this right. So if you're going to stream it, it has to come at a rate that's commensurate with the plan. And so it needs to take up less space. Um. Yeah. So just if you care. So CD quality audio is 44,100 samples per second. Each of those 44,100 samples, it has 216 bit channels. So 32 bits times, um. 40,100 times a second. Oh my God. Yeah. So that's that. That would be CD quality sound. You're not getting that from Spotify. You're not getting that from YouTube. Right? Right. Um, yeah. So we already mentioned this last time, and it's a useful thing for you to know. We distinguish two things. Uh, two approaches to compression that are, um, important categories because there's a lot of work in both. Um, lossy is the kind of thing that's usually done with audio where you think a human is going to be listening. Um, humans hear mostly within a range or about 20Hz to 20,000Hz. I had some hearing loss as a child of mine, and now I'm getting older, so I'm probably topping out around 17,000Hz. Maybe. Maybe not even I don't know. Um, and so if you know, people can't hear certain sounds, you send it to them, right? That's that's one approach to compression. They can't hear it. It doesn't matter. Or if they're playing it back through earbuds that can't reproduce sounds. Why send them data that they even if they could hear but their device can't reproduce, don't send it right. So, um, compression uh, is often done that way. And we call that lossy compression because the data that arrives at the other end is smaller than the data that we originally had, but they can't reconstruct the original data because. It's impossible. And.

They're watching something on YouTube or whatever that YouTube can be like, oh, they're they've you know, this device's audio is being directed to some earbuds that can't produce this. That seems.

No, that's an assumption that they often make. But YouTube There's in general, they can't know. I mean, you could make a protocol where you say, what device are you playing on? And then but it doesn't do that. So it just sends the data to your computer. The thing that YouTube does is it monitors network speed and it will compress more or less depending on your network bandwidth. And it might know whether you're a mobile device or not, in which case it might compress more in that case. But, uh, um, the only point we care about today is that one approach to compression is lossy, and we're not going to talk about that today. Huffman is about loss. Less lossless is you're going to compress the data, but the person who gets it could expand it again and get back exactly fit for bit the original data. That's called lossless. Oh yeah. So there's lossy. I think you can tell which one is more lossy than the other is um, and. Yeah. So. So Huffman was apt to do this kind of lossless compression you care about. I think I mentioned last time a zip file does compression and you wouldn't you wouldn't like it if zip through a, you know, certain characters in your program or lost data in your images, you know, you zip is supposed to give you it puts a bunch of things together, but it also compressed, tries to compress, and it can do a pretty good job. Um, so without further ado, let's, uh. Oh. So a little bit of further ado. Um, so let's talk about, um, data encoding and decoding because that that's where the rubber is meeting the road here. Um, if I'm going to send you information, we have to agree on how I'm going to represent that information. Right? I'm going to I'm going to take a picture and I'm going to scan it, and I'm going to break it up into pixels or, you know, intensities as measured on some, Some hardware device, and then I'm going to break it up into colors, you know, because I've got different kinds of sensors. We will agree that I will send you, you know, 24 bits per color, three colors per pixel. And one of those things for each pixel in the image. And I'll tell you the width and the height. Right. We have to agree how I'm going to represent the information. Taking that information and producing that representation. That's encoding taking that representation and then reproducing the original thing that's decoding. Right. So we're going to end. So anyone who's addressing this has to solve the encoding problem and the decoding problem. Now we have a lot of straightforward ways for encoding data in computers. And you guys have seen a lot of string data, which is a sequence of characters. And the characters by default, the simple ones fall into what we call, um, the Ascii code, which we'll talk about in a minute. And in C plus plus you store eight bits per character. So Abracadabra as a string has 11 characters in it. And so there are, um, eight bits per byte, one byte per character. So eight times 11 is 88 bits. It's 11 bytes, 88 bits. And those are the 88 bits for this. Uh, again, for simple things, not including other languages. Um, because in the US, we didn't discover the existence of other languages until the 1980s. Um, we, uh, um, we just have these, these 128 characters or the simple, basic Ascii characters. It was a question.

You know that a bunch of bits that is reading is. And Ascii code, for example. And, uh, like it just.

There's no way to look at bits and memory and know definitively what they mean. You can take a guess. You can say, well, if they're a floating point value, it's not a number. But if they're a sequence of characters, then it spells out help.

The computer then know in which context to like. This is a color and this is a character.

It all has to be prearranged as part of the communication. There are so-called self describing data items where you send a block of text at the beginning that says this is an XML version, blah, blah, blah document, you know. Um, so there are things like that, but there is there is no definitive. Symbols have no inherent meaning. None. It's all by agreement. So, for example, here's a character. What is that? It depends on the context. Right. We have to have a shared context. could be a minus sign. Here it's a bullet and a bulleted list. Could be the Chinese character for the numeral one. Could be. Could be a hyphen in the middle of the word. Right. I mean, so, um, this is a very deep topic and, um, it's very tempting. So I sort of want to skip it for now. But the thing is, the interpretation must be agreed upon by the parties somehow. And if you're doing a streaming protocol, then when you set up the protocol, often, you know, your browser will say, well, I know how to interpret these. And the and the server will say, well, I have these. And, you know, and it's even called a negotiation. The two pieces of software share which things they have in common and then communicate using those. So take the networking course. It's a wonderful, wonderful, um, collection of things. Um, so here's how you can encode Ascii characters. Um, you can just look them up in a table. And if you want the whole table for the first, uh, the simple Ascii, um, it looks like that. Now notice for simple Ascii there are 128 characters, but there are eight bits which have 256 possibilities. The first bit is always zero for the for the simple characters. Right. If we're going to do other things, that's different. So one way to encode data is if I've got a bunch of letters, I look them up in this table or you know, if somebody hits a key, there's usually a ROM there that takes the key and maps it to a binary code. Um, I've actually implemented one of those. It's kind of fun in a quirky sort of way. Um, okay. So if we just do that, then what you do is you take the bits and you put them together. Now, still, somebody has to say how long it is. So there's an extra data here that says there are 11 characters. Right. And then we would do this. And here are the 88 bits. Right. So that's just a straightforward rendering using Ascii.

Would you not be able to deduce the length of the string by dividing the length by the number of bits per character?

Well, the problem is you don't even know when the transmission ends. Okay. So usually what happens is in a network protocol, there'll be a thing that says I'm a message or this type protocol, this version, and I've got a payload of this many bytes and here they come.

That's, that would be a header.

That's a header. That's what a packet header has in it. Yeah. Exactly. Um, now because we're using simple Ascii here, we could leave out that bit. That's always zero. And now we're down to 77 bits. But of course that's not the way they're represented in C plus plus in memory. So to decode them you would have to look up. You would have to break it into seven bit units and then store them one seven unit per byte in a C plus plus. And so to decode if if I know that it was encoded as a sequence of seven bit codes, then all I have to do is break it up into seven bits and then do the same table, but look it up in reverse. Instead of taking the letter and looking up the bits, I take the bits and look up the letter. Right. Does everybody understand that? Okay. So here is the cool thing. Notice that this is assuming that all the characters have the same length in their encoding. And what's Kaufman was doing was saying, well, um, we're going to use this thing called a we're going to break that assumption. We're going to say we are going to use variable length things to represent code. So the letter E might not use the same number of bits as the letter z. And I think you can see where that's going. And the second thing which is related to where we are in the course, is we can build a binary search tree that has the letters in the leaves, and then we can find the direction through the tree and use that to encode the path. Now, if that's not clear, um, we're going to do we're going to fill this out a little bit. So here's the idea. Um, we could just have a binary code like this, you know, for A, B, C, and D, and then we could make a tree that says, well, you know, zero goes left and one goes right. That's the usual convention. So we could do that. So this is one way to build a tree. Given a representation of letters as bits, we could represent the letters as leaves in a tree. And the bits are the path through the tree. Every time you turn left it's a zero. Every time you turn right, it's a one. So you could think of A as left, left, V is left right, C is right left and D is right right. Okay. Now, it may not be obvious that this is useful, but it's going to become useful. Uh. All right. So here's the. So let's take our example of abracadabra and say, okay, we went from 88 to 77 bits. Could we do it in fewer. Um. But and okay, the answer is maybe we could and we can use sort of a couple of observations. One is we don't actually use all the letters. So in that sense we would only really need. So we have five characters okay. So I only need to distinguish five things. So two bits distinguish four things. Three bits distinguish eight. So I could actually go right down to three bits. Because with three bits I can represent eight possibilities. If I only care about five possibilities five is less than eight I got it 33 bits. Right. We've just shrunk it again. And we can pick them arbitrarily. Um, and encode with 33 bits. Cool. We still haven't gotten to Huffman yet, so this is just all. We've noticed that if we're not using all the letters in our message, we can actually use something smaller than the full Ascii code, right? Because we're not using all those 128 characters. Backspace isn't one of the things we're trying to represent, for example. Or my favorite, my favorite Ascii code is seven. Does anybody know what seven is? 00000111. But it's the Bell character, which on the old days when you had like things that would type the thing, it would ring. And if you were sending data to someone and you wanted to get their attention, you could ding. And so. And to this day, if you print it, it will make a sound in a terminal that has sound on the. Unfortunately, on the Mac, it's a very unsatisfying sound, but, uh, it's still fun. Um, okay, so that's my favorite asking. Um, okay, so we've decided that we can shrink the encoding by taking advantage of the fact that a particular message may not use all the Ascii codes. So we can use fewer bits, but it's even better because it turns out that some things in the message, some symbols are more frequent than others. If we could come up with a way to, um, to represent more frequent things, with fewer bits, we could save even more. And this is the space where Huffman was working. Okay. Um, so what we have here is a histogram of characters. And for the five characters that appear in the file, the A appears five times. B appears two times. D appears one time. In fact, this is generally true of English, right? So, uh, I don't surely you've heard that that's the. That's the mnemonic for remembering the, the first few, um, frequencies, the most frequent that is used in English. So, um, and if you look at Romeo and Juliet, the letter E appears 12,963 times. T is second place 9800 times. Right. So. So if we could come up with a way to exploit this, um, it would work. And the longer the text, the better it's going to work. Hopefully that's the idea. Okay, so Ascii is built on this fixed length encoding. But we're going to break that. Now we're going to say no fixed length. What we're going to do is use a variable length. This of course has been done before. Doo doo doo doo doo doo doo doo doo doo doo doo doo doo. Anybody heard that? Something like that in the movie. Morse code. Morse code works this way. Um, here's the coding for the letter E in Morse code. The shortest one. AI is doo doo doo doo doo doo. Right? Okay, so, um, Morse code is an example of a variable length code, and they did this explicitly. The letters we expect to be more frequent. We'll get the shorter codes and the ones that we expect to be longer. Doo doo doo doo get longer codes.

Do you know how to separate two letters?

Ah that's cool. So it's it satisfies this interesting constraint that. So that's a real problem. And we're going to come back to that. How do you separate the letters. I have a friend who speaks Morse code, and it's amazing. Um, so I'm a lapsed pilot. He's an active pilot, but he studied this stuff for his ham radio license. And so to this day, um, you can when you tune in and navigation aid, they have an ID usually that's a sequence of letters, 3 or 4 letters. And then, um, and if you tune it in on the radio, it broadcasts its ID in Morse code. And I remember flying with him and he'd go, okay, we're going to fly into here. And it goes, doo doo doo doo doo doo doo. And he'd go, okay, yeah, I got it. Um, what what it's like, yeah, that was Betty. That's Bedford, I got it. What? So I have to look on the chart where it gives you the dots and dashes, and then I listen to it and I go, oh, yeah. Um, but he just he he's fluent. Um, okay, so we're going to, we're going to do sort of a similar thing. Um, and we're going to make two attempts to do this. Um, one is we're just going to kind of build something arbitrary. Um, and we'll give the more frequent things, shorter codes and the variable, and we'll give the less frequent things longer codes. Okay. And we will encode abracadabra using this course. But we have a problem. And you've already discovered the problem, right. Is this an A? Is that what it is? Um, I guess maybe that's an A and then is this one one or is this a b followed by a b? Is this a b b or is it a or is it a d. It's ambiguous. Right. So the problem with this sort of straightforward mechanism is that you get ambiguity in your codes. And so we need to solve this problem. What you'd like to do is just read the bits until you figure out that it's a letter and you want that to be definitive, right? So I'm just going to I'm going to read a bit. Is that a letter. No. So I'll read the next bit. Now I've got two bits. Is that a letter. No. So so there's a way you need a way to say, you know, um, we'll, we'll later learn about greedy algorithms. You want a greedy algorithm to work here? Where? Um, as soon as you get something that distinguishes a letter, that's the that's the answer. And it has to be the right answer, which in the previous coding isn't true. We don't have a definitive way to do that. And this works it out. So um, so it's not going to work. I already explained why. So, um, all right, so how do we solve this problem? Well, if you think about it for a minute, what it means is that no encoding for a letter, if we're thinking about letters, a symbol can be a prefix of the encoding of another letter. You can't have, um, you can't have a code B1. Um. Where the encoding for one letter is a prefix of another. Okay, so none of the other letters begin with zero. So if you see a zero right away, it's an eight. If you start okay, if you go to the next bit and you see a one, well nothing is just a one. If you see a one and a zero, well now you know it's a B and none of the other ones start with one zero. Right. So what we've done is we've discovered we've come up with an encoding where, um, none of the longer encodings, sorry, none of the shorter encodings are prefixes for any of the longer encodings.

Morse code example. The E is just a dot, and there's printing orders that start with a door. Yeah.

So Morse code is more complicated and it's interesting. And, uh, um, and they have spaces like between the letters, but they come so fast, I can't hear the spaces, my friend. And not only that, when people who are truly fluent and communicate with this, they can recognize who's speaking. Doo doo doo doo doo doo doo doo doo. Ah, that's my friend Sam.

Ah.

I don't I. I can't hear it, but he does. Um. Okay. So so now we know a solution must be one of these prefix free encodings. But how do we come up with one? And that is what Huffman did. Um. He said, well, you know, we can take these things and we can represent them as trees. And then what you realize is that the letters all have to be leaves you can't have, and you can't have a letter on the path to another letter. That's the same thing as saying that it's prefix free. Okay, so we need an algorithm. And I kind of just told you. So we need an algorithm, uh, that will ensure like this would not be prefix free because the code for B is a prefix of the code for R. And that's a prefix code for C. Right. That's that's math. So we need a tree more like the previous one. That's uh. More like this. Oh no, not this one. Sorry. The one that's coming up. Um, okay, so everything's a leaf and no other, uh, no other symbol. It has a representation that's on the path to any of the other symbols. And so these are what we're going to call trees. And we need, we need some algorithms to go with Huffman trees. We need an encoding algorithm and a decoding. Uh. And in fact, it was written as a course project. I love it. Um, I don't know who assigned the problem. That's pretty cool. Okay, so what we're going to do is we need to be able to generate these trees. So now that you know the trees exist and what properties they have, we need an algorithm that can make them. Right. So that's um, because once we have the tree, then we can sort of figure out how this works and we're going to build the tree bottom up. And so what that means is we're going to start with the leaves and then build up the tree. All right. So we're going to do is we're going to every symbol that we want to encode. We're going to write the symbol down and pair it with its frequency number. Right. We're going to put that in a node symbol and previous two data members. Okay, so here's five times b2. R2 c1 d1. Okay. So and these are going to be our leaves because we already said all the symbols have to be leaves. So we have the we have all the leaves of the tree right here. So what we need is an algorithm for combining them into a tree that preserves this prefix free business. And the algorithm does this. First you pick two nodes that you pick the two nodes that have the lowest frequency. Um so in this case that would be C and D. They have the lowest fields. If you've got more than two nodes and it's a tie, you just pick arbitrarily. You roll a die or something. Okay. Um so we take C and D because they each, um, have a frequency of one. And then we're going to combine those into a subtree. And the subtree doesn't have a character associated with it because it can't. right? Because we can't put any encoding on the path to a leaf. And this node is on the path to both of these. But what we're going to record in there is the sum of the frequencies. So now everything this subtree has has a frequency of two. Because it combines these two things. Then we're going to do is we're going to put this back in our pile of trees. But by the way, if you have a bunch of trees, why is it that if you have a bunch of trees, um, that's called a forest. So another terminology, um, and an algorithm that optimizes something by removing intermediate trees is called a deforestation algorithm. I'm not joking. That's a real thing. Okay, so now we repeat what we do is we say, okay, well now we have these one, two, three, four trees. And we want to pick two that have the um that have the smallest frequency. Well we have three that are tied for two. So we can just pick arbitrary. And we're just going to keep doing it until there's one tree left. So we're just going to keep doing this thing. So we find the minimum subtrees. Um there's a tie. So the slides pick this one. So who am I to argue. And then we do the same process. And then that tree. Now we want to pick the two smaller again in this case where the two smaller are four and two. Right. Everybody okay. Okay. So we combine those and we get six. Well now the two smallest are five and six. So we combine those and we get them. And now there's only one tree left. We're done. So what's our encoding. Well our encoding is just is the path to any of the leaves. So we can make a table like this. So k is the most frequent one zero. Um b is 100. R is 101, D is one one, and C is 110. So that's the that that's how we get started with this. So here's the summer. Oh gosh.

Um.

So here's a summary. We get a frequency histogram of the symbols we want to encode. We build a collection of trees, which are all just leaf nodes that contain a symbol and the frequency of that symbol. So you take the table, make the leaves of a tree. We put those in a data structure. We haven't learned about priority queues, but you could use a priority queue for this. But it doesn't matter. You can store them in a list, and then you can find the one that has the smallest. You can find the two with the.

Smallest.

Frequency in the list, right? Uh, breaking ties as appropriate. Um, okay, we find the two trees in our list whose roots have the minimum frequency. And again, breaking ties arbitrarily. We take those two trees, we make a new node that's apparent to both of those subtrees. Its frequency is the sum of the two things we combined. And then we put that root in as the, as a um, so we take the two subtrees out of our list, combine them, and then put that root back in. And you keep doing it until your list is of length one. So then there's just a tree with one root.

So this is a priority for you right.

Um, you could use a priority queue for this. But if you don't know what a priority queue is that's okay because we're going to I'm going to do lectures on it later. It's coming up.

Um.

Okay. Um, the resulting prefix, which he proved is it. So the resulting tree is a prefix. It results in a prefix free encoding, and frequently occurring characters have a shorter encoding. So this is pretty cool. So, um. So if we use this to encode the data, once you've built a tree and then the table, you can throw away the tree. You just need the table for this. So once you have the table you can encode the data by just to take a and that's a zero. You take V and that's 100 you take ah. Same thing is with Ascii. You just look it up in the table, put the bits together. So that's pretty cool 23. So we save some data.

As well. Sorry.

Oh so each bit uh bit stands for binary digit. And it's either a zero or a one. And that's the fundamental unit of information in a digital system. So it's the smallest unit that we can talk about, which we usually say zero one. Sometimes it could be yes or no. True or false. Up and down. Frog and toad I don't care. They just there need to be two distinguished things. And conventionally we call them zeros and ones. That's a bit, uh.

If you I mean, how would you have like, that table? And, like, if you're a computer reading this, like, you're not going to have that table, so, like, how do you do that? I imagine that would take a lot more than ten bits to convey all that information.

Um, you're quite right. But of course, most messages that we want to send are not 11 characters long. So, uh, you're quite right that when we when we do this, we have to communicate with the decoder, that table and that table takes up space. So normally it would go in a message that says, I'm a Huffman code. And here's my table. And my table is this many characters in it. and it's got this many bytes per character. Here's the table. And then here's the message, you know, and it's got this many bits in it. And off you go. Um, and so you're right that in this case, that overhead would likely swamp whatever we saved. Um, but I hope you can appreciate that if you've got Romeo and Juliet the entire text here, then it would be worth it to send the table. So that's a good point. Oh, yeah. You had a question.

It's kind of a question of that. Like, is there ever a moment where, like, encoding might be less efficient than, like just using Ascii, like for example, if like there are too many characters depends on things and like just the tree is too big or like.

Right. So um, so there is a proof of optimal optimality that is, um, if you have a mapping that's one symbol with a fixed encoding. So you're not allowed to like combine characters like, oh, an apostrophe O and an accent, and then the O with the accent, right. So it has to be sort of a simple 1 to 1 coding There is a proof that it's optimal, which means it won't be worse than asking. Are there cases where it's no better? Yes. If there's no. If everything sort of occurs with with equal frequencies, it won't it won't save you. So was there a question? I feel like there was movement over here. Okay. These are great questions. Love it. Love it. Um, so how do you decode. And this is the funding. Um, so you read one bit at a time and you sort of follow the tree left and right, um, zero and one. Um, if you have that table, you can rebuild the tree. Right. So, um, okay, so you following the left child is a zero. The right trial for one. Just a convention. Could it be the other way round? Sure. But we. This is the convention. Um, when you encounter. If so, you read a bit and then you follow the tree and you say, is this a letter? No. Then you read another bit. Okay. Do those two bits represent a letter? No. Okay. Do these three bits represent the letter? Yes. Okay. That's the letter. Now you move on to. So then you you emit that as your choice. And then you go on to the you start over and you keep going until you've gotten to the end of the bits. And someone told you how many there are. So you can think of this as a tree traverse. So we started the route and we read a zero. Well that gives us an A. So hey, um, now the next one is a one. Um, that's not a letter yet. So then we have a zero. That's not a letter yet. So then we have another zero. But that's a letter B, so we emit B and then we start with the next bit. We start the whole process over um to.

The.

One. Then what's the next one. Zero. Uh, one. So it's an R and you sort of see how this goes. Oops.

It's okay.

Um. Oh, wow.

I'm like.

I thank you here so quickly. I don't know. Um, okay. So you can see how we, we we, you know, you can't see that. Um, now you can see how we got there by by following these, uh, these things. Right. Okay. Um, so here's the here's sort of the, uh, um, uh, the cool things. It's optimal among algorithms that produce single, uh, symbol encodings. That means symbol has a fixed encoding. There's not, like, groups of symbols or, you know, well, I guess a ligature would be a different symbol, but, you know, like accents and stuff like it. It's only if there's a straightforward one symbol has one encoding. One encoding is for one symbol. So it has to sort of obey that. But if you have that it's optimal. Um, and that's pretty cool. It also assumes that you have that you have information about frequency data, which you may not write. So, uh, if you don't know a priori what's going to be the most common symbol, then you you're sort of stuck. If somebody is just sending you random characters, then it's not going to buy you. Um, but usually there aren't current systems. So the decoder will use the Huffman tree. It basically just needs the table. If you give me the table, I can draw you the tree.

It's left.

Left. Okay. Right. So I can figure that out. Um, uh, as I think you observe, the, uh, the sending this information consumes overhead. And so for very small things like the word abracadabra, probably not worth it. But for larger things like your C plus plus program, this would absolutely work. Well because, you know, curly braces, that's those occur pretty frequently. Semicolon appears pretty frequently. So you can imagine that this would compress C plus plus code pretty well. Um okay. So we've kind of reached the end. We're a little early. Um, I should have talked more slowly. Uh, okay. So big takeaways, though. You should know that compression. You should know what compression is. But I think you already know that. Make something smaller. Um, you should know. Why do you care what it's for? Um, you should know that we can do it in a lossy way, like JPEG or MPEG or what have you, or a lossless way like zip or B zip or any of those cousins.

Um, you.

Should know that there are conventional encoding things like Ascii. Um, and you should know that Ascii is a fixed length code, but variable length codes are possible. Morse code being one, Huffman codes being another. And you should know about the prefix freeness. And of course not for the exam, but for the next project. You should know about the coding and decoding algorithms.

All right. Are there any questions? Well, I went with this.

I don't know what we're going to do on Wednesday. You guys are doing exam reviewing and lab. So I don't know if I have an idea, but we'll see. That's right. See you in a couple days.

All right. All right. I got. So much. I'm not. Very nice. And I'm thinking I want to take that into account. Oh, yeah. Uh, I'm. I'm afraid, uh, I'm considering taking. I'm not even. Taking this class. I need a fucking five credit right now. Like we're planning to change.

It, actually. Um, and so.

I think.

I think we've.

Decided. But we need to we need.

To decide definitively. And then, uh. Um, but you're a sophomore.

Um, freshman? Oh, even.

Um, So our plan is we're going to.

We're going to let.

Seniors and I think juniors and post backs register directly on Sis without filling out concerns.

Okay.

And so that's why you're not seeing the updated stuff. Um, we do want everyone who's not a junior or senior or prospect survey, and we've been dithering a bit on what the mechanism is. Okay. One thing we might do is have like a, um, a waitlist section. And then if you're not in those categories, you have to register for the waitlist section. And then once we figure out who those people are, we email them.

The survey.

And then we collect it. So okay. Um, so you there will either be a survey that you know about in advance or if not, there will be a way for you to register on the day for a waitlist section. Okay. And then there'll be this onerous process that will and and then you don't have to worry about the registration period ending because we can get you in after the registration.

Oh, okay.

But, um. But you should have, particularly as a first year student. You can imagine you're kind of low on the list.

Yeah. Yeah.

Not a personal judgment, but just, uh, we sort of go by, like.

Who needs it like most at that point, right?

Yeah. Like, if you if you're trying to graduate in December and you can't or sorry in May and you haven't had it yet and you're a senior you're in. Mhm. And so we sort of work back from that. Okay. Um and then we take into account other things like people studying abroad and stuff like that. And have you had you've had 61 I think we talked.

Oh great. I'm planning to do that next year.

Absolutely. Do that. Do that ASAP. Yeah. Um, and you should have a backup plan for what happens if you don't get 40. Okay. Everybody should, but. Yeah, but you're a little ahead of the crew, and so that's okay because you got to take electives anyway. Yeah. And you could also try to do 105 or 1 of the other core courses. Yeah. Mhm. Um the core courses can kind of be taken in any order. Okay. Mhm. Um, except that the others all require discrete math.

Oh I see. So like basically due to three methods it is possible. Yeah. Okay.

Yeah. So that's, that's where we are right now. And you're reminding me that I need to go to our advising specialist. And we need to get the information out. Okay.

All right. Thank you.

Thanks. Yes. Oh, I don't know. No way. No. No way. No way. No way.

Spell it again.

Oh, I w e r.

All right. I'm sorry.

It's a more unusual name.

Yeah. Um, okay. So how can I help?

What's happening? Uh, I have a question about, um, the the Huffman sorting.

Um, and I have a question about compression in general. Um, Huffman is a lossless sorting algorithm, right? Correct. Right. Um, and like. Okay. So in general write lossless and or sorry, you save less data with lossless and the person to lossy.

Well lossless means you don't lose anything. Sorry.

I mean like the storage space of a loss. The compression file is less is sorry would be in general greater than a lossy compression file. Um, or is it faster? What's the main benefit of like why why would you ever use lossy if you're going to lose data? Um, besides.

Oh I see, yeah. No, that's a fair question. So, um. So, um, lossy compression, you know, there are a lot of trade offs, so there's, you know, how quickly can you encode but also decode? Um, sometimes the encoding process could be slower, but the decoding process is more important. Like if you're if you're streaming, the decoding process has to be Fast because you got to get it to your ears in time for the next note. You can't compute for 1.5 seconds to figure out what the next eight note is. You're not. You can't do that. Um, so all of those things you mentioned matter, right? Um, speed encoding, if you're going to encode on the fly matters, like if you've got a camera and it's sending data somewhere. Um, but very often what happens is you, you record at a very high resolution, and then you, you can rebuild compressed versions to stream at different rates. Um, so sometimes you can do that. Um, so that's one thing. I mean, obviously if you can't tolerate data loss then losses out the window. Um, but sometimes lossy can be much more aggressive. Um, and humans, for example, humans are much more tolerant of visual loss of information than they are audio. Which, you know, if you talk to my friends in the psych department, they can explain this more. I just know it's kind of a fact.

Oh, yeah, I want some of that in, let's say, class.

Okay. Um, and so it's interesting, like, if you're if you're sending a movie or a video, you can, you can compress the video more closely than you can compress the audio. And that's where. But luckily that's where most of the data are anyway. So you, uh, save so you save a lot of data. So I think, um, the trade offs for any given application, the space of trade offs is pretty large. But the big thing is, you know, can I afford to lose data at all? Right. That's sort of the starting point. If you can't, then it kind of doesn't. It doesn't matter how efficient the lossy algorithms are because they're not usable anyway. Does that make sense?

Yeah, that makes sense.

Yeah. Um, I also have questions about some courses. Um, I hope this is for you. I got my sophomore, so I know it's not guaranteed. Yeah. All right.

Did you hear what I told him?

Yeah, I hear it's okay.

Um, like, I, I understand my situation. I have a pretty good shot because I'm, like, double the game, so it kind of means I was kind of sick for the earlier.

Well, so.

Things like that in the survey would be very useful to know that if you've got another degree and there are constraints, um, if you've had 61, that gives you more options. Have you had.

60 and 61 right now?

Yeah. So that actually in in a way counts against.

I heard about that. Yeah.

Because it means I have more elective options.

Correct. Well not just electives. You could take the other core.

I can take one of five.

Yeah.

Ah I was like planning like I have to take for you next semester. No, but this isn't for the AP tomorrow classes and 105 is.

Um.

Yes, but it's not a prereq for 105.

Yeah.

And in fact, once you've had 61 and 15, you can take any of the four courses in any order.

You can take.

Oh, you like 160 105 40 and 170 can be done in any order.

Yes.

So, um, so if you're looking at internships, um, then 160 is a very good alternate. It's not good with 40 because I think it's too much work, but it's a good alternative to for you if you needed something else.

Okay.

Um, yeah.

Um, I also I just wanted to ask about 21. So he has 21 concurrent programs.

Uh, that's, uh, I know that course.

Well, yeah, I know.

Um, I, like Sonia Weber said you don't recommend taking 21 after. After 15?

I do not. Um, mostly because the first few semesters I offered it. A bunch of people did, and.

Idea? Yeah.

No. If it's an idea, you just use low. Like low with no s.

My God, I actually, I'm gonna fail this test I did so on every single practice and I feel like everyone else. But I know they don't like it. But I always ask the stupid questions that nobody else I know. Also America's. I spilled oil on my other parents. Like I was like eating leftover pasta and it wasn't even that good.

So really matching.

No. I love these parents. Okay, I'll be right back.