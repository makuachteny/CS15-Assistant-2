In this class, there's a thing called tokens. What are those for? For submitting late work. If you use a token. Is that an extension? Yeah. Yes. Here's how you can tell if you had an extension, you submitted work and it was accepted for full or partial credit. If you submit stuff after the deadline and someone actually looks at it and you get any credit for it, That's an extension. I just I always get these emails. Um, I'm out of tokens, but now I want an extension. Tokens are extensions. Or actually, the more the more likely one now is. I don't want to use my tokens, but I want an extension. A token using a token is an extension. I have hereby approved six 24 hour extensions for everybody for the semester. There. See? Now you've had the personal approval. Um, so while I was doing that, how where are we with the documents? This has this section. Everybody got one? If there are any left, could you come up and give them to me or hold them up and I'll come get them? I do need the other ones because the other like I said, I, I was pressed for time this morning and so I didn't make separate files for the two sections. So these are all guys. Thank you very.

Much.

All right, everybody got a copy.

Thank you.

Everybody has one.

Wonderful.

I think I've got more than that. This is great. I did print out more than that.

Okay? No, but I did it. Just. Once. Anyway.

Um, so today's topic is something called the Big three. If you didn't hear that, that was dramatic organ music. Um, and I couldn't get keynote to. I couldn't figure out how to make it fade. So it just kind of goes, uh.

Exactly.

Um, okay, we're going to talk about something called the Big three. What are the big three? Well, you've seen one of the big three already. You've seen constructors which are not part ones. You've seen some constructors, but the big three are the destructor, Something called the copy constructor, which we'll learn today, and something called the assignment operator overload, not Overlord overload, which we'll learn about today. Okay. Um, so what's today's? Uh oh. So just to set this up. Um, this lecture used to annoy me in the sense that I resented having to give it because it felt very c plus plus specific. And I want to talk about data structures, and, yeah, we use C plus plus. But this felt kind of in the weeds. But the truth is there's an underlying problem here that C plus plus is addressing that is real and it affects you no matter what programing language you use. The particular solution is very C plus plus C, which is to say ugly and complicated and convoluted, which I'll go through with you today. But the problem it's solving is is real and a general CSS problem. So we're going to talk about it, um, in any language with mutable data structures, which is probably any language, you know. I don't know anyone here know a language that uses immutable data structures. You don't even know what it means. And the answer is no. You don't know. I assure you, you wouldn't know what it meant if you had. Is there fun? Um, okay, so today we're going to, uh, before we get to the big three, I'm just going to do a little review. Uh, pass by value, pass by reference with arrays of pointers passed by reference to C plus plus way. And then this other thing called this, um, which is very hard to talk about because it's the C plus plus syntax is this. And so now you say and this means it's just so it's linguistically confusing, but it's something you have to know. And then we're going to get into the big three. So what it is we want that's kind of driving us um, and why we don't just have it already. Right. What goes wrong? Um, well, under what circumstances things go wrong then how they go wrong, which is key to understanding this is the thing that applies everywhere. Um, because shallow copy is how it goes wrong. Spoiler. Uh, how are we going to fix it? We're going to fix it in deep copy. Um, which is how we would fix it in Python or any other language. Um, and then how we actually program it in C plus plus, which is, of course, what you're going to need for your homework. Um, and then we'll end with, um, the rule of the big three. Okay. Um, so to set the stage a little bit and I know this is hard to read, but you'll you'll see why. We'll go back to the screen in a few minutes, but, um, just relax for a bit. Um, so, uh, parameters and return values of function. So in 11 or wherever you learned, uh, basic programing, you learned about functions, whether you call them methods or whatever you call them. You learned that there were these things you could invoke, these recipes that you could invoke, and you passed values in using arguments. And they were received as parameters. Uh, and there was sort of some mechanism for that. And then sometimes they don't return a value. Those would be void functions and sometimes they do return them right. And so in C plus plus which is pretty normal these days, um, almost everything happens what we call by value. And so we're going to review what that means. Well I guess I'll tell you what it means since it's written right there. Um, the if you pass a value to a function or you pass an argument by value, what it means is that the function gets a separate copy of the data element, right? So if you pass me an integer, then I get three. And if I change my parameter value your art. If you had stored that in a variable, your variable is safe, right? And if I return a value then what happens is whatever value I've computed gets copied back to whomever called me. And this is normal and sweet and wonderful because it gives you good abstraction, right? When you call a function, you don't have to be concerned that, oh my God, any function anywhere can change all my variables unpredictably, right? This would just be a living nightmare if this were true. So the way that most programing languages are designed is that when you pass something to a function, it gets copied, your value is safe, and when you get a result back that gets cut. So then it gives you a a clean interface between the function caller and the function and the colleague. The function that was called so called by value copying things back and forth. This is normal. Um, it's the default in C plus plus pass by reference. Um is an alternative. And if you take 105 you'll find there are some other alternatives. But call by reference is one where if I pass a variable to a function, then the function's parameter refers to my variable, we share the variable. We just have different names for it. But the actual place in memory we're using the same one. And if you pass something by reference, then if the function changes it, whoever called sees the change. Now this kind of can be scary and bad, but it actually has its uses. There are a few standard uses where you pass something by reference. Um, one is the thing is just too big and you don't want to copy it. And then we in C plus plus you use a thing called const to just say, okay, I promise not to change it, but let me have it anyway, right? Um, but sometimes you do want to change it because that's kind of the job of the function. It updates an array, you know, it scales a, um, a matrix of pixel values. Whatever it does, you know, you pass it. Um, and sometimes a function wants to return two things, and the return statement can return one thing. Um, you can package them up in a struct, but you can return one thing by the return statement, and you can effectively return something by updating one of the callers variables if they give you access to it. So those are the those are the reasons to want. You should generally avoid it. But those are fine reasons to want it and to have it in certain circumstances. Um, return values work the same way. And so I'm not really going to talk about it. It's just everything we say kind of applies to them too. Okay. Um, so now what I'd like you to do is look at the example. This one is, um.

Uh.

PB dot cp that stands for passed by value. You'll often see an abbreviated CV call by value. You call the function or you pass the argument. That's the terminal by value. Okay. Um. I remember. So now is everybody is everybody looking at this? Because what we're going to do now is if I can mute the screen, I will do so. Um.

Display. No. Not audio. The other one.

Display. I want to turn off the projector. And I just want to.

Yeah.

I just want to block out.

All right.

So what we're going to do is we're going to draw some memory diagrams here. Now these aren't interesting because these examples on the front of the page don't use the heat. Um, but I just want to kind of model this behavior for you because I find a lot of students are resistant to drawing these pictures. And so I just wanted to go through the exercise where I draw them to instead of just put them on a screen. So then you don't think, well, I don't have PowerPoint. How am I going to draw the pictures? Okay.

Left drawings.

I thought you wanted the backup.

No, I wanted the unused ones back. These your copy? That is your copy. You can write on it. You can burn it in a ritual ceremony later. You use it however you like. Okay, so normally when we draw a memory diagram, we want to have the different areas of memory. There are three. One doesn't come into play very much. One is sort of a global area. And I usually just put that up in the corner. Usually I don't even draw it because we don't let you use global variables in this course. But you might have a global constant. And if you if you had one, you would put it there. The other area of memory that we are concerned with is the stack, sometimes called the runtime stack or the function call stack. And you learned about that in CSE 11. Whenever you call a function, an activation record gets created on the stack. That's where all your local variables go. Um, anything that gets declared inside a function, it's going to go in here, it's going to be stored on the stack. Then we have the heat which C plus Plus also calls the free store. And they've been trying to push that terminology for a couple decades now, but I still don't hear many people use it. Some do. The heap is where when you allocate something with new, it goes and um, and it gets recycled when you use the delete key. I don't like to delete keyword because nothing gets deleted. It's not like if somebody goes and plucks chips out of your computer's memory. Right. So the memory is there. The question is whether someone else is allowed to use it or not. So I refer to it as recycling. If you recycle it, then somebody else can use it. That's what delete does. Um, okay. So, um, whenever you, uh, start your program, then a few things happen first, which maybe we can talk about later. But ultimately, eventually an activation record gets created for the for the main function. This is generally where the execution of your program starts. We told you this is where it really starts in 1011. And that's kind of a lie. Um, constructors for any global objects actually run first and then main runs. Um, and then when you take 40, you'll learn that there's some other stuff that happens before that, but not that's, that's for you. So, so eventually main runs and so main gets an area on the stack that it's allowed to use. And that's where all of its global variables are. That's right. Global. It's all of its local variables. Go. Um, I call that thing an activation record. I don't know what do they call it in the 11? Do they have a name for it?

Stack for.

Stack frame. That's another thing that that's a very common term. So it's called a stack frame activation. The compiler jockey is often called an activation record. Um activation record is what I'll use. What I mean is the area of memory associated with a particular invocation of a function. So a recursive function, you'll have many invocations. Every time you call the function, a new one gets created. It's part of the seven steps of function evaluation. Now in this case, you can see that main has a variable called great creatively and descriptively x. And it's initialized to a value of five. That's not very dark. So you can draw these diagrams. That's the plan. All right. Um then the next. So the first line of main, we've just we've just carried out get allocates a variable called x that can hold an integer and it initializes it to the integer five. The integer value five. Right. So x is an integer variable five is an integer value stored in a variable known as x and being annoyingly precise. Hopefully it's not too. Okay, so then main calls the function func. Now func is a void function, but that doesn't matter for the for this purpose. What happens when you call a function is you evaluate the arguments. Then you create an activation record or stack frame for that function on the stack. Then you create space for all of its parameters. In this case, it's also called x. Then if it's called by value, you copy the argument value into the parameter. So we evaluated x and main which contains five right. Then we copied that five into the x in func. Okay. So each of these is an activation record. I put the name of the function to the left. Inside the activation record go the local variables. That's the basic structure. If you go to the resources page there's a how to draw memory diagrams documents so you can get more there. Um okay. So now that we've we've set up the function and we've initialized the parameters. Now we start running the function and we execute the first and only line which says update x which is refers to the local x. This way if you have a variable reference, then the first place the compiler will look for is in the current activation record. Right. So we're looking for a thing called x. The current activation record is the one on the top. Um and there's a thing called x x is current value is five five plus one. This is university level math. Here is six right. Okay. Now here's the thing that's that's important for call by value means variable called x untouched right. This is what I meant about clean abstractions. They can call this function. The function can't do anything to it's variables. It's variables are safe. They are the same thing they were when the function call returns. My state has not been changed. Right. So we like that. That's nice. When the function completes execution, if there's a return value it gets copied back. And then if there's not after the return values, copy back or if it isn't. Then this activation record is recycled. Any destructors associated with the data stored there gets run and and then execution resumes in main where we started. And then it prints. X is now. Five. Excellent. Okay, everybody. All right?

Okay.

Um, now let's move to the right now in in the intro in in C plus. Plus, what you learned in 11 is that everything is passed by value except.

For.

Arrays.

Right.

So what happens with an array. Arrays are a little bit tricky. So we're going to execute this one. I'm going to erase this. But I'm going to I'm just going to keep the. I'm going to do this. Okay. So now let's look at the one on the right. So in this one once again. We get an activation record for me. Um name has an array but its name is ah because it's a pirate and ah has three slots. Um, the first one contains the character A, the second one the character B, and the third one, that character C, very creative. Will be okay with this. All right. So now we do the same thing that we did before we, um, evaluate the argument. When you evaluate an when you use the name of an array without subscript ING it, does anybody know what that means in C plus plus or C.

Well when you're indexing it.

We're not indexing. So in this thing we have func calling it on r rr. It's not being indexed right. Um no square brackets. So this isn't being indexed. It's just a pointer to the first element of the array. So what it means is so when you do this yes what you if you refer to an array without subscript it, what it means is the address of the first element in the array, which is an address is otherwise known as a pointer value. Right. So if this if this location is at. 0X7FFF0 or something, it'll look like that in our system. So this is the address of a. And then this would be f1 f2. So um if this is a memory address where the beginning of the array then when we call func. What happens is that func has a parameter also called bar. But here's the trick. If you write a function and it receives an array as an argument, it doesn't receive an array. It doesn't receive a copy of the array. It receives the address of the first element of the array. Which in this case is 0X7F. I got too many F's here.

Um 12341234I.

Got it. Okay. Um, and so what this means is that ah, in the function points to is the address contains the address of the array in the caller. So this is important. This is why it's called by reference the function is sharing the array with the caller. Right. That's a that's the key idea.

So can you explain what subscript is okay.

Um subscript is you know like if you print um well in back in main you can see that it outputs. I think it's just one. Right. Using an index to get into. So use an index. Right. So the way you use an array is you use an index to get to the individual slots. But if you try to manipulate the array as a whole, then in C plus plus parlance it devolves to a pointer to the beginning of the array.

So this is like accessing the individual elements.

If you access the individual elements, you have to do it with an index with the square brackets. But if you don't index it, you don't then then that means the address of the first element in the array. And we can go into more detail about this later because it's sort of weird and interesting and it kind of, um, you know, language, trivial way.

If you do index it to like, say, the second element in that array will take, uh, the address of the second element. No.

So if you pass, if we pass some other func. Then this passes by value the thing in the third slot of the array.

Okay, so only when you do the whole array itself does it look for like the add, right?

So this transformation happens when you refer to the array but not indexing it. You don't end up if you index it. And it's just what you learned in 11. Nothing. I'm I'm not really showing you anything you didn't see in 11. Um, but you may not have thought through it as carefully as you will now. There was another question here.

Um, what happens if you were to do something like, uh, r plus one?

Uh, see, this is a great question, and I kind of want to not talk about it now. Um, the answer is it means the same thing as square bracket one. Um, but why? It means that is kind of a fun story. We'll all go out for coffee and we'll talk about it. Okay. Um, So is everybody okay with the diagram now? Now again you. I hope you learned this in 11, but I'm showing you the detailed picture so that now everything y is clear because we're going to we're going to do some stuff. Okay. So now let's look at what is uh what is func do. Well it takes our sub one. Um so if you have if you have the address of something and you square bracket it, then C plus plus treats that as an indexing operation, as if that thing were an array.

Which it.

Is. So it kind of works. Um okay. So our sub one, we go to, we go to R, we dereference that, we go to the subscript one of the array which is this thing. Right. And then we assign that to be the character. Z. And then this The activation record gets recycled and the caller's variable was changed. So call by reference means that the the caller and the caller actually share the same variable or variables. Um, an implication of that is if the callee changes the variables, then the caller sees the change. If they were copied, then the caller the caller wouldn't see the change. Right. Makes sense.

So in this case it is calling it by reference when it says functions on.

Uh, so uh, in in C plus plus whenever you have a function that takes an art takes a parameter, that's an array, then it's actually passed by reference in this in the way I've described. So the address of the array gets passed. If you pass an array the array is not copy. Weirdly, if you put the array in a struct, then the array is copied because. But let's not go there now. Okay. So um, in this instance, if you if you pass, if you use as an argument the name of an array without subscript, and then the function gets the address of that array, which means that they now access the same array that you had in your, um, original.

And how do you substitute like it is necessary to subscript or. It's okay.

Um, there are various options, but um, so again, just what you did in 11. So the way, you know, if you had a function that took an array, you just subscript it, it just as if the array were local. So the the way you use arrays is you subscript them to manipulate their elements. Nothing has changed. All that's changed is I'm giving you more details about how it is that the function can do that. It gets the address of the caller's array. And then now it can manipulate the the slots in the same way the caller does using subscripts. So nothing, nothing really. Nothing really new except that I just sort of filled in a couple details.

When you say it's not, um, indexed, does it come with a bracket or just like R by itself.

But look on you. So this is the function call here. So no square brackets.

Okay. Yeah.

Very good. All right. This is lovely. So, um, this information is on the slides, but I wanted to go through the exercise of, um, doing it manually for fun. Okay. So now look at TBR. These are not great file names. Um, I was being very lazy last night when I put them in the class, so, um, pass by reference with pointer. That's what that means. So that's the lower left on your page. And we're going to execute this one. Where's my razor?

UNKNOWN
All right, here we go.

So once again Mane starts off. I said lower left. So Maine. Maine has a variable descriptively called x. We initialize it to five in the first line. Um okay. So notice something. Look carefully at the declaration of func above. Maine. Can you see that? So this says x isn't an x isn't an int variable. Star X is an int variable. Once if x is properly initialized, if you dereference it that you'll get an integer variable. That's what that means. Basically x it's called x ray. X contains the address of an integer variable. So x is going to be a pointer variable. Everybody okay. Again this is sort of Kes 11 review. But I'm being like hyper precise about it because it's going to be the precision is going to be important because we have to fix the bugs. So you have to know exactly how it works. Okay. So the function is not expecting to get an integer value. It's expecting to get the address of an integer variable. So let's let's write down the same thing. Only I won't use so many F's this time 0X7.

Um so.

700. So let's call it that. I'll just make this. That's that's not very accurate. So. Um, okay. So suppose that that's the location in memory where, where it is. Right. We usually write down memory addresses zero x and hexadecimal. But they're just numbers. It's like, you know, there's slot zero to slot one. You can think of memory as a giant array if you like. Um, okay, so this X is on the stack at this location and now we're going to call func. But when we call func tell me what's different about the call to func. We don't pass x do we.

Uh there's a new variable that points to the value of this in the main.

Well there's not a variable, but there's something else that goes on. And you also had a hand up. Did you say we want to.

Say something to that address?

Yeah. So um we say func ampersand. This is the address of operator. So if you put an emphasis I think Bjarne Stroustrup is secretly in love with Ampersands because Ampersands can be used for five different things in C plus. Plus. In this instance it's the address up operator You put it before a variable, and the result of that is the location is the memory address of that variable, the location in memory. That's what that means. So what we're going to do is we're going to say I don't want to pass x because passing x would mean to take the current contents out of x the five and pass five. But five isn't the address of an integer variable. Five is the contents of an integer variable. I want to pass the address, so I take the address and so func is expecting. As you can see a pointer to an int. And so I'm going to get an address of an int variable which is the same thing as a pointer to a pointer to an int. Okay. So now.

Func gets.

Uh has a parameter called x and x gets ampersand of means x, which means it gets the address of this variable. So what's stored in here is 0X7F00. That's what's stored in here. In this example. Ah. So now let's execute. Um let's execute func. All right. So um star x. So x is a local variable. What star x means is to dereference. The thing on the right. So what is that. X is this variable. So we go there. Dereference means treat the thing there as a memory address and go to the place it points to. That's this. So here's the target of the assignment right there. That's what star X gets. Okay. We're going to store it there. Put a pin in there. Okay. So now what are we going to put there. Star X plus one. How do we do that. Well we go to start. So we go to X star X means follow the pointer.

Here we.

Are. We're going to take that value five, add one to it and store it back in. What box was it again? This one. Then this goes.

Away.

And we've updated the callers.

Yeah. In the function definition instead of using like the asterisk whatever you just did x equals x plus one would have happened again.

You would have gotten a compiler error because oh no you wouldn't. Um, it would have added four to the local value of x. It would have made this B0X7F at 7F04 was my. If I have that right. Why for don't ask that instead. Just don't do this. Don't don't add integers to pointers until unless in 40. You can add integers to pointers.

So would that just like change the location of the memory that it's pointing to?

Um, if you reinterpret that as a memory location. Yes. But because this wasn't an array, we just point to whatever happens to be stored after this. And I'm telling you, there be dragons. That's that's just that's a bug field. You're going to open that bug box and bugs are going to crawl all over you. So just so don't open that box, okay? If a thing is if a thing is a pointer, then don't manipulate the pointer itself. Manipulate the thing at the end of the pointer. Unless and until you know exactly what you're doing in 40, you will you will cross that bridge. Okay, so now let's just review. We have called by value, which is kind of the universal truth in C and C plus plus except for arrays. But of course a C standards guru would put on their pedantic I don't know what they have that makes them feel pedantic, but they they put on their pedantic attire and they tell you, well, actually the array is being passed by value because it's a copy of the address Okay.

Well, whatever's.

Um, it's effectively passed by reference because the caller and the colleagues share the storage. If you would like to share storage. Uh, otherwise, you can always pass the address of a thing, which is the old seaway. And so you can do it in C plus. Plus it was inherited from C. So this is how, you know, when I was in grad school and before I learned about C plus plus this is how we uh, we did call by reference. You would write a function and you would say, no, don't give me the value of your variable. Tell me where your variable is, and maybe I'll put something there for you. Right. That's the plan. Okay, everybody all right?

Um.

Lower right. Lower right is not valid in C. So this is something C plus plus added. Um, and it wasn't there at the beginning of C plus plus I think. So we'll see later a reason away. This gets, uh, we turned weird.

Um.

So in this one remaining. There's a variable called x underscore var example var and it has the value 42. And now. Okay so look at func func has an ampersand in front of the x. Remember I told you that the artist loves ampersands. So in this case it does not mean the address of. Well, it kind of does it. It means that X is what's known as a C plus plus reference parameter. What does that mean? That means that this parameter will refer to whatever variable is passed in. And originally that was implemented by just passing a pointer automatically, which is kind of why the the ampersand makes some sense. Okay. So C plus plus reference parameter. That's why pb c plus plus pass by reference the C plus plus way. Okay. And the way you do that in C plus plus is in the function header. You put an ampersand in front of anything you want to be passed by reference. And now when if the caller passes something and puts a variable in an argument slot, then the local variable will be the same as the the caller's right. And normally the way it works is the same way I just showed you with pointers that the compiler will pass the pointer along. The difference is look inside font. Now it says x gets x plus one, which was you were asking about this, but now it's different because the function thinks that x is an integer variable. The compiler has just figured out that I'm. I'm going to make it be the same as the other one. Basically, it's going to dereference the pointer automatically every time you refer to X, so it won't let you manipulate the pointer directly. You just say x and it says, yeah, I know I put a pointer in there, so I'll just start it for you right. Okay. So now x gets x plus one is going to affect the caller. So how that works is fine. Now some people will draw it the implementation way and put a pointer there. Which is not wrong because that's one way to implement it. What I usually do is I imagine there's like a wormhole here. So um. It's like some wormhole. It's like deep space inside and on the other side. So whenever you get something from X, you reach into X and your arm goes down here and you get 42 F, and then when you put something into X, it goes back. And so that's how I draw. Um, if you draw it with an arrow, maybe that's going to be okay. It's the way it works most of the time anyway. Um, the compiler's allowed to optimize it away, which is why I'm waving my hands a little bit about it.

Okay. That's one.

How do I know X is.

What X like in main you're calling an integral. Under that explores. And then in the function of going x how they go around it's using.

Um okay so the variable names. So this is really important question. So thank you. Um the local name of a variable or parameter is local to the function. It has no meaning outside. So x bar is a thing inside main outside main no meaning. Or someone else is free to define it to be whatever they want, right? So names are always local. Now the question how does it know is that the compiler knows that when you put an ampersand in front of the thing, it's going to set up this mechanism. When you pass a variable, it will it will under the covers take the address of it potentially, and then pass that address to the function. And because the function was declared to take a reference, it knows that it's actually getting a pointer value. And anytime you refer to the local variable it will dereference it. Essentially it converts this program to the one we saw in the last picture. and it puts in all the ampersands and stars for you. So that's what. That's what's happening. And the compiler knows it has to do all that because you declared it to be a reference.

Because because the function of.

The function is not.

Declared with the pointer. It's declare with the C plus plus reference who were declared with a pointer. There would be a star if it's declared with a C plus plus reference, it's an ampersand. And I confess that the notation is a little confusing. I think you were first and then we'll come back again.

So I'm going to clarify. So this so this will only so simple source can only convert it if you make the function. So it takes in the address. And then when you're passing it in you could just pass it in regularly. And then they'll do it for you. Yes okay.

So yeah the clarification is if you put the ampersand in the declaration then that's saying I would like the compiler to put in the necessary address of and dereference operations so that I can use this variable, but it affects the variable of whatever the caller passed in.

And what is like the wormhole like, why is that? Why do you think that differ?

Well, because the compiler is not actually obligated to have a pointer there. It's allowed to optimize things away. Usually there is a pointer. But compiler writers are weirdly tricky bunches a bunch of people, and they have a lot of magic that they do. So their only obligation, their only obligation with a reference parameter is to make the two variables refer to the same location in memory, and you're not supposed to care how they do it.

So does the ampersand in this example mean something different than the previous when we used pointers? Yes.

So, um, so Johnny Stroustrup apparently just broke with the tradition of C declarations and decided to put this in, and it's its own thing. Okay. Um, and then there's a double ampersand, which means something else. Oh my God. Right. So you've got and you got and and but you've also got and and and and and binary infix operators. But then you've got and and and and as reference operators and then uh, so he's crazy with ampersands. I shouldn't say crazy. All hell garnished rooster. He's great. But, uh, he's a little weird when.

You pass if you're in a passing of memory address, um, for this example, what would happen?

You mean if I. If I declared it something like.

Like you have an X variable and then you have the memory of that like that? Uh oh, no. Yeah.

Because you can do that, that says that what you have to pass in is a pointer variable. And then I will be a reference for that. If that broke your brain, uh, don't worry about it. It'll, that's, that's for when you get an internship. That'll matter.

Which is that because you have, uh, like because you're using the Amazon function? Uh, in the function, what is the, uh, memory address or would it be editing what that memory actually pointing to?

So let's back up. When you put the ampersand there you're telling C plus. Plus I want a C plus plus reference parameter. Please make this be the make this parameter when the function runs, be the name of B a name for whatever um variable is passed in by the caller. The caller cannot pass in an address in that situation because you said it's a ref. If you say it's a if you say it's a C plus plus reference to an int, they have to pass in a name of an integer variable.

Okay. So you can't pass it. You cannot.

You have to passengers to append.

Right. You can't cross the streams. You have to. Once you put the ampersand then you're committing, the compiler is going to do all the pointer dereferencing and address for you and you're not going to interfere in the process. So you sort of you give up a little control, but you get some safety because the compiler will always get it right. Whereas left to me, I would screw it up sometimes. Yeah.

You do try to.

Find the address of the x variable instead of func. Um.

Because this is going to come up in a few slides. So please go ahead.

Uh, the address that it will give you is the same as the address of the variable in global.

Yes.

Pay attention. So um, so x here is the same variable. If you if inside the function you ask for the address of x, you get the address of x bar. Because the what a c plus plus reference parameter is it refers to the same location in memory. So the same address. And this is going to matter in about 15 minutes. So oh.

Thank you.

That was great. All right.

Um.

UNKNOWN
Hold on. Yeah.

I guess it's all cinema on us.

Oh, so now we'll go back to the slides.

Okay. Um.

And if you go through the slides, there's some annotations. But I said all the things in the annotations. But, um, for you or your colleagues who aren't here, it's on the slide. Right. So there's an activation record that's being reclaimed. Reclaimed? Recycled. Uh. This one. I don't think I do. Okay. But, um, these two programs mean the same thing. So you can either manually do it the old way. You can say I want to reference parameter, so I'll pass a pointer and the function will take a pointer and the function will dereference the pointer.

And blah blah blah blah blah blah blah.

Right. This was the first example we saw call by reference with pointer. Um, if you write it this way, the compiler can. And the initial implementation actually did change this program into that one and then run it. So they do exactly the same thing. It's a notational convenience, but it turns out to be really helpful. And again we'll see.

Is there a preference for doing one way or the other.

Um, if you're programing in C plus plus okay. Well my biases are going to come out. So maybe I should just acknowledge that. So I learned to program in C. And when I first heard this I was very suspicious because in C if you call a function, it's obvious from the call of the function. If you know the data types of all the local variables, are you passing an address or not? You can tell if the function is going to change your variables, or if it could write with reference parameters, you have to know how the function was declared, because if you pass a variable and something was taken as a reference parameter, then they can change it. So it makes me feel a little queasy though, that maybe my upbringing, um, they're widely used in C plus plus. So in general, um, modulo the concern I had before where you should generally avoid reference parameters unless there's a very good reason. But if there's if there is a good reason, then you should do it. The C plus plus and C plus plus. But when you take 40 you'll do it the C way because you're not programing in C plus plus. So you need to know both.

Right now I'm kind of confused with the terminology I guess like the one on the right you would pass in an address to the pointer. Right. What are you passing in to the left.

Well the left one is taking a reference. In fact the left the compiler is automatically converting this program into that. You can think of it like that.

I don't know, but like how would you like read the left one.

Oh, I would say func takes a reference to an integer variable.

It takes in a reference to nature. Yeah.

So that would be the C plus plus terminology as you call them references. So if you're used to like Java reference types, it doesn't mean that. It doesn't mean that. It means that these two variables are what we call aliases. They both refer to the same location in memory.

So wouldn't you say the same thing for the right one then, like it takes?

I would say that that this function takes the address of an integer variable.

Oh, okay.

This one takes a reference to an integer. Well, this one takes the address of an integer variable. And many people would say a pointer to an integer variable. This one doesn't take a pointer. It takes it takes a reference.

What is a reference? In this context.

It means that the two variables are going to be aliases. They're going to be names for the same thing.

Okay. Yeah.

If you're trying to make the two programs different, you'll fail. They do the same thing. The idea is that.

And to a.

Certain extent this is true. This is much this is a lot easier to read in this than this one is um, just just absolutely. This one is easier to read in that one. The thing that's different is if it's a reference parameter, you know, you're changing the caller's variable, whatever they call it, right? Right. So it's a notational convenience, but it turns out to be really useful. And it turns out to be essential for what we're going to do next. Okay. Okay. Okay. Um, so if you understand pointers, you understand references. Don't get too upset about it. If it ever bothers you, you can just convert it to pointers and it'll work just fine. Um, and so these are the rules which we've already gone through. I'll just make sure I did. There's nothing I skipped. Um, yeah. So you can share the same variable for good or ill make it always for good, and you should use them sparingly. I said that, um, we didn't talk about function return, but all the same rules apply. You can actually return a reference, in which case the thing you return is a reference to whatever you had before, which effectively is going to be a pointer. Um, you have to be careful about that, because if you give a reference to a local variable in a function and then the function ends, that variable goes away and nobody should be referring to it anymore. So you have to be a little careful when you return references. But but interestingly we're going to do it if that doesn't make sense to you right now. I wouldn't worry about that so much. I would understand the parameter passing first. That's really the priority. Um. Oh yeah. One more thing. Any time you call a member function in C plus plus or in Python, or in Java or in JavaScript, there's an extra parameter that gets passed. So you'll see that someone said e1 dot get income, E1 is an employee is an object, is an object of the employee class. Um, so it has, um, a member function called Get income, E1 get income. But you already know something has to be going on. Right? Because inside the class the functions can change the data members. Right. But what data member does it change? Well, it changes the data member of the instance that was on the left of the dot. So the function has to be able to refer to the object that was the left of the dot. How does that really work under the covers? How it works is it's just another parameter.

That doesn't make you.

Right or talk about it's just there. And then C plus plus figures it out. If you refer to a thing and it's not defined as a local variable, but it is defined as a data member of the class you're working with, then the name refers to that data member inside the instance of the class that was to the left of the dot. How does it do that? Well, it has to know what's to the left of the dot. There's a, there's a secret parameter called this is and this contains a pointer, the address of whatever's to the left of the dot. And again if you're programing in Python, you've actually weirdly you don't see it when you call but you see it when you receive in Python it's kind of weird. But in C plus plus you don't you don't write it anywhere. Just whenever you feel like it, you can say, you know what? I'd like to refer to this. And when you say this, it means the address of the thing that was to the left of the dot that caused this function to run. That's what it means. So.

Um.

The these two lines do exactly the same thing, assuming the employee has a base salary and an overtime hours, um, and an overtime rate. The first one just refers to those data members. The second one is just very specific. It says refer to the data members in the thing called this this era, which means dereference and then get the field again. That's the CSV file. Okay, so that's all I want to say about it. Now it's going to come up in a minute. Just let that simmer. Let that simmer. Because now I want to get back to our central topic. So that was our rather lengthy diversion. So here's the problem. The problem is we want to define new classes. We want to define new data types. And we want to use our data types just like the C plus plus ones and C plus plus one. Is that for us too right. They want you to be able to have strings which turn out not to be in the core language. That's a class. But they want you to be able to do all the things with a string that you could do with an int, you should pass it. You should be able to pass it to a function by value, return it from a function by value or by reference according to the rules we specify. Um, you should be able to copy them for initialization and you should be able to assign them. You should be able to have S1 and S2 be two strings and you should be able to say S1 gets. S2 and that should have some meaning, right? And not only should it, you know it has meaning. You've used it all the time that you've done this. Um, so let's think about that. We want to create new variables. That's you know, how to do that. You just say employee E, right. Whatever that, um, you want to pass instances to a function, you want to return instances. Now this one is interesting. You're probably used to this syntax. It looks like an assignment statement, but it's not technically. Why is it not an assignment statement. Well, you're declaring a new thing here. You're saying my value is a new variable. Its type is my class, and its initial value should be. So this is called an initializer under the covers. It's quite different from an assignment as we'll see. Um, the way that you do this in modern C plus plus is you put an initial value in curly braces and you can use curly braces for all initializers. You can even do int end curly brace zero curly brace and now n will get initialized to zero. So in C plus plus this is now the preferred syntax. But these previous syntaxes are still accepted. So you'll see them in the wide world and you'll even see them in my code. Um, you'll probably see this one more than this one, because I think I've changed more of these to that. But, uh, anyway, you'll see, you'll see it. But the first one is preferred. Here's the deal, though. Here's what you need. Are you ready? Um, when you pass something to a function, if it's not an array, it's passed by value. It's copy. Right? Okay, so you need to create a new parameter. You need to have essentially a new variable that's local to that function. That's going to be initialized from the copy of an existing instance of the class. Right. I'm passing the string in. Then the function is going to have its own string variable, and its initial value should be copied from whatever string the caller passed in the body. you okay?

Just what you used to call my value.

Um, if you initialize a variable, um, by, you know, you you set, um, you know, employee E one gets e zero, then you're saying, okay, well, this employee one, we're going to make it new never existed before. And its initial value should come from this previously existing member of the class. And you can use the equal sign the curly braces or the parentheses. So in all of these cases it's a new variable. But it's its initial value is is copied from some other thing.

Might be a weird question. Um, if we make.

If we take the second, uh, statement, the one with the equals, if we wanted it to work like it did in Java, you would put an emphasis in in front of my value. Is that correct?

Uh, no, it's more complicated. We can talk later if you want it to be like Java, um, it will resist you at every turn. Um, okay. Oh, the last one I didn't talk to the last. So, um, passing values, returning values, and initializing values are all instances of new instance of the class initialized from an old instance of a class. Assignment is this my value gets my value two no, there's no data type here, so this is just an assignment. In this case, my value one is a preexisting instance which is getting its value updated from an existing. So now we have two instances of the class. Both have a history. People have been adding things to the list taking things out of the list. They both have a history. But now what you want to do is you want to take the contents of the one on the right and copy that into the one on the left. The difference is in the first case is the one on the left had no previous history, but in this case it does have a previous history. So they're subtly different. So. We've already talked about destructors. And destructors sort of help you with the first one. As long as the variable is local and you don't pass it to a value or return. If you don't pass it to a function returning from a function or initialize with it. If you don't do any of these things. Um, what you know already is enough. Sadly, you're going to want to do those other things. So, um, and as I mentioned before, all three of all three of these examples are copying, um, an old thing into a newly created thing, which sounds like a constructor. Right? Because the job of a constructor is to initialize a newly allocated instance of a class. Hold that thought. And then this one is an assignment. And so we're going to deal with that separately. Okay. So we're going to do copying first. Then we're going to do a survey. And so so that's what we want and why we want it. And so why can't we have it. Well you can but it's not straightforward. Why isn't it straightforward. Well so look on the back of your paper. And I think I'm going to do this on the screen to save the up and down the sky. But you can draw this to yourself as we go through it. So just take a moment and rock the NUM class. This is the simplest class I could think of that would that would create the problems. It's very simple. There's one data minimum. And the idea is that data member is the address of a double on the heap. A double variable on the heat. Okay. So that's that that's that's all it is. Okay. So basically this is whole this is a whole abstraction to just have a less efficient way to represent doubles. But it this one will create um problems. So Um, understand why. Uh, all right, so you can create a numb with, you know, the default constructor will initialize the number to 0.0. If you would like your numb to have an initial value, it'll get initialized to whatever you pass in as an initial value. So in both cases, you allocate a new double on the heat, and then you set that value on the heat, that variable on the heat to contain either 0.0 or initial value. Right. So two constructors, some building of what we did last time with overloaded constructors. Um, the destructor does a good thing. Um, if one of these things goes out of scope, is no longer used and and it's going to be destroyed. You recycle the memory so you don't have a memory. Right. Good. Everybody okay? Again, this is all what we talked about last time. Um, then the big operations are you can get the current contents of this thing, or you could set it to a new value. It's basically just a number variable that's going to exhibit what I want to show you today.

All right.

So hopefully the interface is not very complicated. You can you can initialize one. You can let it be initialized to zero. And then you can you can get the current value and set the the new value right. Nothing new. And when it goes out of scope the heap storage gets reclaimed because that's the right thing to do. All right. So um, this is on the back again. And you can draw the picture.

However you want.

Um, here's how I'm going to start. So the first line is, um, the first line of code. We're just going to go through it line by line, see what happens. The first thing that happens is we say num zero. So we allocate space for num zero. Then before the next line of main calls the constructor of num has to be called which constructor. Well we didn't give anything any information. So the default constructor runs. That's the one at the top. So that's going to allocate a thing on the heap initialize it to 0.0. And now the data member is going to be the address of that.

Okay, everybody. All right.

I don't expect controversy for the first couple lines. It's the it's the third line that's going to get us. And then.

The okay.

So what is number one. Number one just uses the other constructor. You can see I'm initializing the variable to 1.00. Uh, um now I'll talk about that okay. So the next line does what you expect. So so so far I don't expect any controversy. This is just review of completing basic classes constructors. And then the overloaded constructors we talked about last time. Here's where things get interesting. So let's get to the third line. So the third line says I want to allocate space for a variable called num two. It has the shape of a of a of an instance of the num class. And then something has to happen. But which constructor to runs. Well, it's not the default constructor because we are providing an initial value, right? But it's not the other constructor that we wrote because that one takes a double. This isn't a double. This is a num num one isn't none. So what does C plus plus do? Okay, well it uses a kind of constructor called the copy constructor. It's a constructor that you use whenever you're initializing a new instance of a classroom, an existing instance, and C plus plus help. Uh, C plus plus defines one for you if you don't define one. And can you guess what it does?

It copies.

Yeah, but we're going to get more details.

Perhaps it was the destructor on the first variable that you're no longer using, and a constructor for the second one.

Well so that's an interesting hypothesis. But in this case we are going to continue to we could use num one. So we don't want to destroy num one. So num one is still available so nothing's going to get destroyed. So that's an important observation right. We're going to we're going to create a new thing based on an old thing. But afterwards both the new and the old things still need to be usable. So that's really important. We'll go left to right.

It got the values from 10.

To 20 copies, the values from number one to number two. Right. Yes. And we have to be a little bit more detailed. Do you want to. Can you be more detailed or is that okay? Maybe it just runs whatever line was number one. But then again.

For number two.

Um, that's also an interesting hypothesis. But it's not what happens. But it's, you know, if you're looking at it de novo, it's not a bad thing. So I think you are next.

Uh, yeah. So it's going to copy the pointer that was in num zero.

So you're going to get another pointer to the zero from num zero.

That is what's going to happen. And is that what you were going to say.

Yes. Number one.

Okay.

Uh num one.

From another one. Um, okay. So here's what happens if the default copy constructor goes through all the data members and copies the old one into the new one, but it just copies the bits so it doesn't interpret the page. Um, unless it's an instance of a class. If it's an instance of a class, then it runs the copy constructor for that class. But if it's a simple thing like an integer or float or a double or a char, it just copies the bits and that works fine. Those things are called pod types, plain old data types. This is the best class. Um, so those are fine. The problem is, it does the same thing with pointer values. And this is a bit of a problem. So what it's going to do is it's going to go through all the one data members, all the one data member of num one. And it's going to copy this value, which is, you know, 0X6010C or something. It's going to copy that down here okay. Which means.

Okay.

Anybody got the shivers? This looks like a problem. This is called a shallow copy. What a shallow copy means is you copy each component, and if the component is a pointer. So what? You just copy the pointer. You don't go any deeper than the things you need to copy. You don't look inside any of them. That make sense.

That's called a shallow copy. Of the same thing happens that pointers of class type.

Yes. So any kind so any kind of fundamental type. So you know int char bool float double.

Blah blah blah blah.

All of those and all pointer types, regardless of what they point to, are treated this way. So if it's a pointer type now if you have an instance of a num in there then or an instance of a class, some other class, then the copy constructor for that class runs okay. So this is a problem and it's very bad news. So let me just tell you what's going to happen. First of all, the client may not expect that if they change Num1 value that num2 value changes. But that's exactly what's going to happen, right?

Um.

Now, interestingly, so this is where sort of we're getting to what we were just discussing with the the class types. If you define a new type, you have to say what copy means for your type. C plus plus has a default meaning, which is the dumbest one that's wrong anytime there are pointers involved. But it has the virtue that it's very easy for the compiler writer to implement. Right? And it's very fast. So C plus plus often chooses fast but wrong over over slow. But right C plus plus often makes that tradeoff. Um, in this case I think we don't want that. But you might want it, right? And this is why C plus plus doesn't make the decision for you. You get to decide it makes a default assumption. But we'll show how to how you can decide. But what's worse is that the end of the function, what happens is the destructors of all the things allocated to the function run in the reverse order. So in this function, the destructor for 3210 will run in that order, always in the reverse order.

The way you did it.

So if the function were to stop at this line, then what would happen is NUM two's destructor would run. This would get recycled. Then num one's constructor destructor would run. It's going to try to recycle it again. Now the program crashes was with what's called a double delete or double freeze, because the heap manager has said you don't know what you're doing. You just you tried to delete it. You tried to delete it. Again, I think you've got a problem, and I'm just going to stop you here until you fix it, right? So that's that.

But if you thought.

That was bad, we haven't crashed yet, so let's just keep going. So num three does kind of okay. Not controversial. Right. We're just it's it's the same thing that we did with them. Zero. Okay. The next thing is an assignment. So the first one ran something called the copy constructor. The next thing is different. It runs what's called the assignment operator. You know that's an assignment statement. What you don't know is in C plus plus you get to decide what it means. If someone assigns members of your class or instances of your class, cool. Guess what? It does by default though, if you don't define that shallow copy, right? That's the same thing. Now we have two problems, right? We have the same two problems we had before that. Now these two things are aliases. And the the client may be upset. Then the other problem is that at the end of the function, the destructors will cause a double delete. And we've added a new bug that this memory. Now we don't have a reference to it, but it was never deleted. So now nobody can ever use it and nobody can access it. So that's what we call a memory leak. That's not an error, but it's an engineering badness. And we will in fact take deductions on homeworks for memory things. Um, we'll tell you more about.

Uh.

Oh, yeah. Sorry.

So maybe.

When the.

Function ends results in a double delete. Why is it the default? Just because it's fast? Yes.

It's fast and it's easy for them. So you say. I take no responsibility for the design of C plus.

Plus, I'm just. I'm the bearer.

Of the message. Okay, so I now have two problems to solve. How do we copy an existing thing into a new thing? And how do we copy an existing thing into an existing? You can already see the big difference at one difference is we need to delete this. right now. Potentially. Okay. So here here are the solutions right. The syntax is ugly. You can treat it like boilerplate boilerplate. But you need to um you'll have to write it for the homework and you should understand it over time. So how do you define a copy construction? Like all constructors, it has the same name as the class. Right? So you know it's going to be called num. What is the argument to the copy constructor. Well it has to involve the uh the thing that you're copying from. Right. But it can't take it. Just can't say num other thing to initialize it to. Why. Because if it did that, then you would have to copy the thing to call the copy constructor, which would invoke the copy constructor, which would require that you copy the argument to that copy constructor, which we call the copy paste. So you have to end this somehow. And so you either have to pass a pointer or a reference, because that's the way you stop that. You have to pass it by reference. Um, this thing C plus plus and this feature being added after the C plus plus references were invented. It passes a referenced lesson and in particular it passes a const reference. Const just means I function. I'm taking a const reference to a thing. I know you're giving me access to your variable, but I promise I won't change it. I will leave it constant for my for the duration of my function. Right. I do solemnly swear I will not change your value. I said I was going to copy it, I will copy it, but not change. Okay, so that's all that means. Um. And then what do we do? Well, um, just as we did for the regular constructors, we allocate the thing on the heap and we initialize. How do we initialize it? We get the value out of the other one. Um, so we do other dot value pointer that gets us to the, the value pointer that's inside the variable. Then we dereference that because that refers to the thing on the heap. We copy the value out and store that In the location on the heat that we just allocate. We're doing a deep copy. We're going down. In this case it's not very deep. It's just one level because there's only one level of pointers. But as we'll see in future data structures, there can be an unknown number of levels of pointers. But for right now this is one. So that's easy enough. Um, so the syntax is ugly. Hopefully the Y is clear and what it accomplishes is clear. And now you can write one yourself. All you do is you do the same thing that the other constructors do, but then you deeply copy the pointer based components of the data structure. And if there's only one level, it's particularly easy. You just you dereference one pointer, you get the value back and you store it in your heap.

Other habits.

Um, oh. So the order of operations the star happens after the dot. So other dot var pointer refers to the thing called var pointer inside other. Yeah. And then what that thing is, is a pointer variable. Right. So now I want to dereference that to get to the heap. Yeah. Makes sense. Okay. Very good question.

Yeah.

Uh is it okay? Why is parentheses to not get confused with the order of operations?

You can always use parentheses to disintegrate. I do that all the time. One more question, and then I have to show you one more thing or you can't do the homework.

So just to.

Clarify, what makes it the copy constructor is that it takes its own type as an argument.

Correct. Okay. Well, it's a constructor because it has the same name as the class. It doesn't have a return type. And in this case it's the. So it's an overloaded constructor. But this one takes an instance of the class itself a reference to it. Okay. So I have to tell you one more thing because at least one more thing. And I've got just a minute and a half or so by my clock here. Um, okay. Oh, and you can use this. All right. I'll skip that because it's going to come up on the next slide. All right. When I first learned you could do this in C plus plus I was like okay the language is officially cool now I hated C plus plus at first when I found out you could do this, I thought, this is glorious. You can override any operator. So if someone pluses instances of your class, you can say, what does plus mean on my class? What is minus mean? What is starving? What if they dereference it? What if they subscript it? No. My favorite is. What if they called it as if it were a function? You can do that. You can say it's really weird. So here's how you do that. You're going to define a thing called operator. And then you just put the operator that you want over operator equals sign. If someone equals is uses equals on my class I'm going to override that. The operator equals.

Okay.

So two things just like the copy constructor it takes a reference to the other one I usually call it R's for right hand side of the assignment statement. Um, and it's a const reference. The difference is this one has a return type because assignment does two. Because in C plus plus you can write A gets B gets C gets D you can chain them together. So when you assign you have to return this part. If you don't get this part 100% today, I'm not to worry. You can treat it again like boilerplate, just, you know, sort of copy it out. Substituting for your class, it's going to return a reference to an instance of the class, which one it's going to return, a reference to the thing on the left. That's all it's always going to do now okay. So now here's the weird thing. So the this variable was invented in C plus. Plus before references were. So the this variable contains a pointer but the right hand side is a reference. This is just historical accident. This was invented first. It was a pointer type because there were no references. The assignment overload came later, but there were references then. So now. Now we have it. Okay. So how do you know this? If this contains the address of an address that's the same as the address of the right hand side. Then someone is doing something crazy. They're doing x gets x. I'm going a special case that if someone says X gets x, I'm going to do nothing because you're assigning to yourself. You're already equal to you, right? Why am I even here? Um. And then you return star. This you'll always return star this from assignment operator.

Always.

Then. Otherwise you delete the storage. So you run basically the destructor, and then you run the copy constructor essentially. So just glues those things together. There's an optimization, but I don't have time to describe it. Um, all of your classes in CSS 15 will define these. The big three. Big three are.

Structure Copy constructor.

Assignment overload. By the end of the term, you'll be missing.