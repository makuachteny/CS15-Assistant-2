Today's 25th of September. Um, the sign up for phase one of the project is do what? Project one. What's that? I'll see the calendar. There's a there's a sign up thing I have to do. Yes. See the see the assignment, which is like from the calendar. Um, there's a note about this posted on Piazza. Um, also note that, for example, I believe Friday is already completely booked. Sunday is already completely booked. So, um, if you're not on there, not now, but after class, um, sign up for phase one and the check off. Um, it doesn't have to be onerous.

But, you know, if you just show up and say, check me off, that's not good. They're going to say, well, when you're done, come back and then show me, and then we'll check you out. So it's not going to be perfunctory. You actually have to have something prepared. What. See the assignment and then be prepared to talk about it. And then and then it should be easy. Write my instructions for the Tas are everybody should get all the points, but if they can't get all the points, you send them away and then they come back and then they get all the points, right. So the idea is not to sort of squeeze people's grades, it's to squeeze their brains and hope that thoughtful juices come out and allow them to complete the assignment. Um, so that's the that's our evil plan. I'm just putting it out there. So no secrets. Um, if you think about something before you try to program it. Life usually goes much better. Um, ask me how I know. Oh, I know, I know I have many times just rolled up my sleeves, opened up the iMacs and started hacking, and, uh, it's usually better when I know. All right. Um, we have some new topics today, but last time I was a bit rushed at the end, so I just kind of want to go back and see if you have questions about complexity, complexity analysis, aka asymptotic analysis and big O notation. Um, you'll recall last time that we we told you we needed a way to measure something, and then we kept telling you to forget about this and throw away that, and constants don't matter and lower order terms don't matter. Right. We we told you all of this stuff. Um. In the real world, sometimes those things do matter, right? So I think I mentioned this last time, um, if you tell me that, uh, you know, my website is going to be ten times slower, it's a constant factor, but no one's going to want to use it. Right? So constant. It's not that constant factors never, ever matter. It's that usually constant factors as you scale are swamped by these other things. Right. So a website that gets ten times slower is bad. But if it gets bad exponentially the number of users I have, then that's just going to that's going to make the whole thing impossible. Right. So um, so that's the point. And we're often interested in theoretical situations in 160 here in and 15. We mostly want you to get used to. You want to discuss it intelligently when you go to that job interview and someone says, look, can you can you come up with a constant time solution to this? And you and you know what that means. And you say, no, it's impossible. And I can I can show you why. Or you say, of course I can. And you whip it out. And then they say, oh, you know, sign this to a $50,000 contract or whatever. I'm that's not a promise for me. I'm just making up a story. Um, okay. So, um, despite all of this, um, it is remarkably accurate in the real world. Um, like I said, we used to do it. We we used to do a sorting assignment, and we dropped it. And I'm trying to figure out if we can reboot it. The problem is that all the grading was done in person, and so it's a scheduling nightmare. But, um, but part of that was we actually ran student code on things of size zero 110 101,000 110,000 100,000. Right. And we gave you a big table, and then you could see which which things are order n squared, which things are. And it was really obvious. Really obvious. Right. So if something went from 10 to 100 it got ten times bigger. Ten squared is 100. You look at the times, sure enough, the decimal point has moved over two places. It's like that. So it's it's not intuitive and you have no reason to believe me yet, but just, uh, trust for a little bit and you'll see it is weirdly effective even when you think it would be. Um, and so I think we reviewed this last time, I'll just skip to the end rather than have the dramatic and the drama of revealing them one at a time. Um, if we're talking about the implementations that we had, um, you can insert at the front of an array list in order n times because you have to copy everything. Um, if you have a linked list with a back pointer, inserting at the front is constant. Just update three pointers or two pointers or 18 pointers. If you've got like a, you know, front, back and sideways or whatever. Um, but it's a constant number of pointers. It doesn't depend on how big the list is. That's the important thing. The worst case is you have to update, you know, 3 or 4 pointers. Um, insert it back constant in both with the proviso that an ArrayList might have to expand. Um, so in general, the worst case is order n because you have to copy. You have to allocate a big thing and then copy n things. But what you'll learn in 160 is that for most programs on average, it works out to be averagely constant. Not every every time you call it you, you might get a slow one. So it's not reliable in that way. But if you just sort of take the number of times you call it and sorted the number of times you spent in the function, and divide by the number of times you call it, it works out to be roughly constant, which is really weird. Um, so inserting at the back of an array list is is is easy if you have the space, um, getting any element in a, um, in an array list is order one getting the kth elements in the linked list, you got to go through k things, possibly n minus k things. If you start at the back of the doubly linked list and work your way back, but still it's proportional to n, right? Um, let's see. And if I want to know whether this list contains, you know, the name sassafras, then, um, I have to look at if, unless the list is sorted, then I have to go through every element and check. Are you sassafras or do you use this first? And then I either get to the end and haven't found it, or I find it and then I'm done. So that's proportional to n in the worst case. So any questions about that? Because what I've just done is I've illustrated the sorts of discussion and the level of discussion that will often have about complexity. Um, we will analyze code, but I don't want to. We don't have time to go back and do that again today. Any questions about complexity? You all you've understood it. It takes you a constant amount of time to understand it. Um. Oh, this brings up I don't think I mentioned this to to this section last time. Um, picking n is really important. So when you're in a job interview and they say, you know what order n if it's not obvious what n is or even if it is, restate what it is. Well, assuming that n is the number of elements in the list, right? Which is typical, but there will be cases where you might have multiple values of n that make sense. So if you're dealing with rasters image rasters which are 2D matrices, what is n? Is it square and n is one side, in which case there are already n squared pixels, right? Or is it the number of pixels? In which case there's square root of n columns and square root of n rows. Right. But you can see that this change is. Suppose I want to update every pixel in an image. And there there are and it's of size n. Well what does n mean. If n is one dimension, then it's n square. If n is the number of pixels, it's n, right? So understanding what the measure of problem size is is really key. And this can be crucial in job interviews. And again if you're if you're ever unclear nail it down. And in fact the interviewer will be impressed. You saw that there was some ambiguity in this. Right. And so so they're um, very often um, yeah. So we're going to ignore, expand and copy most of the time. Um, and if we don't, then I'll say so explicitly, um, you'll learn why in 160 you'll do the proof. I think they do the proof. Um, I'm not going to do the proof. I did it when I was a student, and I'm not doing it again. So there. Um, Big-O isn't the only game in town. Bingo is the upper bound. It will never get worse than this. Big Omega is the lower bound. Oh, it's always better than this, right? Or I guess it's always worse than this. Omega. Omega is the good news. This is as good as it's going to get. So as bad as it's going to get, as good as it's going to get. And you know what? No matter what you do, it's kind of about this. That's what they did, is they call it tight bounds. It basically means you can write bigger and omega with it, and you get to pick different constants or proportionality. So if you pick one constant the graph is here, you pick the other constant. It's here. But as long as the bounding works for both then you say it's theta. And once again I don't think we'll use omega and theta in 15. You'll see it in 160. But since we talked about Big-O, I wanted to mention. All right. So that's my very quick recap. Bless you. That was the end of complexity. Anything you need to know about it. Let's, uh.

Let's get rid of that.

All right, so today we're going to do two data structures. And I think it shouldn't take too long. We'll see. Um. Oh, one thing I didn't tell you. Did you guys know that, um, C plus plus has built in array lists. Does what do they call them? They're called vectors. And it has a built in array list specialized to characters. And that's called string. So in fact there are two kinds of array lists built into C plus plus. And there are linked lists. Those are called lists. Right. So all of these things are built in. That doesn't mean you shouldn't implement them. Right? I mean, um, how many people have learned to play the Moonlight Sonata? Um. Has it been played before? Of course. Is it a worthwhile exercise to learn it? Also? Of course. Right, so. So learning to implement these things gives you a really good sense of not only what they're doing inside. So you can recognize situations that would apply later in a real application. But also now you've developed those same programing skills which you can apply to other problems when they're relevant. So it's a very worthwhile exercise I think. Um, one thing that I should mention, um, and it's going to come up, well, I really wish I had board space that I could use in tandem. Um, okay. So it maybe I'll show you an example. We'll we'll see later. The trick is, when you use these things, they're in something called the Standard template Library. And I may try to wedge in a short lecture about templates, but it's not a big deal right now. The idea is that a linked list can hold isn't really just a linked list of integers, or a linked list of zombies. My favorite example. Um, so the C plus plus one in the standard template library is just called vector or list. And so how do you tell it what type the elements are. Well you say vector and then you put an angle brackets you know less than int greater than. And that means an array list of integers but pronounced vector in C plus plus. And you can put zombie in there if you have the zombie type. And I'll show you an example. I would write it on the board, except this room makes it hard to switch back and forth. So without further ado, um, I just wanted to point that out because all of the containers we're looking at are what are known should be what we call polymorphic, because that's good for modularity, right? You write one vector implementation. Now you can use it at any type. You don't have to have a separate integer or separate zombie, a separate float a separate. Motorcycle, whatever it is you're. Okay. So, um, so I just wanted to point that out because I don't know it. I feel like situating what you've been doing in the context of real software is helpful. So that's my thought. Um, okay. We're going to look at another data structure. And you know, this data structure inside and out. It's called a cube. Um, if you're. In the US we call it a line. Wait in line. Unless you're from New York, wait on line. Right. So New Yorkers wait online. Everybody else in the English in America waits on the waits in line. But if you're British, you join the queue. That's the data structure. So you know what it is because you're in it all the time, right? You you go to Dunkin Donuts or Starbucks and you walk up and you want a coffee and you don't just, uh, um, you know, now there are people who, you know, there's 20 people waiting there, and they barge to the front and say, give me my coffee. And then they're, you know, they call the police or something on people like that. Um, particularly the, um, caffeinated people take a very dim view of this. So, um, so you join the you join at the end. Right. So there's a line of people possibly empty. If it's empty, you're at the front. You're also at the back because you're the only person in the line. Right? Um, but you're at the front in particular. And so the person who's taking orders and giving the coffee takes them one at a time. The person at the front of the line gets their order, and the person at the back waits until they get to the front, and you just keep taking off the front. So the key idea of a queue is that you're adding at one end and taking off at the other. So I already said, waiting in line to buy coffee. Um, customer service queue. This can be online. Your call is important to us. You are number 4003. In the in the waste context. Um, right. So we've all been there. We know that. He was like, right. Um, the person waiting the longest gets the next available service representative. Right? That's kind of the rule. Um, and like I said, you get mad if this isn't true. Um, if you send something to print, which I did yesterday, and I did it. And when I got there, I realized that another course had had an exam, and they were scanning using the printer. And I went, oh, no. But luckily I won. So I was in front of the queue. So I got so I got my printout. Um, you know, you can wait to get on a roller coaster, which I don't do. Um, I think when my older daughter was eight, she maxed out my roller coaster tolerance. And I haven't been since. Um, okay. Um, so you join at the back and you get. And the service is provided at the front. So you join at the back, take off from the front. It's the is the model of the queue. Now we use these spatial metaphors front and back because, you know, if a lot of people are standing and they're all facing the same way, then we would say that's the front and that's the back, right? But I just want to point out these are spatial metaphors. And as long as you have an underlying data structure. So for example, if you have a linked list with a front and back pointer, you could use the back of the linked list for the front of the queue. There's no rule the the as as long as the people in the queue observe the correct behavior. What you do under the, you know, behind the scenes is your business. So I just sometimes you use the word and then folks over bind it. So it's just a spatial metaphor for the cube. Okay. So first come first serve. You've heard that right. That's a standard thing. Um, in CSS we say first in first out and you will see and hear the term Fifo. Um, in fact some people say don't say queue. They just say, oh, I put it in a Fifo. Right. And you'll, you'll program in some environments where there's a class called Fifo vivo and it's Akira. That's what it is. There are some people who say Fifo queues and these people are a bit, you know, they're, you know, they're belt suspenders and and other things. So, um, that's okay. They're well prepared for any eventuality. But first in, first out is what it stands for. And so if I had a queue, what would I want to do with it. So you've already you've used them all the time. So what do you think the, the operations would be.

Yes.

Yeah. So you could join the queue. You could put something at the back. Yeah. AD right at the back. A push back is a common term for it in C plus plus. Okay. So add something to the back of the line. What else.

Yes. So you could.

Take something from the front. So those would seem to be essential right. We it has no cuteness if it doesn't have those things. Um not the Star Trek Q this, um, get the size of the queue? Yeah, you might want to know. Right. If you're if you're working and it's an hour before closing. How many people are out there? Right. So how many how big. How long is the queue up front without removing. Yeah. So a very common one is you just want to look at who's in front. Is that a complicated order? Not that it's really going to help because they're still at the front. But you might want to you might want to. And that's that operation is frequently called peak. I'm just going to peak. I'm not going to take them off. I'm just going to peak. It's easier. Um, okay. So the operations, um, they go by different names. Like I said, sometimes they're pushed back, sometimes it's just push. Um, it's often called NQ. You and you, you know, you NQ something. Um, and so we're going to use that terminology I think mostly um but that's the thing that adds an element to the logical back of the Q DQ is you take something off. So if you've n cubed include something that at the back of the, um, the queue, then when you want to take something off, you dequeue always from the front. Strangely enough, this word spelled exactly that way is sometimes pronounced deck, and it has. It's another data structure, so it's a little bit confusing. Uh, deck doesn't have the last, um.

This is.

I think. Well, yeah. You may. I think you may be right. Which is good, because then that means double ended. Q is what it means.

Yeah.

So which is why I write Q so anyway, we're going to say thank you. And then, of course, you might want to know is empty. Um, you could say, what's the size? And if the size is zero but is empty is a useful kind of thing. It's not hard. Um, it's one line long. What the heck? And then you might want to peek at them.

Right?

So, um, peeking does not remove anything. And again, different implementations behave differently. Sometimes when you dequeue something you find out what it is. So it both, you know, this is the first person in the queue, but they're not in the queue anymore. I took them out. Sometimes DK just removes them. It doesn't tell you anything, in which case you need to speak first and then queue. But those are details. The key operations. You want to add people to the queue. You want to take people off the queue maintaining the order. Um, you want to and then you want to know if the queue is empty, how big it is. And you know, you want to know who's in it. Um, and interestingly, that's the whole interface. That is the whole interface. Um. I think this next one. Okay. So with this summary, here's something you should notice. Um, we're not allowing you to reach into the middle of the line. So it's not like if your friend is fourth, you can bump them up to the front, right? So the queue enforces the rules that you add. You join at the back, you get removed and there's no cutting, right? You can't remove somebody from the front. You can't add someone in the middle. Sorry. You can't remove someone from the middle. You can't add someone. Yeah. Is there a reason you can't.

Even, like access? You can't even look at, like, what's in them?

No, no, look.

No, no.

It's it's not as much a line as it is a tunnel.

Um, if you're looking for a better metaphor, that could be true. A very dark tunnel. Sure. Actually, you know, some of the things that Disney World feel a lot like that to me. Um, okay. So here's an example. Um, if you've got a store, then there might be two queues. There are customers that come in, um, and then there might be a queue of orders. So the customers make orders and then you keep track of each order as they made it. And then the people in the kitchen can prepare each order if it's a restaurant. Does that make sense? Um, so you can sort of think of two different tasks. You can think of the order takers task and their job is, um, you know, from open to close. Um, if, if, if, if there's nobody in the customer to then they, you know, they go outside, they have a warm beverage and whatever they do, um, but when the customer queue is not empty, then they take the first person off the queue, then they take their order, then they take their money, and then they and then and only then do they add their order to the queue. Right. So can everybody sort of imagine this is I've written code like this. It really it really works. Um, now if you're, if you're a cook and you're working, then as long as you're on duty, you're going to do a similar thing, but you're not looking at the customer queue, you're looking at the order queue. And when an order comes up, there's so it's not empty anymore. Then you take the first order off the queue. You prepare a meal, you deliver it to the customer, and then you keep doing that. Okay. So everybody understand. And this is so common. In fact, it has a name. This is called a producer consumer pattern. You've got the order taker that's producing orders and you've got the cook that's consuming them.

Is it common to mix camel and snake case in C plus plus?

Uh, no. No. Um, I have no legitimate defense. My illegitimate defense is in pseudocode. And so there. But that's not really a good defense. It's still inconsistent. Um, so no, we would, uh, I think in this course, we tend to prefer camel case. The problem is I go back and forth between 40 and 15, so I sometimes I don't even notice myself. I've done it. So thank you for that. But good questions. Okay. So, um, how do we implement cuz. Well, let me think. I've got a sequence of elements that I need to store in order. Hmm. What kind of data structure could be used for this? Right. So some form of class. Some form of class? Yeah. Some class. Um, some form of list. And so array list and linked list both seem plausible. Right. Because a list is an ordered sequence of elements. I need to keep track of an ordered sequence of elements. Done right. It's got to be a list. Um, so then we can ask the question. Given what we know about complexity, do we have a sense of which one might be better for a queue?

Yeah, I think it.

Would be a linked list, because it's really hard to get steps on the front of an array list. Um, and if you have a pointer to the back of your linked list, it will be really easy to get from the back to you don't have to worry about the middle.

Yes, exactly. So, um, what you now. So May has suggested that if you have a linked list with a back pointer, then it becomes constant time to access either end and so you can put stuff on at one end and take stuff off at the other, or put stuff on at one end and take stuff off at the end, but you get constant time access to both ends. So that would seem to be an advantage because for array lists, we're going to stipulate that the back is efficient. We're going to put aside expansion with that. If you don't care about expansion the back is very efficient. You can get there in constant time. The front you can get there in constant time. But to remove an element means copying n things over. Right. So linked lists would be constant time for all of the operations we listed. If you have a back pointer and a size data map, you keep track of those two things. All the operations are constant time, so that's cool for the array list. You're forced into a situation where one of the operations is going to have to be in. You could put them on at the front and take off at the back, but then that just okay, well, now taking off as fast and putting them on as slow. Right. Um. So, um, you might prefer a linked list. And so let's implement an order queue. I'm going to assume that there is a thing called order lying around. And this is it. This actually. Um. What's it missing? It's missing is empty.

Empty?

Um. It's missing is empty, but otherwise, this is complete. Everything here is completely empty. All I do is. I said I've got a linked list. And so here's where that template commented on. So like, if you assume that it works like C plus plus vectors, you put the type of thing in the list in angle brackets. So if you have a linked list that could work on multiple types and you tell it, I'm going to keep, you know, order structs or order instances of the order class or whatever they are, I'm going to keep orders in here. And I've got a queue of those. Um. Sorry. I'm going to call it Q, but it's a linked list, so I've got a linked list of those. Then NQ is going to push at the back of the list DK is going to get is going to get the zeroth element and then remove it from the front. And return was what was the zeroth element which is no longer in the list. So I don't really need peek. But peek would still be nice because you don't want to take it off maybe and size just well, how many things are in the queue? The same number that are in the list. So this is. It's really that easy.

Right? Um.

Now you might have a couple questions. Big three. What do you think?

Uh, the structure is sort through the copy.

Yeah. So here's an interesting thing about C plus. Plus, remember when I told you that the default copy constructor just copies the bits? I think I said it, but if I did, it was it was quick. For data members that are instances of classes. Their copy constructor runs automatically by default. So it's only the plain old data types like ints, floats, and pointer values that just get their bits mindlessly copied. Um, otherwise the default constructor will automatically run the default constructor for linked lists, and the copy constructor will automatically use the copy constructor for lateness. Likewise for assignment operator and everything else. So data members that are instances of classes automatically get their stuff applied, only stuff that's not a member of the class. So that's sort of cool. Um, I think that's all I want to say. Um, so you might say, but I don't get it. Why should I have a queue? Because it feels like just a few of the operations I had on list. And look, it's true. It really is just a list. Kind of. But it's a list with a difference. Um, it's a list that has fewer operations. You can't reach into the middle. You can't change things in the middle with a queue. You put things in at the end, you get them off at the front, the logical end in front. Um, and so that, in fact, is why you want it. You want it not because it provides more features, but because it provides less. It provides only the operations you actually need for queue like behavior. And this means anyone who wants a queue can't screw it up. And not letting me screw stuff up is the best error reduction strategy there is, right? It won't let you write the bogus code that had people in the middle. Um, I should the I don't know if it's going to happen now. The first few times um, Metro sim was used, we've changed the assignment of it, but the first few times it was really interesting because students were trying to use vectors and array lists, and they were doing things in the middle. And it was not it was not a pretty sight. So the best. So if you mean Q, use a Q, don't use a list. And the abstraction barrier is really being is really your friend here. It's you're going to have C plus plus be the sheriff and force people not to screw up the order in the queue. They can't they can still screw up the logic. Right? They can still take all the people off the queue and then try to take another hundred off. They can do things like that. You can't. You can't fix all bugs, but they can't make any bug that involves screwing up the order internally because you don't let them.

All right?

Cuz I told you.

Um.

Next data structure. I'm calling them data structures because I'm falling into the trap I mentioned on the first day. Um, we're specifying abstract data types here. And of course we're going to implement them with data structure. So, um, I mean, sort of when I say Q, I'm talking about the abstract notion of a Q and then we drill down. Okay. Um, right. You can't see that, but I can. Um, so the next one is called a stack. And this one, you don't see it as obviously in the world. But, um, let me tell you a story. Uh, many years ago, I was sitting in my office in in Harlingen. Harlingen.

Um.

And, uh, and, you know, I got into the office. I was sitting there, you know, I finished my coffee, so I'm working on a lecture, and I'm actually writing some notes and sort of going through and taking some notes on, on my draft of the, of the lecture. And while I'm sitting there, Miller comes in and he's got his computer out and he's like, you have to see this. The student did this amazing submission and come for you. It's so cool. You have to see it. So I'm thinking, okay, well, in the middle of my lecture, I put the pen down sort of right where I am to mark my place. And then I say, let me see. And it is amazing. Right. So we have a reference implementation that's not super optimized but pretty fast. And our implementation goes like zoom and you go, yeah, it's fast. And then his went like oh my God, how did they do it. So. So we talked about that for a while. And while I was there ring something happened. And so I said okay hold on a minute. And you know you look at the thing and it turns out it's like the department chair. You always take the department chairs protocol. So, um, okay, hold on now. And I, you know, blah, blah, blah. I talked to, um, well, I guess it would have been Kathleen then. And then. Okay, so then we chat, hang up the phone, and then I pick up where I left off with Noah. So I'm looking at the thing, and it's what? They wrote it. Oh my God. And, um. Okay, so then that finishes and the Noah leaves, and then I finish, uh, my my note taking. I get the, the lecture in shape and then I leave and have lunch or something. Right. So that's the story. How is it relevant? Well, we're going to see um, let's just reprise the activity. So first I just I arrived in the office and I'm sitting here. Then I started to work on my lecture. Right. Um, while I'm working on the lecture, Noah comes in. So I pause that and I take time to marvel at the student submission. I still remember it was. It truly was. He was ever he was really justified in bursting into my office with that. It was. I'm very glad he did. It's great. Um, and if you think we don't do that, we absolutely do like the, you know, the pleasure to read points. Have you seen those on I'm sorry. Here's my rule for those. If you look at the assignment and it's like, so mind blowing, you say you guys, you guys, you have to see this, that they get the point. That's what it's for things like that. Because it because it's a pleasure. You read it and you go thank you. Thank you for submitting this. It's great. I never had any doubt. You know, every line. I knew what you were. I knew what you had done, what you were about to do, what you're doing. I can tell it's correct. I've got no problems. If you handed this to me and paid me to work on it, I would take it in in a heartbeat, right? That's the sort of thing. Um, so. So we absolutely do share things like that. We go to people's offices and say, guess what? Um, and then I had to pause there and then talk on the phone. Now, when I finish the phone, what happened was that task completed? And so then I resumed where I left off, marveling at the student's work. And then that task became complete. And then I continued to work on the lecture until that was completed and then a bunch of time. Okay, so you can see that the tasks stack up and you'll sometimes hear people say that. You say, oh, can you have one? I've got so many things stacked up, I don't even know what to do. Have you heard things like that? So, um, it's not obvious because you don't see people in a stack, but you do use that term. Um, so I hope you have some intuition. So very common case is where you have some models sort of start a task, interrupt a task, and then resume the task later. So that kind of interrupt resume pattern is very common with stacks. Um, if you call a call center very often they don't know what the heck you're talking about. They put you on hold, they call somebody else, then they get an answer. That person may call somebody else, but eventually they come back to you having consulted others. Right. So that's an example. Um, in CSS, every time anyone teaches stacks, apparently you're required to do this one. The stacks of plates in a in a cafeteria. So there's a big spring under there that holds the plates up, and you take the top plate off, and then the rest of the plates move up. And so you take, you know, there's the top plate. And then when you come and you put clean plates on those, go on the top two. They don't take them all out and put them on the bottom right. So so that works like a stack. Um, if you browse Wikipedia, I have this all the time. I start reading something and it says, and then blah, blah, blah link and oh yeah, that's interesting. And then you click that, then you click that, and then you just sort of do this until you die, I think.

But you.

You if you're a responsible person, you might come back or you might just terminate the program with an exception. Um, okay. So, uh, what's the problem? Um, the problem is that the the problem, the thing we want to model marvel is this kind of a thing starts and then other things may interrupt it and pile up. And then we want to sort of handle the most recent thing and then go back to the most recent one and then go back. Right. So we want to sort of support that pattern. Um, of course every program you've written has it has this data structure in it. It's called the the stack. Right. It's so important. It doesn't it's the stack. Right. It's just like that sometimes it's called the call stack or the function stack or the function call stack. Right. It has all those sorts of things, but it behaves exactly this way as we'll see. Um, but it also follows when you have nested structures. Have any of you done HTML? HTML is structured this way. So if you've got an HTML web page you say this is the start of the HTML, this is the end of the entity. And then you say this is the start of the body of the web page. This is the end of the body of the web page. So these structures, you know, the body has to be inside an HTML, the paragraph would be inside the body. The quotation would be inside the paragraph, inside the body, inside the HTML. So. So structures that work like that are called nested structures. And the the dolls are the greatest example of this. Have you seen those. You know you've got the doll and then you take the doll apart. And inside is another doll. And then you take it apart and inside is another doll. And I think this is the best application of quantum technology. You can make this go much further. Um. They're delightful, I love them. Um, okay, so that's another example. Oh, and this is not the right place, but I had found this picture. So here you go. Here's a picture of the thing in the cafeteria. Um, okay, let's come back to the function call stack and sort of think about that. So let's run some code. And we've drawn these things right. Stacking up the memory diagrams so we know how this works. Um, your program starts and. Oh yeah maintenance. So main has a variable x again set to five. Then it calls food. So at that point we you go through the seven steps of function evaluation. You got to define a function evaluate the arguments, create an activation record for the function. You initialize the activation record for all of the parameters. You copy the argument values into the parameters left to right right. And then you can. So that's that. You know you've done that a million times. So here's here's my activation record for food. And it's running. And so Foo sets um, you know y becomes uh becomes eight. But then it needs to set aside space for Z, which it does. But but um, before it can actually save a value in Z it has to run a function bar. So then it starts bar. And then bar kind of does its thing. Um, when it's done it, it returns its value, which is 64 in this case, and the activation record is reclaimed. Um, then you can store the value. These are not useful functions. They're just, you know, they fit on a screen. That's their version. Okay. So now we now we can resume right where we left off. We were about to store a value in Z. And now the function has returned a stat value. And we can store that in z. So it's not just the functions you have to when you when you create another activation record, you have to know exactly where in the code you are. So then when you resume the function, you say, oh, I was just about to assign Z. That's where I was, right? So you have to know exactly where you're going to receive that information. Interestingly, is stored in the activation record. And you'll see that if you take Kes 40, um, so eventually Fu returns and when it does, its activation record gets reclaimed. And then of course, eventually, Maine will finish and return zero to the operating system.

Right?

So I don't think I'm saying anything new. I'm just, you know, we're going through the process over and over and over again. So then you're going to feel very sticky and then we can talk about it. The call stack was invented in 1946 by Alan Turing.

Yeah.

So, um, do you have to read it now? You can read it later. Um, basically it's. Ha ha. I figured out stack frames, and you guys are going to think I'm going to come join me in 50 years. Yeah. Um, actually, 46 now, they sort of joined him immediately. Okay. So if we had to kind of characterize this policy, queues were first come, first served. The stack is like the worst possible nightmare of that. If you're in a coffee because you're waiting in line and some new person comes and they get their coffee first, right? So this is the nightmare of people in, um, in Starbucks. This is called LIFO. Last in first out. So first in the first thing in the queue is the first thing to come out. The last thing in the stack is the first thing to come out. So what this means is if you put a in the stack and then B and then c, then if you take something out, C comes back first, and then you can put more things on whatever you whenever you take something off the stack, the thing you get is the last thing you put on the stack. Last in, first out. Okay. Um, so here we are. Let's design an interface. Oh, no. What operations do we want? I forgot to.

Push up front.

Yeah. So push it front. Well, yeah. So we could call it push it front. We can call it. In fact, usually we just call it push, but, uh. Yeah. So we want to add a new element to the stack, push it front is perfectly valid name for that. What else? So we've got add a new element to the front in. In stack parlance we usually call it the top by the way, but you sometimes rarely see it. Also called front remove.

From the top.

Yeah. So you want to remove from the top. So you want to put things in. You want to take things out. What else. Get the size. How big is the stack.

Oh look at the top.

Um peak. Yeah it's the same as the queue. Basically. It's just what happens under the cover is a little bit different. So same operations. Um, except instead of front of queue and back of queue, we refer to top of stack. And we don't usually refer to the bottom of the stack because the top is the only interesting part. That's where you add things and take them off. Um, but just as front and back are spatial metaphors for queue clients, top of stack is a spatial metaphor for stack clients. If you put it on a data structure that has a thing called, you know, back or front or bottom or last, or it doesn't matter as long as you give the as long as if the client pushes something on, then if they pop something off immediately, they get that same thing back. They always get the, um, you know, you give the, uh, LIFO behavior. Okay. So how would we implement it? Well, gosh, we need to keep track of the sequence themselves. So, you know, so any list will do. Any list will do. Right. Um, the observation now is if we want to pick a list or linked list with some other benefits that we have. Um, the good news is there's only one busy end. See, the problem that array lists had with, um, with queues is that you needed to be able to perform efficiently at either end. But with the stack, you only have to be efficient at one it. Ha. So now, um, if the top of the stack is at the end of the array list and we're throwing aside this issue of expansion, then, um, it then that can be the top of the stack and that'll be fine. And it'll be constant time access modulo the issue of expansion linked list with a back pointer. You could put it at the back, but you could also put it in the front and then not have a back launch because again, there's only one. Uh, you'll often hear this phrase, there's one busy end. That's the end of the list where all the changes are happening and the other end is less busy. Um, old architectures, computer architectures used to have a thing called a top of stack cache that would keep track of basically the data in the most recent functions, up to however much data fits in the cache. So they would call it the top of stack cache. And as with the queue, you could say, well, wait a minute. Why not just use a list and the argument is the same? The interface is restricted on purpose because we don't want you meddling in the stack, right? If you said stack that you're committing, I'm putting stuff on the top of taking stuff off the top. It's not. I'm putting a bunch of things on the top, except for my good friend and roommate who will go further down. I guess maybe you do that to your enemies. You put them somewhere. Um, but you can't do that, right? You can't, like, demote things in the stack. Um, you can't do that. Um, there's a typo there. I don't know what read is in that.

Um.

Okay. Um, but otherwise it's the same interface. And I'm not going to show you the implementation because it's the it's the same, right? It's equally good. You can each you're an implementation of the stack can have an array list or a linked list and then you know, push back, pop from back. Push front, hop.

From.

Front to back at remove from back. You know, as long as you are working on the same end, it's okay. And what had these delightful pictures? So I'm going to put them up because I thought they were funny. Um, so if I push a puppy dog, I get a puppy dog on the stack, and if I push a monkey, I get. Now, now there's a puppy dog and a monkey, and then a pig is on the top now. And then if I pop, the pig comes off. And if I pop. The pig run away. Um. And now we're going to pop. Oh, sorry. That was the end of the pub. Sorry. And now we're going to push a fox on. You get the idea.

Right. So. I thought. Um. Oh, good. All right. Oh. Um.

So I want to look at an example that is near and dear to your heart, or could be if you're a compiler writer. Because every compiler has this problem of nested structures, right? So you've got a function that has a body inside curly braces inside there you've got an if statement that has a then clause inside curly braces. Inside there you've got a while loop that has a body inside curly braces. Inside there you've got an array access that uses square brackets. But the index is a function call that uses parentheses.

Right?

These things match. Have you ever gotten, you know, unmatched opening curly brace era from the compiler? If you haven't, just leave one off and compile and see what happens. Um, so the the compiler has many jobs to do, but one of them is it has to verify that all of these different kinds of braces matched. And so we can we can sort of think about that problem a little bit more carefully.

Um.

So, um, let's let's raise a problem. Suppose suppose I read in a program text as a string, and I remove every character that isn't a brace, but I preserve the order. Or another way of that is you write the algorithm to ignore anything is not a brace. And so you can get open and close friend. By the way, the single, uh, the singular is parenthesis and the plural is parentheses. And if you don't want to remember, you just say param and params. Um, I often hear people say parentheses. I may have said that too, in my wayward youth. Um, but I found my way. And it's parentheses in parentheses or so we've got. Or round braces removes the whole problem because these are curly braces. Right. Open and close. And we have square braces, square brackets. And in fact we also have angle brackets. But angle brackets can also be less than and greater than. So there's a little the compiler has some additional work to figure out which ones are which. Um, okay. So here's the question. Balanced or not balanced. Okay. Balanced. How about this one? How do you know. So I'm getting thumbs down. How do you know?

You look at.

The like the later five. I'm a little confused on like the square brackets nested within the round brackets, even though there's like a single restriction.

Well so all so we've removed all the program text so you can wonder about the context, but you just have to ignore it because it's gone. Um, but if you're, if you suppose you call a function and inside you pass, you know, array sub three, then the closed bracket for the array sub three has to be before the closed parenthesis. So the function call for example. Does that make sense?

Okay.

Um, if it doesn't, let it sink in and just try to figure out, how do we know it's not balanced?

Outside of the square parentheses. But the other randomness is inside of that. It's not nested in the same place.

Uh, I think.

I think I get it, you're talking about this place is wrong. And so since we're going to write an algorithm, we want to know how we know that. And of course, you can just be a human and look.

Yes, I.

Think you have to, like, resolve the, uh, curly parentheses first, um, before you add another thing. So then we can use a stack that, like stacks above.

Okay.

Um, you're getting there. So we're going to go for a stack. So that is in fact, what I'm going, um, for right now, I would just say, like, if I were doing this, what I would do is I would like, um. if I see an opening curly brace, I would say, okay, I've got an open curly brace. Then I've got an open parenthesis, then I've got an open square bracket, then I've got a closed square bracket. So that has to match the last open thing, whatever it was. So for it to be legal that that has to match an open square bracket. When it does I cross them both off. That's discharged. That's the way I would do it by hand. Then I got to close. Well, the last not crossed off opener is a print, so that matches. So then you cross those off.

Now I've got an.

Opening square bracket okay. Remember that opening for an okay closed square bracket. The last open thing was not an open square bracket. So that's bad. So the two kinds of braces sorry. The two sides. Each kind of brace has an opener and an enclosure. And the closer the closure has to match the opener. And whenever you encounter a closer, it has to close the last open thing. Right. So we're getting algorithmic hints here.

So if we were to call this on the set like recursively, uh, every time we see an opening, we'll put like a new block on our stack. And for each block you can either, I don't know, a different opener or even closer to the block we're currently in.

And you're thinking about it. Well, this is all good. This is all good.

And so those are the only things that are allowed. And if there's another thing other than those two things, then you have an error.

Well, yeah. So um, we we're going to so we're going to determine success in error. So one error is what you just mentioned. That's where you get a closing. And the last unresolved opener doesn't match it. So that's a then you say fail. Fail.

Yes. Um.

This would seem like the case here. But another way you could fail is that if you have. You get to the end of the string and they're still stuck in the start. And then that means you've also failed because you haven't closed something.

Right? So you can you can fail because you get a mismatch and you can fail because when because when you run out of input, there are still unresolved openers. Exactly. Excellent. Oh, this is good. Is it really okay? Um, okay. So I think we've resolved that one. Let's let's play the game again. Yeah. So.

Yeah. Okay.

And this is the case you were just telling me about. Um, here's a case where you got a bunch of openers and then some things closed. All of those match. But there are some unresolved openers, Right. Um, and then in this case, you can get a closure and it doesn't match the corresponding opener because there isn't one at all. Right. So this is another error case. You got to close it and there's nothing to look at because these two are resolved. So they're gone. And so you open this and you try to find the previous opener. And there isn't one at all. So that's another case. Okay. So not balanced. Um, so one way to think of it in terms of the, um, pause and resume semantics I was describing before is you can say that each opener starts a new task and it really does actually. So if you're a compiler and you get an open curly brace and it's in the body of a function, I'm now compiling the body of a function that's my current task. And then I'm going along. And now I have to compile an if statement. And maybe there's another curly brace. So now I have to compile a block of code that goes inside the then part of an if statement where the elves or whatever is right, and it sort of goes through like that. So it's I don't think it's a stretch to think about the openers as the start of a task. And so any opener that hasn't been resolved has to be resolved in the future. So you have to store those away. Um, whenever you encounter a closure, it it ends the current active task. So when I, if I have a function body and there's an if statement, when, if I get to the closed curly of the if statement, I finished the if statement. And now I can go back to the compiling the the body of the function. This is actually the way the compiler works. Uses an abstract syntax tree, but it it does work out this way. So at the end all of the tasks must have been ended appropriately. Um, I'm trying to imagine a a real life, you know, given my example of Noah. So, um, you know, if I'm talking to the department chair and she doesn't know that I'm, uh, I was looking at this student's work, and I. And I tell her, you know, nice job on the assignment. She's going to go. What? What are you talking about? Right, I have to I have to close the task. I have to close the task I'm currently engaged in before I close a previous task.

Um.

Okay. So how much time do we have? Some time. I'm a little on the fence because I have another thing I might want to do. I was a little bit unsure how the timing of work out. Um, we've sort of talked about this, uh, in words. Um, but you could draft a pseudocode for this. Okay. Let's take five minutes into it. Talk to talk to folks. Um, and so you're going to write this. Don't write the C plus plus code. Just write it in pseudocode so you can say things like while there are characters for each character in the string, you know, you can say stuff like that. Um, and you can just say I have a stack before you start at the beginning. Create a create an empty stack. Right. So you can do that. Um. Yeah. So that sort of thing.

Okay.

So go ahead and just think for a minute. Um, jot down on paper or computer what have you. Think it through. We'll take like, um, four minutes. Four minutes.

So, you know. I guess that's. More. Like, just. You know. I think. You're using this. Would you take it? Or not? I don't think so. We'll try to come up with it. Oh, by. The way. It doesn't match my physical properties. But you know what? After all of.

Our.

Lives will.

Be. So as we kind of close. Yeah. Yeah. Yeah. Oh, right. Yeah. Yeah. Yeah. All right. All right. Like the rest of it.

The rest of us.

We did. I don't think it has, like, everyone's like. Oh.

I didn't say that. I didn't. Yeah.

Okay.

So let's say we.

Started out with.

That.

So.

Let's see.

Oh, wait. No. Michael. Yeah.

No.

No, we're not okay. Let's go back. Oh my.

God.

Oh, look. It's okay. We're. Like. What is going on here? Yeah. Yeah. All. Right. Here we go. Yeah. All right. Back to back. It. Looks. Like.

You don't care about things.

Like that? Yeah. All right, so, um, if you haven't.

Quite worked it all out, that's okay. That's fine. I'm just, uh. Uh, now, I did hear some discussion that I think is great, but probably not. Um, what I'm going to show. Um, so if you're thinking of doing it recursively, first of all, array on recursion fan. But the reason I don't want to talk about that is it uses the call stack as the implicit stack. And I want to make the stack explicit. So it's not that you were wrong if you were doing that. In fact, you were good and noble and I appreciate it, but we're not going to go in that direction. So let's assume that we're going to do it sort of loosely. Um, where do we start? What do you think? What's the first?

Step.

Okay. Make a stack. What kind of stack? What kind of data are going to be stored on the stack? Cha cha. That sounds useful. Okay, so we'll make a cha stack and we'll give it a name. What's a good name for it? Open brackets. That sounds like a good one. I think I called it pending openers, I don't remember this is my code because I looked at this and I looked at it. Is this so he calls it whatever he calls it. Oh, he just says stack.

It's really good. Thank you.

So I, you know, cha stack would be better or open or stack or pending open or something like that. Okay. So we got a stack. The stack is empty. So what are we going to do.

Check to the screen like this.

Okay. That's interesting. Why even.

Because if it's odd, something. Oh.

Oh, interesting special case. That's true. Right? If it's an odd string, it can't possibly be balanced. Okay. Good for you. Interesting. Special case. Um. All right, so the string is even has an even length. So now what do we do?

Loop through every character in the string.

Yeah. So we're going to go through the string. Just sort of the way I did my fingers though. So we'll go through. So for each character see in the string what do we do. Um let's see um, in the tufts. The blue tufts.

Yeah. If it's an opener, we're just going to add this.

Okay. So if it's an opener, push it on the stack. Okay, good. What else.

And if it's a closure, then we have to check if it matches the top opener.

Um, right. And if there's not a top opener.

Then you just.

Then it then it then faults. And if if there is an opener but it doesn't match, it falls. Yes. Okay, we got that. Um, okay. Good, good, good. And then we're just. We're nearly done.

Actually. Now we need to check if there's anything else on the staff.

Yeah. So you keep doing that until you run out of string characters. And then at the end, is the stack empty and you can return is empty stack, because if it's empty, then they were bounced. And if it's not empty, then they were not perfect. So um, so this is the code which has some advantages over mine, except for the name of the stack. I have to say. Um, so you initialize the stack, and then as long as the expression has any characters in it, you get the next character. If it's an opener, then you push it, which we said, um, if it's not an opener, then it has to be a closure because we're ignoring all the other characters. One way to do that is to say if it's not a closure, then ignore it. But here we're just pretending they're not there. Um, if the stack is empty or the top doesn't match the current character return false. Otherwise pop. And then at the end, return is empty. So it's not hard, actually, right. It's interesting. So you guys are going to become compiler jockeys? I'm going to redo 15. Um, so let's so hopefully that code is sort of loosely in your mind. And let's just sort of follow an example. So we're going to, we're going to go through this sequence of characters. And we're just going to follow that algorithm now. And then hopefully we get the what we agree is the correct answer. So we're going to start with the first character and that's it open. So it gets put on the stack. Then we get another opener that gets put on the stack. Then we get another opener that gets put on the stack. Now life is interesting a little bit. We got to close it. It matches the top of the stack. So we pop that one off. Okay. So now we get another closure. And so now we want to see if that matches the top of the stack. And it does. Now we get a note that gets pushed open or gets pushed. We get a closure, but it does not match the top of the stack.

OO is.

Returning false. Um, I think. Um, I have to show you one that succeeds because otherwise it would be unsatisfactory. Okay. Um, and there's a whole implementation in Korean matching CPP. There's also a grace matching, which is my code. But, um, my code uses a few things that count 15 students may not know about, so I would prefer period matching. So, um, it's linked from the calendar. So. So there that stacks.

Um. One moment. Huh?

Interesting. Um. Don't go away.

Don't go.

Away.

File io.

I think I want to. I don't know, I'm trying to decide if I want to start this, this topic or not. It's, um. I don't think I can finish it, so let's see. Maybe I can just get started and just kind of mention, uh, at the very least. I can reveal our course theme song. So that's very important for the.

Audience. Okay. Um.

So The Young Rascals in 1967 posed this vexing software engineering conundrum, right? Because, yeah, that's what they were talking about, software engineering. Um, and, uh, and so the answer is. Strong data abstraction and rigorously enforced invariance. Right. So those are the two. Then you can be sure in a world that's constantly changing. Um, and so I just wanted to get this started and we'll do a few minutes on it and then. Um, okay. So you might ask, what's an invariant? I asked this question. So invariant means unchanging. Any philosophers here? You know the poem of Parmenides. You know that the the world is eternal and unchanging and spherical and all this stuff. Um, so an invariant is a thing that doesn't vary. It doesn't change in math and computer science, it's a function, quantity, or property that remains true under certain transformations. Okay. So what does that mean for us? Practical. And why do you care about things that don't change? Well, it turns out that when things are changing all around you, the things that are stable are very valuable. But there's more to it that your brain can't keep track of everything. It just can't. You're a human being. You have a finite brain. Um, and so we need things that help us understand when our algorithms are correct or incorrect. And so in variants that are clearly articulated and enforced can be a big part about that. And there are two kinds that we're going to look at. Loop invariance. We'll see when we do sorting. Mostly we'll deal with what we call representation invariance. So I'll just tell you what those two are. And then maybe that'll be a good time to start. So a loop invariant is some condition. That's true at specified points in the code. But actually a code invariant is something that's true at particular places. So a loop invariant if you're looking at a loop you're going to pick some time and you're going to say whenever we get here this thing has to be true. And the most common place to have that is right at the start of the loop. So in a while loop, it's sort of right before the wild line. You want to make sure it's true. Then, um, and then every time you get back to do the test, you want to make sure it's true before you do the test again. Right? So that's that's the most common. Uh, time to check a loop in theory. Um, like I said, we won't see many of these right away. Um, but we'll see them when we do sorting. Um, but it's, it's worth having a couple examples. So if we look at the thing on the left. So this is a function that, that purportedly adds up, um, a list of numbers stored in an array. It starts off with the result and then it's got a loop and then it returns the result. Um, we could try to formulate the, um, invariant, but I'll help you out. So usually we start to get a little bit formal when we write down invariant. So you would say at the start of the kth iteration of the loop result Salt contains the sum of the elements zero up to k minus one, up to and including k minus one. So if that invariant is true, then when the when the loop ends on the last test I is going to be equal to n, and that means that result is the sum of everything zero up to n minus one. It's the it's the sum of everything in the array. If it's true, is it true at the beginning? Um, yes. Because I before the test. So that's right. Between this and this, um, I is going to be zero and the sum is zero. And that is indeed the sum of all the elements in the empty interval. You know, we haven't looked at it. Um, and every time you go through, you'll see that you might change the, um, in this example is not so clear. You might screw up the invariant briefly, but then before the end of the loop. And this is how it helps you. You put it back. Right. So the cool thing about it invariant is it gives you a thing you can check, but it's also a checklist while you're programing. When you get to the end of the loop, you can say, look, I said my invariant was these two things have to add up to be the same. And then you and then you say, oh, wait, that's not true because I added one thing to one. I made the credit card transaction, but I didn't actually list the delivery. Make the delivery schedule. Right. So you do the two things. Now you've added one more cleanly. So it just gives you a way to check this your way through. Um. And so the other one is a little bit more complicated. Um, I'll say this and then we'll talk about representation invariants. Maybe next time. Um, so use it like a checklist. Um, first know what it is. That's often the best thing. Just saying it out loud and writing it down, putting it in a comment can help a lot with your. Because now it gives you a thing you can keep in your head while you're writing and see if you screw it up. Um, the loop initialization should establish the condition, so it should be true before the first test, the invariant is assumed true at the start of the body of the loop, but if it gets messed up. Then it's reestablished by the end of the loop. So this is how you use it as a checklist. Okay, we'll stop here. So start thinking about invariance. Um, I know when you're writing loops, try to think about it. Think about how it looks like.

So the question is. What if.

UNKNOWN
I didn't tell.

You. Oh. Nobody I.

Know it. Okay I wouldn't. Like.

That. For no reason. Oh! Dude. Where are you going? Uh.

If you need help.

That is because I'm.

Assuming you got that spot.

Right now. So I actually have a lab prepped on it, but sort of a.

Full on labs.

Um.

So I think in terms of the required assignments. No, but if you want to learn how to do it, uh, I, I, I have a mini lecture prepped. Um, the lot also has one. I'm sure it's good, too. Um, so we.

We can.

Absolutely cover it. I'm just trying to figure out where. Yeah, yeah. So, like, today, I had a little bit of extra time. I figured I'd started hearing. If I've got a theme like that, I might do it.

Okay. Sweet. So I. Just stopped at. Um, literally a block back to the point. Back to that point on the block which struck me. Like, is.

There a way to get.

Back to you. That's it for today. I.