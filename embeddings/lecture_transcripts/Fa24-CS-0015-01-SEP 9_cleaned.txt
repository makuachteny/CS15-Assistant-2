Uh, there was a question about, um, the calendar, you know, are there things you have to do before class or, um, you know, during class and after class? And, um, my experience in assigning before class readings is like 99% of the people don't bother. Um, and so, uh, and while that, you know, so here's here's the deal. That's it. I was scrolling the wrong one. I have to scroll the one that's actually on. Um. So the things that say read are, um, you know, textbook readings associated with the material of that day. If you're an organized person and you want to be on top of it, that would be more like my wife than me, then by all means, read that right. Um, the lecture notes. You're welcome to try to look at them, but I think the last version of this was updated. Well, I updated it at 12 and then I think again at 1230. So the, um, as I mentioned last time, lecture notes are kind of up to date. About a day after the lecture, because sometimes I change them and then there's not even time to save them back. And then I do it. Um, so you can look at lecture notes or not, but but if you do, then you should be aware. You should. Well, you should come to lecture and then you'll see what's different. But if you somehow missed lecture, you know, don't expect it to be current until the next day. Uh, other items that are important for, uh, um, you know, so these sorts of things, the, the code files are usually about the lecture. And again, you're welcome to look at them. They might change slightly. Um, this one only change like a couple comments. Change. No big deal. Um, and things like read intro to valgrind. That's something you need for the homework. So basically, there's nothing I will not give you a quiz on material that was announced on the calendar, but not otherwise, that we haven't otherwise had a chance to talk about. I won't do that though. I do have a quiz about the admin page, but no time for that today. Um, but that was assigned last week. Right. So my assumption is that a week later, you definitely have read everything. So that's my does that does that help clarify? Okay. And if you of course, if you have questions you don't ask on Piazza, um, we all live by this calendar. So, uh. I want to be as clear as possible. Um, and then we're just upfront about what the expectations are. All right. Um, so today, no play. I'm sorry. Um, I don't think they'll ever be another play. This I don't know, we'll see. Maybe we can get something together. Um, but anyway, so today we're going to continue our discussion of array lists, which we started last time after. Of course, the big idea last time was data abstraction and cost and cost. We're really going to study later, but we started diving deep into data abstraction last time, and that's going to be a theme all semester long. So today they'll just be like one slide of some terminology review. Um, we'll get back to where we, you know, try to remind everyone where we were with array lists. Um, a little bit of a note on constructors and destructors and overloading. Um, you may or may, if you took 11, you've seen constructors and destructors, but you may or may not have seen overloading. So I'll just mention that today. Um, you'll get time. You'll also see it in the lab and in the homework. So plenty of time. Um, and then we'll, we'll talk about implementation decisions. So last time was all. Bowler hat. Today is one here. Um, we'll see how they work. And then we'll do some we'll do some programing. And you're welcome to join me if you like. Okay. That's the plan.

All right. So last time, um, we mentioned data abstraction and I gave you the term abstract data type. And I just want to hit that again because it's very common in the industry. You'll hear it all the time. Um. Types represent, at a first level of approximation, the sets of values that something can be. So in C plus plus you associated type with a variable. That variable can only hold data that conforms to the type. So if you have an integer variable you can't store a string and you're not supposed to. Right. And the compiler will yell at you, um, if you're supposed to store a boolean value, you should really only store true or false in there. Now some of you will get all like, oh, but I know zero and one way, you know? But uh, true and false are the real thing for booleans, right? When you go down the street, someone you know and you say, wait a minute, isn't the thing, isn't the cleaners on the next corner? They don't say, you know, that's one. They say that's true, right? So use the one that's clear. Um, integers. Now, not for this, not for today, I guess, But. So in C plus plus R a finite approximation of integers. So they're integers mod two to the 32 minus one. Positive and negative. Um, characters are individual characters, so you know what to type is. Right. That's you've been programing. Um, now last time we mentioned that the problem is that C plus plus didn't anticipate zombies and menus and schedules and appointments and Facebook friends. Does anybody use Facebook anymore Instagram stories or does anybody use Instagram anymore? Okay, good. Um. So rather than try to build everything into the language that anyone would ever need, which is not not not a herculean, herculean task, it's impossible. Um, they did this. They said, okay, we're going to give you a way to make new types and then subject to some programing by the person wearing the long hair. The implementer. You can use them pretty much like all the built in times. That's the idea. And we'll also ship a bunch of predefined types like that, like string and IO streams and all of these goodies that we rely on. So, um, in the world of computing, an abstract data type is a specification of some new type that gives you, you know, what kinds of values it can range over, but also what operations you can perform on it. Right? If someone said you could store integers but you couldn't add them, you would be like really horrified, right? Because so if they're integers, what can you do with well, you can add them, subtract them, multiply floating point numbers. You can do that too. But it's different as you will learn in 40 what actually happens. Um, strings. You use the plus sign. You don't really add strings you concatenate. Right? So every time you define a type, you have to say, well, what what are the what are the legal values of this thing? And um, what can you do with what do we store? What do we do with it? We mentioned those questions last time. So an abstract data type is a general term, a programing language independent term that just says it's a new type that is abstractly specified, what values it can hold and what it can do. And we don't commit to how it actually works. And if you think about it, you've been using things like ints and you've been using strings and you've been, um, printing stuff on the console and you have no idea how that works. Well, maybe a few of you do, but, you know, you you don't have to know anything. You go into your first programing class and they say, okay, we're going to use print. So you print with the last, last character, you put the destination on the left, see out there what Sierra or whatever file you open, whatever goes there, and then the data you want to send goes on the right. Right. You learn that that thing is pretty complicated, I have to tell you, but you don't care because you can use it. So, um. So this is the key. Um, a data type is an abstract data type. Usually it's higher level besides enter something like that, but that it's specified abstractly. What can it hold? What can you do? Um, data structures I mentioned last time, some people use the term data structure to refer to the abstract type, and I sometimes do that too, out of habit. Um, but a more useful definition is a data structure is an arrangement of data. And usually we're very concrete in memory on disk. Then in this course it's always going to be it's almost always going to be in memory. Right. So what is the data layout in memory. What are the things that are there. So we'll use data structures to implement our abstract data types. And we'll use classes as the C plus plus mechanism for introducing and defining abstract data types. Um okay. Any questions about that. So that's just that's our review.

Yeah. So what a struct. Also be an example of an abstract data type.

Oh well so struct is a language keyword. And so it's not kind of a language independent concept. It's a thing that is very specific to C and C plus plus. And they're slightly different in C and C plus plus. And weirdly struct in class are the same thing with different default visibilities in C plus plus in C it's very different because you can't put functions in there. So they're different. But so usually when we use the the the struct thing in C plus plus we're talking about a data structure. We're saying I want an integer here. And then I want a string here. And then I want another struct that contains this and this and this. So usually we're doing the data layout part. Have you seen structs. Do you see that in CSS 11. You may have used it usually for laziness. So we'll we'll do it again. Okay. So last time we we were talking generically about this abstract notion of a list. And abstractly we can have a list of integers and floats and strings. A list of animals. Um. Mallard found those cute pictures, so he put those there. Um, so the notion of list is kind of, um, what we would say agnostic about the data in the list. Um, it kind of has the same idea. It's an ordered sequence of elements. So ordered means there's the first one, and the second one doesn't mean it's sorted in alphabetical order. Nothing so grandiose. Just, you know, if I'm reading you guys left to right, then you are the first one. You're the second one, you're the third one. And I don't know whether you're in alphabetical order or not, but it doesn't matter. It's positional. Whoever's first in the list is first in the list, and there's no particular constraint. Um, the size of a list can vary, right? So it usually starts out empty and you add new elements to it. You may take elements out, we may reorder them and sort them by other means. Um, and, but the size can grow and potentially shrink As you know, you remove an element. It's one shorter. To add an element, it's one larger. And last time we brainstormed some ideas. And this is sort of a combination of the two sections and whatever I had in my head. So all of our data structures, all of our data structure implementations in C plus plus you have to have a, you have to think of explicitly about create and destroy. So when a client says a thing they have to say I would like a list. And you create a list where C plus plus does, but you help you initialize it. And then when the client is done, either the client or C plus plus will tell you they're done. You don't have to know who's telling you. All you have to know is they're done and that's what destroys it. And we're going to see an example of that. So that's going to be all of the abstract data types you're going to have create and destroy. I mean, what fun would a data structure be if you couldn't create an instance of it? Right. Then it just seems like just me. Um, you could have a list, but you can't. You can't. But this is what it would be like if you just imagine a world. But I won't give you a way to create me. Um, so you want to find out how many elements are stored in the list? We're going to call that the size. There are two things that you might plausibly call size. And I'm going to try to be very consistent in our data structures. I'm going to try to use the term size to refer to the number of client elements in the data structure, not some other thing which could plausibly apply. Um, we want to add new elements. Maybe we want to have separate functions for the front of the back or at an arbitrary position we could remove an element. Um, if there are things in the list, we might want to find out what thing is there. Who's in slot three? Oh, the person in slot three, they have a different cell phone. Actually, I just I saw someone I hadn't, I saw a bunch of people I haven't seen in like 30 years over the weekend. Um, their phone numbers have changed. Who knew? Right. So you go in and you might want to change. You might want to update the value at some position. Um, you know, in print, for debugging purposes, you should just always do print. And then if the client says, I don't want to print, then you commented out at the end, but you should always do it because your program is not going to work. Sorry. It's just not. And the first question you're going to say is, ah, it's crashing. Well what's in the list? Oh, now I have to do a print. Now the print function crashes, right. Much better implement it up front, debug it up front. Then it's there when you need it. Um, just plan to debug. Um, now, if we turn these things into C plus. Plus, they start to look like this. Uh, now you'll notice I'm writing element type here. I think I did that last time too. The operations are going to be the same. If it's an integer list, then you just replace element type with int. If it's a string list string, if it's a student list, you know the student class is named this. It just says student whatever, right. Um, I just did that because if we look at INTs, there'll be two things called int. But the index is always an inch, but the data is only an integer. The data in an array is okay, but so these are the operations. Anybody surprised? This is a good chance to remind you of what C plus plus looks at. It looks like it's going to. It's going to get worse I mean better it's going to get better. So we'll come to you first.

Sorry.

That's right.

If it says element type. But you said like the elements can be of any type. So what if there's integers and strings.

Oh no. Excellent question. So in C plus plus you have to say what all the elements of the list are in advance. And so you can't have an animal followed by a student followed by a float. So they're what we call homogeneous lists. All the elements of our of of are the same are of the same type.

Why don't we consider lists as data structures.

Well this is that ambiguity again. So if the data structure is allowed in memory then list is an abstract concept. If the data structure is also the abstract thing is also the abstract thing, then it is individual. So it's it's that unfortunate ambiguity between the term data structure. So it either is or it isn't based on which which definition you apply. Um, so we're going to well we'll see. Okay. So um, just to get even a little bit more. Um c plus plus e, um, we're going to create a file that ends in H which stands for header file in C plus. Plus I think I said last time three roles in an abstraction, three files at least the interface is going to go in the dot h file the implementation. So whatever your class name is, class name which the implementation doesn't have to be. But that's the normal convention. The implementation will go in class Namecheap and then the client will be. You know poker simulator, dot CPP or whatever the name of the application is dot CBB. So here's the dot h file. And the way you define a class is you write a class and then a space, and then the name of the class. And then in curly braces you put what are called the class members semicolon at the end. And we usually divide up the things in a class into two parts the public part that the client can access, and the private part that the client cannot access. Right. So it's private is like staff only. Okay. So question um, where's. So the whole thing is that the interface because an interface doesn't include the implementation specific stuff. So where's the um, I'm not used to the view lines in here. So the where's the actual interface? Uh, no. So the CPP file will contain the implementation. Well, the class list of cpp will contain the implementation, but the interface is embedded here, but there's other stuff. So which I just want to know which subset of the lines here represent the interface.

All the stuff under public and support private basically. Although you could also say that the class name is part of it.

Uh, yes you could. And I'm glad you said that because I think I've got a slide on that. Um, right. So, uh, we'd say the dot h file contains the interface, which is true, but it isn't the interface, it contains the interface and other stuff that C plus plus needs because it's boneheaded and not as cool as Java. Um, okay. So this this the public part is the interface. So that's really key. Um, other things in the interface include external documentation. So there might be web pages that tell you how to use it. Right. Um, and then read the style guide because when you write programs you have to follow it. And I won't follow it today because I don't know if I'll have time, but also unlimited and screen real estate so you guys can have a big file. You can put detailed comments in. Um, and I do that when I'm really programing for myself. I'm just going to leave it out today for other reasons. So all of that stuff is actually part of the interface. Anything that describes how you use this, what it's for, what operations there are, how the operations were, what happens if you give a negative number as an index? Right. Um, all of that stuff is also part of the interface because the client can see that anything that that's that the client either can do or will see should be documented.

And the client see the comments you write in your code.

Well, so this is an interesting thing. Normally no. But um, you know, we make some assumptions in, in a class. So in an educational environment. So you may assume when you turn work in that the Tas can read the comments in Europe they will have access. And even though you would normally put the things in a web page, in fact, there are now frameworks for this. So for my other courses, this thing called doc and I put all the comments in the code and then I run E doc and it makes a web page that extracts all the contracts and puts them on a web page. So that's the that's the industrial practice. But for our purposes, you'll just put it in the code because we have to draw a line somewhere. So we want you to do the documentation. But you know when you when you get an internship or a job, they'll tell you how they distribute it. Then you'll do whatever they say. Okay. Um, now the two things at the top are the constructor and the destructor. Constructors beginning constructors have the same name as the class. Destructors have the same name of the class, but with a tilde in front. So list if the class is list, list is the constructor tilde, list is the destructor. And I just want to mention that now both for review, but also, you know, for students who maybe haven't done as much with this yet. Um, so here's the rule that C plus plus has. It doesn't do this for instant things, but it does it for classes. Any time a memory is allocated for an instance of a class, a constructor must run. We'll see. There's there like five of you. There are different categories of these things, so there's a whole bunch. Um, but some constructor must run whenever you allocate space. So if you declare a variable that allocates space, constructor has to run. If you use new to make an instance of that thing, constructor has to run, right. The idea is that, um, and similarly when you, um, when a variable disappears, a destructor must run. That's it.

Okay.

Um, so what are the jobs in these things? Why did C plus plus. Why do they mandate this? You know, they must be useful for something. Well, here's the idea. A constructors job is to initialize a new thing. So C plus plus will allocate the memory. But it doesn't know what your class is for. So it allocates the memory. then it calls your constructor, and your constructor initializes the memory. And there are a lot of rules about this. But that's that's the basic idea. This means that a client can't use the instance until you've initialized it, so they never see if your code is right, they never see an invalid instance, right? That's part of the implementations job. Whenever you create one, they have a valid instance. And now they can start doing stuff. Yes, when we cover constructors.

And constructors and yes 11 it was saying that it is called whenever the variable goes in or out of scope, rather than just when the result is that.

Yeah. So the C plus plus term of art is when a thing goes out of scope. And that's related to a concept called lifetimes. Um, its scope makes more sense when you're referring to a local variable in a function or a block, because at the end of the block or function, it's gone, and we say it's gone out of scope, and then it gets destroyed on the heap. It goes out of scope whenever somebody calls delete. So so so yes, that's that's perfectly correct. And I was just trying to avoid the kind of C plus plus jargon about it, which I'm generally fail at because you have to use it at some point. So if you know the term out of scope, yes. Um, a destructor runs anytime something goes out of scope. Uh, okay. So constructors give you a valid instance. Um, so then clients can start doing stuff and they're not going to get.

Oh no.

Something was initialized by some random value. -18 million. And for, you know, um, they get a valid thing um, and destructors clean up. And what does clean up mean. Well, in um, in our case, it's going to mean if your implementation allocates memory on the heap, then it will get rid of all the memory you allocated on the heap. It'll give that it'll recycle it. So then the heap manager can use it again. Um, destructors can be used for other things. Um, um, my my dance partner is an orthopedic surgeon, so she, like, drills into people's legs and stuff. And, uh, if you have. And they sometimes have remote control surgery. Have you seen that? What if you what if what if a variable goes out of scope and while the drill is on, you want to turn the drill off, right? Wouldn't that be important? Yeah. So so cleaning up can save files. It can store things in databases, update credit card stuff that if you haven't done it yet, in our case, it's going to mean you recycle memory. Okay. That those are the general jobs of constructors and destructors. I'm just going to mention, um, one other thing which is missing in the assignment. Um, C plus plus is a concept of overloading. So you can only ever have one destructor. There's no such thing as an overloaded destructor, but you can have more than one constructor. And they all have the same name. That's what overloaded means. Overloaded means you have an operation or a function. You have multiple functions or operations that all have the same name. How does C plus plus know which one to call? Yeah. So the number and the size the number and the types of the parameters. So if you if you have a default constructor then if nobody says anything that's the one that gets run. That's the one at the top. That's called null or default. If you don't define one C plus plus we'll define this for you and it will do nothing. It will not initialize that. So you should always divide. Um likewise it will define a destructor for you that does nothing. If you have other ways that you'd like to initialize your data structure. Maybe the client knows for a playing card what the rank and what did I say the rank and suit are. Then maybe you have a way to initialize it that way. Okay. Um, so that's overloading. It's not just for constructors. Any function or operator in C plus plus can be overloaded. So that's pretty cool.

Uh, this is the order of the. The constructors matter. Like, does it matter that, um, so you can put in any order?

Yeah. The order of the declarations in here really doesn't matter. You can even put the private at the top. You can you can even do like public one thing and then private the next thing and public then you can stripe it. Um, so no, the declaration order doesn't matter. Okay. Um, unless a definition refers to a previous one. So it only matters if you like defining new types, and then you can't refer to a type until you define it. But for for things like the functions, it's not going to matter. You can just find a way that works in the documentation. Yeah.

Uh, what happens if you only put like one of the parameters, for example, like let's say, you know, that's an ace, but you don't know. It's like a club. Um, is it a two parameter?

There's no function that takes one parameter. So if you, the programmer, think that's a reasonable thing to do. You would have a third constructor that just takes One of those things.

You make a private constructor.

You can. And if you want to be mean, you can make all the constructors private. And then people can't use it because if they try to declare a variable, it'll go, oh, you don't have you don't have access to a constructor. Hahaha. I've actually done this. Um, not not just to be mischievous, but because the class was designed not to be used directly, the it had a slightly different interface and I didn't want the clients to be in charge of initialization. So I did sort of a different thing. Um, so the answer is you absolutely can do that. Generally speaking, it's not done. Um, so here's how you use yours, how you use overloaded constructors. This is really important because don't write parentheses here. If you want the null reconstructed because it's ambiguous then then it looks like C1 might be a function that returns a car. So if you. So the rule in C plus plus again Java people pay attention. When you when you create a new instance if using the default constructor. No parents no decorations, just the name of the variable comma or semicolon be done with it. Right. So that's that. Um, there are two ways to, to initialize, um, an instance of a class with another with a Non-default constructor. The old fashioned way is to use parentheses. But I just mentioned the ambiguity. And so that's why they got rid of the old way. Um, so you'll see, the reason I put it here is your book will use this because I think it was written before they introduced the other one. So I think that's my memory. Anyway, you'll definitely see code like this, but you should use the curly braces because then it's not ambiguous. It's not a function that returns a card. It's I'm initializing it. And these are the these are the parameters to the constructor for initialization. Um, and similarly when you create one on the heap you use new. You write the name of the class and then old fashioned way with friends, new fashioned way with Curtis. All right. And again you'll see examples. Yeah.

So if you wanted to use the constructor with.

No parameters, you could.

Also just put an empty braces.

No o empty braces. Interesting. I don't know what happens. I've never tried it because it was just I got so beaten up by using them incorrectly before the curly braces were an option that I never bothered to even try. Um, so I wouldn't do that. I wouldn't do that.

So, um, is this only for class creation, like we would only or is it for constructor?

No. And in fact, you can use this initialization syntax for anything you can do int and curly brace one. So the initialization syntax is curly braces. And it was always that way for other for for arrays in in C and C plus plus they just extended it to everything else. Okay. Um, so C plus plus made it more consistent. Okay. So, um. All right. I want to get started on the implementation. And we can always come back to to things like this if there's time. Excuse me. So if we're going to implement, um, a list that can change size, there are several ways we could do this. There's a gazillion ways we can do it. We're going to study two in detail. And in fact, this one has a gazillion variants just to itself. Um, we're going to look at something called a ray lists first, which is the Java name for this thing. Um, C plus plus calls them vectors. But I don't want you to confuse the built in thing with what we're doing here. They're the same functionally, but now. But somebody else has led to that one. You're going to implement this. So that's the difference. Um, so we're going to start with this notion of an array list. And it's called an array list. That makes a certain amount of sense. But if I had to implement a list. Could I just use an array?

Um.

Well, maybe I could. Um, what properties of an array would would make it hard? Um, in the back of your mind? No. You you. Yeah. I'm sorry.

Uh, it would be that, uh, arrays would have a fixed, fixed size, and it can't change from that.

Perfect. Perfectly quick. Yeah. So when you make an array, you have to say in advance how many elements it has. So at least you have to know the maximum possible for the whole application for all of eternity. So this is a logical impossibility. You can't know in general. I mean, we used to just live with it and then the program would break if it got too big. But we kind of want to do better than that. Um, an array cannot change size in C plus. Plus, once you make an array, you have to say how big it is, and then that's how big it is for the entire lifetime of the array never changes size. There's another feature of arrays in C plus. Plus. It's very interesting. If I'm a function and you pass, you try to pass me an array. I don't get the array, I get a.

One I.

Don't, I get a pointer, I get the address of the beginning of the right. So now I've got the address at the beginning of the of the array. Can I find out how big the array is? No I cannot. There's no way people in 4D go crazy with this because they'll look at the thing in memory and they'll say, how big is it? And the answer is, you can't be sure. You can't be sure. There's no way to really look at it and tell. So this this is telling us something. So can we use an array like that? No, because this will be ten elements, always ten elements. We also have to keep track of how many slots we're using if we're not going to use the whole thing. Right. Um. So we're going to use addresses and pointer variables and heap allocated arrays to give the illusion of it. Right. So what happens is you know so I've got a list that can store only one thing, but I'm hiding it so you can't see it. And so you say I want to add something to the list. And I go, sure, give me your thing. You know, then when you ask for it, I give it back. And then you say, I want to add a new thing. And I go, okay, uh. Hold on. Sure. Give me the new thing. Right. Okay. So I left out some steps, but that's that's the basic idea, right? The I guess I could where now? I'm sorry. This is implementation day, so no hats, no hands. Um, okay, so here's what we're going to do. Um, I've pre drawn the memory diagrams. Um, you need to draw these memory diagrams by hand and Tas, if you ask for help, we'll ask one of the first questions I tell them to ask is draw a picture of your data structure at this point in the program. And if you can't? We'll say, okay, we'll go do that and come back when you have a drawing. Right. So you need to do this. Um, and so I'll show you some examples. But there's a thing on the resources page how to draw a memory diagram. So just look at that and practice. Um okay. So what we're going to do is we're going to instead of making the array here in main, we're going to create the array on the heap. Okay. So this is the stack over here. So this is where all the data that all of the function variables are going to be stored over here. And then here is the heap memory definition. The lifetime of an element on the heap goes from the time someone calls new for it. Until they call delete on that same location. Right. So the lifetime is completely up to the program. The lifetime of data here is the lifetime of the function or block the variables in. Right. So when Maine has done this, this variable here will automatically be recycled. Um. This one. Is a little bit special, but, um. Okay, so we've got this thing, and then suppose we store data. Okay, so we put four 3324 minus nine. Um, we can use the same array syntax that we would use if the array were locally. So that's part of the point here. Um, okay. So now we've filled up the the data structure. I'm not telling you how we know this. There's other programing going on, but we've kept track. And so what are we going to do. Um, if we want to add something. Well, um, if we, you know, if we could play this trick, that's that's good. But we have to be very careful because there are a lot of details we're going to have to manage. So I'm going to go through part of it here. And then we'll go through the rest hopefully later on today. So here's how you do it. You say okay well that array is now I can't change the size of that array. Right. I can't go back to the heap and say, you know what? Eight. Make it eight. You can't do that once you've because it might have put something else right behind it. So you can't do that. So what you do is you say, give me a new array that's twice as big. And of course, whenever you use new, new gives you back an address. And so you have to save it somewhere. So I'm just going to make a variable. I'm calling it temp because I'm not very creative. Um and so that's my temporary um array. Well now of course it has a, it's twice the size of the original one, but it's deficient because it doesn't contain the data. Right. So what are we going to do. We're going to copy the data over. You know how to do that. You write a for loop whatever. Okay. Um, once we do that now this is key. I've allocated two elements on the heap. I'm going to use the big one. Now I don't need the little one in C plus plus Java and Python people pay attention. I must explicitly say I'm not going to use that anymore. We use the delete keyword for this. And then the heat manager now can give that memory to somebody else. Because I've said I don't need it anymore. It will trust me. So that means I have to stop using it. Okay. Now the final step is we just let whatever we the place we thought the array was. We have that point to the new one now. And now. If code is using RR to get to the data, it still works. It just has more spaces. So did you get those steps there? Going to be a couple more in a minute, but.

Um, yeah.

I said this already. You have to draw the arrays. Um, okay. So now the the thing we call RR can store twice as many elements. This is a classic thing in computer science. It's been written that every problem in computer science can be solved with just one more level of indirection. Um, so we're not going to store the array here. Instead, we're going to store the place in memory where the array is. And now we can change that variable RR so that instead of going to the where the array used to be, it goes to the place where the array is now. You couldn't do this if the array were in situ in Maine. You couldn't do that. Um, okay. The heat gives us I said that, um. Uh, array list. We sort of done that. Okay. So now, um, I'm a little bit behind, but I will endeavor to speak more quickly. Okay, so there are several things we have to keep track of. We talked I think we talked about this last time. Obviously, if an array list is going to keep track of lists of things for the client, it has to store the data somewhere. So there's that array has to be somewhere. We have to store the array. We're going to store that as the address in the heap of where the memory of where the the list starts. That's how we're going to do it. Um, we also have to store how big that thing is in the heap. We call that the capacity. That's one name for it. I think Java also calls it the capacity. That's what we say in CS 15. So that's how big the array is. But we're going to we're going to play a game where we don't use it. We don't store exactly the number of elements that the client wants. We have some extra space. And I think I mentioned that last. So we have the the data. We have the capacity of the array and then the number of elements currently being stored there. Okay. So you have to keep so three elements of state. We're going to have to keep track of those things. This is all going to go in the private section of the class right. So I'm just enumerating. Then we're going to have to have some other operations. So the main one is we're going to have to change the capacity of the array we've just seen. We're going to have to go through these steps. And these are the steps will allocate a new array will copy the data to the new array will recycle the old array will update the pointer variable in the object so that it's using the new array. And then the the last thing that didn't come up last time is we just changed the capacity. The old array was of size four. Now this instance has eight slots. So we have to update that to oh okay. You'll store this in a map and hopefully I can get uh okay. Important all of that stuff. Client doesn't care. All of that client doesn't need to know that. Um. So we're going to use abstraction encapsulation to do this. Okay. Um, so I think I'm going to try some live coding. We'll see how it goes. Um, but I want to make a point that we did not start with C plus. Plus. Right. We've spent a lecture and a half not programing in C plus plus. For the most part that's because C Plus Plus is a great programing language. Industry standard. You know if you've played a game it's probably in C plus. Plus it's widely used. Great programing language, well supported. But it's a terrible thinking language right. Nobody's native language is C plus plus. Right. Did your parents go oh no.

No they didn't do that.

So so so nobody thinks this way. Um, and it's a, it's a danger to just open up an editor.

And say, oh, I mean, you know.

Um, don't do that. Um, no. What you want to do first, draw the pictures first. When my my colleagues and I work on something, we almost never actually write the code together. Sometimes we do, but we'll say, hey, you do this thing, you do that thing. But what do we want? Well, we we want files that go, this is this is going to contain. Here are three elements. I guess we'll maybe we'll put them in this order. And then we'll do this when we draw pictures of the data structures. And then we draw maybe some.

Very.

Loose algorithms, but you can almost read the C plus plus from the picture if you have the picture. But if you write the C plus plus first life gets weird because again, you didn't grow up speaking C plus plus. So we identify the problem. We sketch what we need. We draw lots of pictures. Um, we do incremental development, which I'll try to show you a little bit today. Um, incremental development means that you don't write the whole program at once because program complexity goes up exponentially with program size. So if a ten line program is not too bad to debug, a 100 line program is not ten times as bad, it's a thousand times as bad. You see the problem, right? And so it goes up like that. So that means the number of debug lines in your code basically is how much time you're going to spend trying to debug this thing. So you want to keep that number very small. So you write a little, you test a little, you write a little, you test a little. In real life, I almost never write more than about 2 to 5 lines before at least compiling. And often I'll test at five lines sometimes if I'm feeling really, you know, hyped up on caffeine, I might write ten. And then and then you write, um.

Okay.

So, um, oh, and I'm going to do a little bit of manual testing because you haven't seen the test framework, which you'll learn in lab. And I'll talk about separate compilation in Lincoln. That's important to me. Um, okay. I'm not going to follow the course style guide because I have very limited screen, but you can expect to to read your whole file so you don't you're not so constrained. Um, okay. So let's stop that and then, um. Maybe I'll share my screen. That'll be easier. Um, now you guys are using VS code. You go right ahead. I'm going to use Emacs. Um, so in the upper left. So I've just taken my Emacs, which is the editor I've used, and I've divided up its, its screen into four chunks. On the left you see the h file which we've seen before, right. Nothing new there except I've replaced Ellen type with int because we're going to store integers. Otherwise it's exactly the same. Um, in the upper right I have my implementation file. I've started to write it. Um, and I have a constructor and a destructor because those are like the first two things on my to do list. So I'm going to do that. Write. The thing on the left is kind of my to do list as a as an implementer. Okay. Um, on the left. Lower left. I'm going to have a testing program, you guys. Like I said, we're going to use the test framework, but. So I'm just going to make up a client whose only purpose is to allow me to do some testing. And again, not very rigorous because in class we have limited time, but that's there. And over here we have a shell. So that's what's going on. If I type ls over here, you'll see the files that I was just talking about. And there's a thing called a makefile, which we're going to learn about later. So you don't have to worry about that. Um, okay. So here's the interface into a list. Who has said the name. Right. So the interface is basically this part. Yeah. Plus associated comments. Um, oh, and I've added another constructor Y so that we can practice using overloaded constructors. That's uh, um, that's there.

And uh.

No, that's not it. So some of you will freak out by these things that begin with pound. Don't worry too much about it. They're called include guards. We can talk about it later. Um, in large systems they're really important to do. But there's three lines. There's these two at the top and this one at the bottom, and they're pretty much all the same. You just replace it with the variant based on the name of whatever it is you have. Otherwise it's the same. Um, okay. I think that's that. And. Oh, right. So down here in the lower left we have the client note the client pound includes into a list each. Right. Everybody see that because C plus plus when it compiles the client has to know oh you have access to a radius do you. You have to the client has to say what it's going to use. So it includes you'll see the implementation also includes it because the implementer has to implement all of those things. And so you want to make sure that all the functions have the same types. And right. It would be a shame if you mix these things up and then the client couldn't use them because you put the arguments in different orders in the implementation or something. So those 2 pound include of into real estate. Make sure everybody's playing by the same rules. Um let's see. Um, okay. So a quick aside in how we build programs, we're going to build programs in phases. I don't know how they do it in 11 these days, but we're going to do it in phases because you can get errors at different phases. And the kinds of errors are different and how you fix them are different. And if you think about them separately, you can save a lot of time. So would you like to debug in ten minutes or would you like two hours? I think ten minutes. So, um, but that does mean you have to learn a little bit more. So the way this works is we try to compile each of the CPP files separately, never compile files. It does do something, but it doesn't do what you think. And you will later have problems if you ever change anything again. So just don't don't compile h files. And. So we're going to use a compiler called Client Plus. Plus you might have used G plus plus in which case you write that. But we're going to use Clang plus plus whenever you compile you should always do Wall and Westra. I would like all of the warnings please. And in addition to all of the warnings also give me the extra warnings because for reasons I don't quite get all doesn't mean all, it means it means all circa 1998 or something, I don't know. So extra means the ones that came later, I don't know. Um, if you ever debug with some of the debug tools, you'll use dash G. You can leave this one out in CSS 15 and probably be fine, but I use the debug tools a lot, so I always include it. Um, and then um, we want to put the file that we want to, um, compile. So let's try, um. Integrate. Escape. Um. Okay. Everybody. Okay. Um, by the way, I really start out this way. I write, like, lists of functions, and if I put them in, I'll just write to do or something by them. I always start out like that. And my main always starts like this. So do not scoff it, because if this works, this means at least look, I included this. So this syntax checks the file, right? So I can test that without writing any other code to to do it. So now does anybody think they know what's going to happen.

Oh no. Oh no.

What happened.

Okay.

Well the compiler doesn't just compile. It does. It does several things, but two that matter. Now it compiles, which converts the code to binary. Take the C plus plus code. Turn it into binary for this machine and then it does linking, which takes all the modules you need and puts them together. So this compile fine. I didn't get any compiler errors for this. This is not a compiler error. How do I know? Linker command whose name is LD? LD is short for linker because it used to be the linking loader, and then they change the name without changing the program. Um, so so this is telling me that the linker command failed. So syntax is correct. Types are correct. Good, good. But I have this problem because the linker was trying to make a whole program. But you can't have a whole program without a main. So there are two solutions. We can give it a mean or we can tell the compiler, we can tell clang plus plus not to not to link or c means compile only, so just compile. Don't link. Watch what happens. Now it works. So what I said works. But what does that even mean? Well, I told you to check the syntax on the types. And if we do ls, you'll see there's a dot o file which is called an object file. So the compiler translates c plus plus source into binary what's called object code. And then it just saves it for future linking. Right. So now it did the translation. All of that worked. Now we have to do this to all of the.

Um.

All of the modules in our system. And yet does that get tedious? Yes, it does. And we have a solution to that. Um. Right. If I o that works because I'm not actually using it. So that's interesting.

Um.

Okay. And that means I can run it.

Uh. Oh. For ages. You got to. Not down there. Oh, because I misspelled.

Oh. Thank you. How many GS does plain plus plus have? Uh, yeah. There we go. Okay, now I can run it. And it went in a weird place called a dot out. Okay. Um, so. And there's my return zero. So I got zero back. So that's returns zero. So let's make it fail, because that's more fun. Let's make an int array list al1. So now. That should fail because the syntax is right. As far as it knows, the type is right, but it doesn't. It doesn't have any implementation for the ArrayList. It needs that stuff. So how do we do that? We have the 2.0 files I hope. Oh decent. Okay I'll do it later. Okay. So now let's let's do dash C. And now we have 2.0 files. So compile each module get a file. Then we link them together using clang plus plus again. But this time with one g. This time we just have the audio files array. Oh. We missed. If you see me make a typo please let me know. Int array list. And let's put the output. As necessary. But I'll do it anyway. Let's store the output in a program called int array client. So dash o means store the output in the thing that comes next. You can't move these independently. So the next thing is the following. If you put your cpp file there will destroy your cpp file. So don't do that. Okay. So now what have we done. We've compiled each of the cpp files into zero files. Then we linked the 2.0 files together to make a runnable program. And now we're going to. Run the program. There's our return zero. Now our our constructor and destructor are wrong. But since we never actually use it for anything, it doesn't hurt us. But let's fix it, shall we? This is a good point. Any questions? Because now the implementation really starts.

So that other ways.

To link.

Say the int ArrayList client and inter LSH files, other than what you just did, you might using the ceiling and the object code.

So be careful we don't link h files, we include them and then include just basically copies and paste them in line. We link the O files which come from compiling the cpp files.

So it's different.

So it's different. Yeah cpp includes dot h files because the compiler needs that to determine type correctness and all that stuff. Right. Did you pass the right arguments all that stuff. Um, so that's that's happens in the compiler phase. Then the linker phase takes things where all that's already happened and then just glues them together and says, oh man, you're calling a constructor for this thing that's over here in this file? Got it right here.

UNKNOWN
Right? Yeah. Okay.

So, um, We have our three elements of state. So in any constructor you should always initialize your elements of state. Yes.

Oh sorry, I had another question. Could you explain what the dash and the O was, was again um.

So inter readiness O is the object file you get from compiling into Lisp. This is just the C plus. Plus turned into the local binary representation of program code. Okay. Um, the hyphen O is a message to clang plus plus saying when you link these things together, instead of putting them in a stupidly named thing called port, would you put them in this place? Okay. So this just changes the name of the output file to be something I like.

Okay.

But you can't mix it up if you put the dot o file over here and it'll like destroy things. So these, these two things come together. You have to put them together.

So then going through that entire thing of putting the zero at all necessary.

Um, well, we're going to automate it in a minute. But if you don't understand what's happening, then the automation doesn't help you. So I want you to understand how it works. Do it yourself like 200 times and then use the automated tool. That's nice. Well, in the homework we'll use that will give you the automated tool. Okay. So what do constructors do. They initialize the data members. So we have three data members here right. So let's let's initialize them. Curses. Well nobody stored any elements in here yet right.

Um.

Capacity. Um, I'm going to play a trick because in the lab you're going to start off with, I think two or something. So I'm going to say zero. And because I'm going to have fun doing it. And then since the capacity is zero, I'm not going to allocate a zero size thing on the heap. So I'm going to do this null pointer. So this is how I'm going to represent the initial empty. Um, ArrayList. Later, if you remove elements, I might not get back. But this. Does anybody understand what's going on here? It's a little bit weird. It's saying nobody stored anything yet. Size is zero. I don't have the capacity to store anything. And since I don't have the capacity to store anything, I don't actually have an array. So I used a null pointer for that null pointer. Do you have to do it this way? No. You'll see a different way in lab, which is why I'm showing you a different way in lecture. Just so you see two different ways to do it. Okay. Um, so constructors initialize. What do destructors do?

You know, the cleanup.

Now in this case. For the first one we're just going to have null pointers. But if you run this for a while it's not always going to be null. In general the way this is going to work is you're going to have a data array on the heat. And so at the end you need to recycle it. So we just have to do that. And we do that with the delete keyword delete. Um little C plus plus. So all of these things are going to be erased. So they're going to be allocated with square brackets. If you allocate with square brackets you have to delete with square brackets. If you don't weird things happen and it bugs me. But I think they ought to be able to tell that. But apparently they can't. Um, okay. So we've done that. And so now at the least I would test this again and I'm going to use a shortcut now. So I didn't save it. So I was wondering why didn't it, why didn't it say there we go. So now we have a tool called MiG which was designed for making programs for building programs. And what it does is it compiles. It compiles all the things that have changed. And then anything that needs to change as a result of that. So this automates all those steps. You should know all the steps. Okay. So um, do we know it works? Well not really, but we know it doesn't kill anything yet. So we have a little bit of, you know, celebrate the small achievements.

Yay! Didn't crash. All right, um.

What are we going to do next?

Uh, blah blah blah blah blah blah blah blah blah. Oh, I know what.

Um, let's do the size and is empty functions because those are those are not too bad, right? So let's go ahead and add those. Um, so size returns an integer. It's a member of the int ArrayList class and its name is size. And it doesn't take any parameters, and it has a body that we haven't figured out yet.

Um.

So because we have the, uh, the class definition in one file in one place and the, the definitions of the functions outside the class, we have to say to C plus plus this size function is actually part of the interface class. If we didn't then it would just be a freestanding size function. So if you want to because this isn't inside the class, it's in a separate file. Whenever you want to associate a thing with the class, you have to say so. And so you list the class and then use the colon colon, the scope resolution operator to say, hey, I'm inside the introduced class because, all right, you're inside the intermediate class. This means I can access the data members. Um, okay. So how do I know if what the size is? That's the size, right? Now, how do I know if that works? Right. So, um. Now, since I haven't figured out how to add elements to the list, I can still test this a little bit. What I can do is I can say print to see out. Um. Initial size should be zero. Okay. Let's see, what do we think? I think it's going to work well, so that's good. That's not normally. Usually I make a typo.

That's for my kids. So. There we go.

And it is zero. All right. Do a lap around the room. Buy some popcorn. Here we go. Um. Now again, we haven't tested this thoroughly. We have to make sure. We have to test it again when we start adding new elements. But we're off to a good start. And so the next one is is empty.

I almost forgot.

Okay. How do I know if it's empty?

It's.

True. It's always empty. False. It's never empty.

How about if I buy?

If I ask for the size and if that zero, then it's true. And if it's not, it's false. That sounds pretty good. So then I can do the same thing again. But what is it called?

I'm going to be a little bit better here.

So blue Alpha I think that'll work if it doesn't all change it in a minute. Um, L1 dot is.

There's one issue with Norman.

What did I screw up? Undefined symbols so it didn't link.

Oh.

Guess who forgot to save the file.

Ah. All right. Okay.

So now how much time do I have?

Oh, this is interesting.

Okay. Um, so let's do add. Let's do element dag, because that one's very easy at first. Okay. So here's what you want to. Here's what you're tempted to write.

Is that ever wrong?

If the answer were were no, I would not be asking. So the correct answer is yes. And in what circumstances is it wrong?

If it doesn't, if it's not in the thing.

Yeah. So, um, so to do check bounds. There we go. And then, uh.

Add it back.

All right. So, um. First let's just ask it. Suppose there are, there are n elements in the array. What is the next free slot in the array. If it has a first.

Is it that slow?

Well, if by hedge slot, you mean slot zero. That is true the first time. But in general, suppose somebody already put five elements in and we want to add something at the back. What's the next three. So suppose there are three things in. So there's something in slot 012. The next three one is.

Three.

Is three. And in particular that's always the sixth position right. Because the indices always go from zero to size minus one. So what we'd like to do is say data size.

Yes. Hello.

And now we've added one more element. Right. So that means that the size the increment. There's one more element. Everybody okay.

Uh, when this.

Uh, return or fail if the.

Um, size.

Is over capacity.

This is absolutely going to fail if the size is over the capacity. So this is a bug so far. So we have to think about that, right. Um, so what am I going to do about it. So this is the code that you want to write when there is spare capacity. So what do we what do we say then? If you like.

You check if size is above capacity.

Uh, yeah. Yeah. Or if it would be above. Right. So if we, if we have the invariant that we never let it get, it can't be equal to if the thing is valid because the number of elements can't be. But the number of elements can be sized, but it can't be greater than six. So if.

Okay.

So now we can do that.

Right? Are you right?

Hold on, hold.

On, hold on.

Okay, so now let's, uh. Right. So if size is equal to capacity, we now have to do our trick. Right? Now that turns out to be really useful. So I'm going to write that in a separate function. So I'm going to say if size is equal to capacity you know what double the capacity. Now there are a variety of ways to do this. But this is a thing we can do. Oh okay. Well that was easy. Except now we have to write double capacity. But the point is that we're going to make sure that double the capacity is always and is always at least current size plus one. That's important. Now initially we have a capacity of zero. So there's a little bit of a not quite doubling but zero times two is still zero. So we'll have to solve that. Um, let's go ahead and compile and make sure I didn't screw something up though. I did oh it's undeclared. Well, um, let's declare it. Why am I doubling? It's because if you add one more, I know you're going to be back in a few nanoseconds asking for more. So I'm just going to. I'm just going to get some spare space. And always, you know, whenever I have to increase, I'll just get more than I need in the hopes of going to sleep for longer in between visits. Um, okay. So we have to double the capacity. Okay. Um. Oh, we have to do this, and it's not going to compile again, but let's see if you can follow while. Why? Out of line definition. Basically I'm defining a function and saying is in the array list. But there's no nothing in the array list with that name. Um, question. Public or private? Private. You guys are getting it. That's fantastic. Why is this not a problem? Um. Well, I think because I changed my indentation settings in between setting it up, you know. Okay, I can fix that for the next lecture. So let's see. This should at least compile. Maybe. Let's see. Yeah. It compiles. Now it doesn't do anything. So what do we do? Well, we know what we have to do, right? We have those steps. Um, make a new array. Copy the elements. Um. Recycle old array.

Um.

Update data.

Update the capacity. Right.

So. Okay, well, so now we have our little outline we just go through. So, um. How big should it be? Capacity times two, I think. But usually I do this in two steps. I'll do it in one now. The interest of time. Um, but of course the initial one is zero. So this is a special case. Again, the client doesn't care, but I happen to know that, um, so I'll add two, which, by the way, is what Java does and why two one would suffice. But if you do two, apparently the math works out nicer when you take 160. So just just wait till 116. You get the answer and then your proof is much prettier somehow. Um, okay. So now. So now I have my new array. Uh, we have a copy of. It's four and I get zero. I less than the passenger side by side, because we only want to copy the elements that are being used by the client. Why copy garbage that the client doesn't even know it's there. Um. Not yet. I haven't put the size of the element, so we're going to go zero up to, but not including size. So up to and including size minus one. So that size of us because we started counting at zero. So if there are three elements in the array size is three I'm going to go through elements zero, one, two. Now I've copied three elements.

No I mean.

Uh shouldn't size be equal to.

Oh, oh in this case yeah. When this function runs, maybe that's the general assumption. I'm going to assume that people might call me to double the capacity for some other reason. So, um, that's interesting because I'm not going when I write this function, I'm not going to assume only a single person is going to call me. I'm going to write it whenever you want to double the capacity, I'm going to do this. You could wait until it fills up or you could do it or maybe, um, okay. So that's great. So we have.

New.

Array sub. I get data sub. I be okay with that. Everybody right? Uh, recycle the old array. Delete. Don't forget the square brackets. Data.

Update the data. Data gets.

New array. Update the capacity. Ah, this is why I do it this way.

Oh thank you, thank.

You, thank you. That's really helpful. I'll come back and get it in a minute. Okay. Where's the missing semicolon? Yeah. There we go. Got it. Okay. And then these comments, you don't need to comment that because what else would that do? You don't need to comment that one. You don't need to comment that one. Um, I'm finicky about stuff like that. And copy elements. That's okay. You don't need that one. All right. So I think we're all right here. Yeah. Now, if I go down here and I type make. That compiles. But we haven't tested it yet. And so what time is it? I've got one minute. One minute. Uh, al? One dot. Uh, back. Negative one. And then I would do a print statement here. Um. And then hopefully this works. But if not, we'll see the thrilling conclusion.

That's not going to work. You've got brackets. Oh, correct.

We'll see that there's actually a way that you can do that. But.

This is the one.

You guys are great to hang out in my office when I'm programing. I would really like to.

UNKNOWN
Okay. That's good.

I think with 30s to spare. All right. So go and have fun with the lab on Tuesday and I will see you on Wednesday.

Oh, my. I gotta go faster. Oh. Yeah. Yeah, I don't think so. I think. I missed, I missed record.